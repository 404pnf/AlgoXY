\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
\input{../../../common.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Comparision of imperactive and functional implementation of binary search tree\\
排序二叉树的命令式实现与函数式实现对比}

\author{刘新宇(Liu~Xinyu)
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline
  }

\markboth{Binary search tree}
{imperactive and functional implementation}

\maketitle

\ifx\wholebook\relax
\chapter{Comparision of imperactive and functional implementation of binary search tree}

\section{abstruct}
\else
\begin{abstract}
\fi

由于作者水平有限，文中难免有谬误之处，欢迎广大读者指正！
本文使用\LaTeXe排版，遵循FDL(GNU Free Documentation License)许可协议。
并受其保护。具体请参考：http://www.gnu.org/copyleft/fdl.html

\ifx\wholebook\relax\else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} Epidemic simulation, Squeak, C++

{\bfseries Corresponding Author:} 刘新宇

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

%\begin{verse}
%子曰：学而不思则罔，死而不学则殆。%\\
%\end{verse}
%\begin{flushright}
%――《论语》
%\end{flushright}

%\begin{figure}[htbp]
%       \begin{center}
%	\includegraphics[scale=0.5]{images/peace.eps}
%        \caption{from www.zikai.org}
%       \end{center}
%\end{figure}

去年地震灾害的时候，我就常常问自己：“抗震救灾，一个普通的程序员能够做些什么？”Google很快
给出了灾区的地图，各大网站及时报道救灾的新闻。可是对于普通程序员来说，如何才能发挥所长，尽
一份贡献呢？当前，正值甲型H1N1流感在世界蔓延，这个问题再次引起我的思考。

希望能通过这篇文章，尽我自己的一点绵薄之力。我将依次通过计算机程序给出一些直观的仿真结果，包括下面的几种情形：
\begin{itemize}
\item 传染病发生时，如果不采取任何防治措施时的传播速度
\item 具有一定传染概率时的传播速度；
\item 公众自发防防治，主动采取隔离措施，及时治疗时的传播速度；
\item 疾病带有一定潜伏期时的传播速度。
\end{itemize}

\section{Kedama, a simple epidemic simulation example}
\label{kedama}

著名的Smalltalk程序员大岛芳树(Ohshima Yoshiki)曾经为squeak开发了一个叫Kedama的项目。这个项目现在已经是
OLPC(one laptop per child)中Etoy的一部分。它可以非常直观地模拟疾病的流行\cite{kedama}, 西邮Linux兴趣小组
的同学们曾经帮助翻译了中文的介绍文章\cite{kedama_cn}。下图是Kedama运行过程中的一幅截图：

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{images/kedama.eps}
        \caption{screen shot of kedama}
       \end{center}
\end{figure}

图中，黑色的方块表示一个封闭的区域。区域中一共有1000个点表示在其中自由运动的人，红色的点表示已经感染某种疾病的个体，
而绿色的点表示健康的个体。健康的个体如果接触到染病的个体就会被传染。Kedama的设计非常直观，其运行结果也非常惊人。
在完全自由运动的情况下，疾病在非常短的时间内感染了所有的人。

虽然Squeak和Etoy被设计为针对8到11岁的儿童学习使用，但是考虑到国内了解Smalltalk的人并不多。作者下面用C++来实现
一个类似的模拟。

首先是建模问题。其中一种建模方法是采用简单的“暴力”解法，如果需要模拟一种疾病在1000个人中的传播，就开启1000个独立的
线程，每个线程代表一个人，并行在某区域内随机运动。其中一个线程被设置为已染病个体。每个线程在随机运动过程中，都检查和
自己遇到的其他人，是否已经染病。和染病线程接触后，自己就变成另一个染病线程。

这个方法，虽然看起来直观，然而却有两个问题难以解决。第一个问题是性能问题。虽然在现代多核计算机上，同时开启多个线程
的性能已经大大提高，但是如果模拟人群的规模增大，例如模拟大型城市如北京、上海的上千万人口，同时开启几千万的线程，这样
的计算，恐怕要使用超级计算机了。第二个问题是一个算法问题，也就是每个线程代表的人在独立运动中，如何判断自己和其他线程
代表的人接触到了？是否要在全体线程中做一个查找？如果是这样，完成某个人走一步，然后进行查找的算法为线性算法，其复杂度为$O(n)$，
n个线程的计算量为$O(n^2)$。这是非常大的计算量，算法的效率会非常低。

根据Kedama的启发，在做出一定的化简后，可以找到一个简单、高效的方法。假设需要在$W \times H$平方米的范围内，模拟
某种疾病在N个人中的传播。我们可以将区域划分为$W \times H$个格子，也就是每平方米一个格子。然后我们建立N个对象，放入
一个列表。每次模拟遍历一遍这个列表，让每个人独立走一步；同时，我们检查这个人是否染病，如果染病，我们就标记他所在的
那个格子（也就是那一位置所在的1平方米）为污染区。之后我们重新遍历这个列表一次，检查每个人所在的区域是否为污染区，如
果一个健康对象经过运动后进入了污染区，他就被标记为感染。我们的模拟程序不断重复上述的两步过程：移动――感染，直到90\%
的人染病后，程序退出。

下面我们来一步一步实现上述程序。首先是区域的建模，这部分非常简单。类定义如下：
\begin{lstlisting}
struct area{
public:
  area(int w, int h):width(w), height(h){
    cells=new char[w*h];
    reset();
  }
  virtual ~area(){ delete cells; }

  char* at(int x, int y){
    return cells+y*width+x;
  }

  void reset(){ memset(cells, 0, width*height); }

  int width;
  int height;
private:
  char* cells;
};
\end{lstlisting}

其中cells是一个buffer，代表的是w列、h行的二维格子，我们将用它来标记污染区。之所以
采用原始的buffer，是出于效率考虑。我们可以通过memset和随机访问操作，快速地重置污染区
和访问污染区。

之后需要对人进行建模，对于在疾病传播模拟程序中的人，我们只关心两个方面：1，他是否染病？2，他
目前在哪里，向哪个方向以多快速度进行运动？对于1，我们可以以一个bool量来代表；对于2，我们
需要对位置和运动信息建模。这一模型如下:

\begin{lstlisting}
const int  MAX_SPEED = 50; // walking speed: 50 [m/min]
struct physics{
  physics(){}
  physics(int _x, int _y, int _s, int _d):x(_x), y(_y), 
      speed(_s), direction(_d){}
  physics(const physics& p):x(p.x), y(p.y), 
      speed(p.speed), direction(p.direction){}
  physics& operator=(const physics& p){
    x=p.x; y=p.y;
    speed=p.speed; direction = p.direction;
  }

  bool operator==(const physics& p){
    return x==p.x && y==p.y && speed== p.speed && 
           direction == p.direction;
  }

  void move(double dt){
    x+=static_cast<int>(static_cast<double>(speed)*dt*
             cos(static_cast<double>(direction)/180.0*pi));
    y+=static_cast<int>(static_cast<double>(speed)*dt*
             sin(static_cast<double>(direction)/180.0*pi));
    speed = rand() % MAX_SPEED;
  }

  int x;
  int y;
  int speed;
  int direction;
};
\end{lstlisting}

物理量包括位置坐标x,y，以及运动的速率speed和运动的方向direction（本程序中使用角度）。定义拷贝构造函数，赋值以及相等
是为了方便操作。其中值得注意的是运动函数move，它接受一个运动时间小量dt，然后在二维平面上以当前的运动速度和方向更新位置，
最后再更新运动速率。考虑到人在步行时的运动速率为3km/h，我们的最大速率设置为50m/min。

有了物理运动信息，接下来就可以定义被模拟的人了：

\begin{lstlisting}
class person{
public:
  person(bool x=false):_infected(x){}
  person(const person& p):_infected(p._infected), _loc(p._loc){}
  person& operator=(const person& p){
    _infected = p._infected;
    _loc = p._loc;
    return *this;
  }

  physics location() const{ return _loc; }
  void set_location(const physics& l){ _loc=l; }
  bool infected() const { return _infected; }
  void set_infected(bool x) { _infected = x; }

  void move_inside(area& a, double dt){
    _loc.move(dt);
    if(_loc.x<0 || _loc.x>a.width)
      _loc.direction = (180 - _loc.direction + 360) % 360;
    if(_loc.y<0 || _loc.y>a.height)
      _loc.direction = (-_loc.direction + 360) % 360;
    if(_loc.x<0)
      _loc.x=-_loc.x;
    if(_loc.x>=a.width)
      _loc.x=2*a.width-_loc.x;
    if(_loc.y<0)
      _loc.y=-_loc.y;
    if(_loc.y>=a.height)
      _loc.y=2*a.height-_loc.y;
  }

private:
  bool _infected;
  physics _loc;
};
\end{lstlisting}

这段定义中，除了构造、拷贝、赋值以及getter/setter之外，只有一个move\_inside函数，
它是模拟人在某区域运动的关键函数。该函数接受一个区域引用和一个时间小量。然后调用前面
定义的move函数更新物理信息。如果发现人已经运动出所限制的区域。程序按照物理上弹性碰撞
的规律，将人限制回区域内，并让他的运动根据弹性反向。读者也可以不采用弹性碰撞，而使用
其它物理模型。

模拟程序的核心，是一个被称为scheduler的类。之所以起这个名字，是因为它的运行上，本质
类似于一个调度器――依次取出列表中的每个人，然后让其运行\cite{ao}。首先它被设计为一个
singleton：
\begin{lstlisting}
class scheduler{
public:
  static scheduler& inst(){
    static scheduler _inst;
    return _inst;
  }
  //...

private:
  scheduler(){}
  ~scheduler(){ 
    delete a; 
    for(Population::iterator it=people.begin(); it!=people.end(); ++it)
      delete *it;
  }

  area* a;
  typedef std::list<person*> Population;
  Population people;
  int n_infected;
  std::list<int> diagram;
};
\end{lstlisting}

scheduler拥有一个指向模拟区域的指针a，一个记录全体被模拟人口的列表people。一个记录已染病人数
的变量n\_infected，和一个用于将模拟结果写入文件的列表diagram。scheduler在最后析构时会释放
所有被模拟人的对象。这里之所以没有采用person对象的列表，而采用了person指针的列表。是因为在语义
上，我们并不关心不同个体的差异。我们并不能说，在同一位置，以同一速度运动的不同对象是相等的，因为
他们完全可以是不同的人。

scheduler在初始化时，设置好区域，创建出n-1个健康个体和一个染病个体。然后把他们随机放入区域中
的各种位置。并设置目前的染病人口数为1。

\begin{lstlisting}
const bool INFECTED = true;
class scheduler{
  //...

  void setup(int w, int h, int n){
    a=new area(w, h);
    for(int i=0; i<n-1; ++i)
      people.push_back(new person());
    people.push_back(new person(INFECTED));
    put_people(people, *a);
    n_infected = 1;
  }

  //...
private:
  template<class Coll>
  void put_people(Coll& coll, area& a){
    for(typename Coll::iterator it=coll.begin(); it!=coll.end(); ++it){
      (*it)->set_location(physics(rand()%a.width, rand()%a.height,
                                  rand()%MAX_SPEED, rand()%360));
    }
  }
\end{lstlisting}

scheduler的核心函数是run()，它按照我们最初设计的算法，每次遍历全部人口，执行移动――感染两个步骤，
为了直观，函数还在每次模拟后，显示输出当前时间（单位是分钟），在总人口中有多少人已染病。并在diagram
列表中，记录染病人数随时间变化的曲线。当90\%的人口染病后，程序退出。

\begin{lstlisting}
class scheduler{
  //...

  void run(){
    for(int tm=0; n_infected < people.size()*90/100; tm++){
      a->reset();
      move();
      infect();
      std::cout<<"time "<<tm/60<<":"<<tm%60<<" "
               <<n_infected<<"/"<<people.size()<<" are infected\r";
      diagram.push_back(n_infected);
    }
    write_diagram();
  }
\end{lstlisting}

移动――感染的两个函数分别由move()和infect()实现。移动步骤遍历全部人口，针对每个人，调用move\_insdie()
函数；如果当前个体已被感染，则标记他所在的位置为污染区（设置为1）。然后在感染步骤中，程序再次遍历全部人口，
针对每个健康人，如果他所在的区域已经污染，则将此人标记为患病；并增加染病人口数量。

\begin{lstlisting}
const double dt = 1;       // 1 min
class scheduler{
  //...
private:
  void move(){
    for(Population::iterator it=people.begin(); it!=people.end(); ++it){
      (*it)->move_inside(*a, dt);
      if((*it)->infected())
        *(a->at((*it)->location().x, (*it)->location().y))=1;
    }
  }

  void infect(){
    for(Population::iterator it=people.begin(); it!=people.end(); ++it)
      if(*(a->at((*it)->location().x, (*it)->location().y))){
        n_infected += (*it)->infected()?0:1;
        (*it)->set_infected(true);
      }
  }

  void write_diagram(){
    std::ofstream file("diagram.csv");
    std::copy(diagram.begin(), diagram.end(), 
       std::ostream_iterator<int>(file, "\n"));
  }
};
\end{lstlisting}

我们注意到，这个算法在每一步的运算复杂度为$O(n)$，而非$O(n^2)$。程序最后使用STL的copy算法和insert iterator
将染病人口随时间变化的曲线写入一个csv文件，供我们使用Excel进行后继分析。

程序的主函数main非常简单：
\begin{lstlisting}
int main(int argc, char** argv){
  scheduler::inst().setup(1061, 1061, 1000);
  scheduler::inst().run();
}
\end{lstlisting}

为了接近真实情况，考虑到北京市的人口密度为888人/平方公里\cite{bj-density}，如果样本人群为1000，在1061米长1061米宽的区域内模拟
即可。程序最后输出：

\begin{verbatim}
time 124:34 900/1000 are infected
\end{verbatim}

结果非常惊人！虽然只有一个人染病，但是仅仅过了124小时后，就有9成的人群被感染。如果考虑到人群只在白天活动8小时，则
在不进行任何防护措施的情况下，接触即传染的疾病仅仅需要2周，就可以使城市中的9成人口感染。这就是为什么在古代，瘟疫可以
迅速消灭一个城市。

我们用Excel将染病曲线绘制出来，如下：

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{images/epidemic-free.eps}
        \caption{infected people along time}
       \end{center}
\end{figure}

这是一个标准的指数曲线。也就是说，在无任何防控措施的情况下，传染病会以指数速度进行传播。

% ================================================================
% epidemic with possibility factor
% ================================================================
\section{epidemic with probability factor}
\label{p-factor}

上一模型中存在一些不合理的地方，比如假设健康的个体接触患病者就会被感染。这一假设对于恶性传染病，例如鼠疫等可能
比较适用。但是对于甲型H1N1流感，可能就过于粗放。为此我们可以增加一传染概率来改进模型。所谓传染概率，也就是并非
接触即被传染，而是有一定的概率被传染。影响这一概率的因素很多，例如健康个体的身体状况，是否正面接触等等。

根据这一模型，我们可以修改当前程序如下。

\begin{lstlisting}
  void infect(){
    for(Population::iterator it=people.begin(); it!=people.end(); ++it)
      if(!(*it)->infected() &&
         *(a->at((*it)->location().x, (*it)->location().y))&&
         rand()%100 > INFECT_PROBABILITY){
        n_infected++;
        (*it)->set_infected(true);
      }
  }
\end{lstlisting}

这一改进在infect()函数中。在遍历全部人口中，如果当前的个体是健康个体，他走入了污染区，并且感染概率超过预设的
INFECT\_PROBABILITY，就标记此人被感染，并增加受感染个体数量。当此阈值被设置为50\%时，程序执行结果如下：

\begin{verbatim}
time 272:3 900/1000 are infected
\end{verbatim}

可以发现，加入感染概率模型后，疾病传染速度明显降低。大致需要272小时才能使9成人口感染。我们使用Excel打开CSV
文件，显示曲线如下：

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{images/epidemic-probability.eps}
        \caption{epidemic speed with infect probability}
       \end{center}
\end{figure}

可以看出，虽然速度比第一个模型减慢了。但是曲线形状仍然是指数形状。这个结果告诉我们，即使不是恶性传染病，传染
速度仍然是惊人的。

% ================================================================
%                 hospital model
% ================================================================
\section{Hopspital model} \label{hospital-model}

通过前两节的叙述，已经可以大致认识到传染病在人群中的传播速度是非常快的。对于这次甲型H1N1流感，在有效疫苗尚未
研制出来之前，我们应该足够认识到它的危险性。那么如何在疫苗问世前对抗这种大规模传播呢？我们可以再次通过改进模型
来认识一种有效对抗疾病的方法――主动隔离治疗。

所谓主动隔离治疗，就是当每个病人意识到自己染病后（例如发热），立即前往医院隔离治疗，而不是在城市内自由活动。
在前面的模拟程序的基础上，稍作改动，就可以实现医院的建模。首先考虑到，医院是位于城市中的一个特殊区域，所以它
应该具有同area一样的几何属性，包括长和宽，同时由于医院坐落于城市内部，所以它还应该具有一个位置，我们可以用
x0,y0来代表。另外，医院不需要自己单独的污染网格列表。它可以共用城市的cells网格。最后，由于需要判定某个人
是否在医院内隔离治疗，我们可以判断它的当前位置，是否位于医院范围以内。针对上述分析，我们将area类，改进如下：

\begin{lstlisting}
struct area{
public:
  area(int w, int h):x0(w/2), y0(h/2), width(w), height(h){
    cells=new char[w*h];
    reset();
  }
  area(int x, int y, int w, int h):x0(x), y0(y), 
                width(w), height(h), cells(0){ }

  //dtor, at(), reset() are same as before...

  template<class Loc>
  bool contains(const Loc& l){
    return abs(l.x-x0)<=width/2 && abs(l.y-y0)<=height/2;
  }

  int x0;
  int y0;
  int width;
  int height;
//...
\end{lstlisting}

如果用户仅仅使用长宽来初始化一个区域，我们就假定区域的位置位于矩形的几何中心，并初始化污染网格。否则使用第二个构造函数
设置区域的位置和长宽，而不初始化污染网格。我们增加了一个函数模板来判断一个物理位置是否在矩形区域内部。

每个健康的个体，如果他发现自己染病，就会立即出发去医院进行隔离治疗，为此我们给person类增加一个成员函数move\_to()，它
接受一个区域参数，然后调整自己的运动角度，使之正对区域中心（也就是医院的位置）。函数采用反正切函数来计算角度，并根据90度
和180度的特殊情况做了额外处理：

\begin{lstlisting}
  //inside class person...
  void move_to(area& a){
    if(a.x0 == _loc.x)
      _loc.direction = a.y0 > _loc.y ? 90 : 180;
    else
      _loc.direction = static_cast<int>(
                     atan(static_cast<double>(a.y0-_loc.y)/
                          static_cast<double>(a.x0-_loc.x))/pi*180.0);
  }
\end{lstlisting}

scheduler类增加了一个area*成员hospital来代表医院，并且由set\_hospital()来设置。该指针在scheduler的析构中释放。
在主函数中，设置医院的大小和位置。

\begin{lstlisting}
  //inside class scheduler...
  void set_hospital(int x, int y, int w, int h){
    hospital=new area(x, y, w, h);
  }

  //...

int main(int argc, char** argv){
  scheduler::inst().setup(1061, 1061, 1000);
  scheduler::inst().set_hospital(500, 500, 50, 50);
  scheduler::inst().run();
}
\end{lstlisting}

关键的改动出现在移动――感染两步中的move()内部。当遍历到某一染病个体时，程序先判断该个体是否位于医院内部，如果是，则限制
其只能在医院内自由活动（隔离），否则，立即调整个体的运动方向，使其前往医院（治疗）。对于未感染的个体，则允许其自由运动。

\begin{lstlisting}
  //inside class scheduler...
  void move(){
    for(Population::iterator it=people.begin(); it!=people.end(); ++it){
      if((*it)->infected()){
        if(hospital->contains((*it)->location()))
          (*it)->move_inside(*hospital, dt);
        else
          (*it)->move_to(*hospital);
        *(a->at((*it)->location().x, (*it)->location().y))=1;
      }
      else
        (*it)->move_inside(*a, dt);
    }
  }
\end{lstlisting}

经过上述改进后的模型程序一旦开始运行，即使经过漫长的时间也无法达到9成人口的感染。这说明主动隔离治疗非常有效，作者调整程序退出条件。
只要有2\%的人口染病就退出。程序运行如下：

\begin{verbatim}
time 675:59 20/1000 are infected
\end{verbatim}

大约合28天后，才有2\%的人口染病。考虑人们仅仅在白天活动，实际时间约为84天，也就是3个月。这为研制出疫苗赢得了宝贵的时间。
用Excel描绘主动隔离治疗后的传染速度曲线如下：

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{images/epidemic-hospital.eps}
        \caption{epidemic controlled by hospital}
       \end{center}
\end{figure}

可以看出，传染速度被完全控制了。

% ================================================================
%                 delitescence and summary
% ================================================================
\section{Delitescence and summary}
\label{delitescense}

事实上，即使采取积极主动的隔离治疗，传染病仍然存在巨大威胁。原因在于潜伏期，以甲型H1N1流感为例，潜伏期为7天左右。
在潜伏期内，染病个体仍然可以传染其他个体，而其自己却毫不知情。因此潜伏期内的患者不会主动采取隔离治疗的措施。我们
可以稍加调整现有的模拟程序，了解潜伏期的巨大威胁。

首先给person类增加一个成员变量\_delitescence表示潜伏期，如果是健康个体，它被初始化为0，对于初始患病样本，它被
初始化为3天。也就是说染病后3天开始发病。一旦开始发病，病人就会主动去医院采取隔离治疗措施。这样person类被改进如下：

\begin{lstlisting}
class person{
public:
  person(bool x=false):_infected(x), _delitescence(0){}
  //copy ctor, operator= changes are minor.
  //setter/getter, move, move_to are same as before ...

  bool ill() const { return _delitescence > DELITESCENCE; }
  void inc_delitescence() { ++_delitescence; }

private:
  bool _infected;
  int  _delitescence;
  physics _loc;
};
\end{lstlisting}

然后，需要要改动scheduler的move函数如下：

\begin{lstlisting}
  void move(){
    for(Population::iterator it=people.begin(); it!=people.end(); ++it){
      if((*it)->ill()){
        if(hospital->contains((*it)->location()))
          (*it)->move_inside(*hospital, dt);
        else
          (*it)->move_to(*hospital);
      }
      else
        (*it)->move_inside(*a, dt);
      if((*it)->infected()){
        *(a->at((*it)->location().x, (*it)->location().y))=1;
        (*it)->inc_delitescence();
      }
    }
  }
\end{lstlisting}

也就是说，如果一个感染者没有发病，他仍然可以自由活动，但是程序开始记录他的潜伏期，当潜伏期到达，
患者开始发病。他就立即采取隔离治疗措施。经过这一改进后，模拟程序给出了一个仍然很惊人的结果：

\begin{verbatim}
time 263:51 900/1000 are infected
\end{verbatim}

大约32天后，仍然有90\%的人口被感染！而这时的潜伏期只有短短的3天。此时的传染速度曲线如下：

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{images/epidemic-deli.eps}
        \caption{epidemic with delitescence}
       \end{center}
\end{figure}

可以看出，仍然是以指数速度传播的。通过以上逐步精细地改进模型，可以认识到哪些因素会影响疾病在人群
中的传播速度。甲型H1N1流感是威胁人类的疾病，我们要正确认识它。了解到只有主动隔离治疗才能为研制
疫苗、征服疾病赢得宝贵的时间。这也是为什么我们政府全力监控、采取措施的原因。希望通过本文，能给
广大读者以一个粗浅的感性认识。让我们团结起来，对抗甲型H1N1流感！

由于作者水平有限，文中错误想必不少，还望读者批评指正。

\section{Appendix}

本文使用的全部源代码可以从这里下载：http://liuxinyu95.googlepages.com/particlesys.cpp

\begin{thebibliography}{99}

\bibitem{kedama}
Oshima Yoshiki. Kedama: A massively-parallel tile-scriptable particle system. http://www.is.titech.ac.jp/~ohshima/squeak/kedama/

\bibitem{ao}
Liu Xinyu. 《刀耕火种的繁荣时代》，http://liuxinyu95.googlepages.com/ softdev.books.book1.essay4.chn

\bibitem{kedama_cn}
西邮Linux小组，《怎么做一个流行的模拟》，http://code.google.com/p/chinesesqueak/wiki/KedamaEpidemic

\bibitem{bj-density}
新华网. 《北京每平方公里人口密度888人 城区是远郊63倍》，http://news.xinhuanet.com/newscenter/2005-06/01/content\_3030636.htm

\end{thebibliography}

\ifx\wholebook\relax\else
\end{document}
\fi
