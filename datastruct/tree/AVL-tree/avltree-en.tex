\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
%\input{../../../common.tex}
\input{../../../common-en.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{AVL tree}

\author{Liu~Xinyu
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
  }

\markboth{AVL tree}{AlgoXY}

\maketitle

\ifx\wholebook\relax
\chapter{AVL tree}
\fi

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction} \index{AVL tree}

\subsection{How to measure the balance of a tree?}
Besides red-black tree, are there any other intuitive solutions of self-balancing
binary search tree? In order to measure how balancing a binary search tree,
one idea is to compare the height of the left sub-tree and right sub-tree.
If they differs a lot, the tree isn't well balanced. Let's denote the 
difference height between two children as below

\be
  \delta(T) = |L| - |R|
\ee

Where $|T|$ means the height of tree $T$, and $L$, $R$ denotes the left
sub-tree and right sub-tree.

If $\delta(T) = 0$, The tree is defnitely balanced. For example, a 
complete binary tree has $N=2^h-1$ nodes for height $h$. There is
no empty branches unless the leafs. Another trivial case is empty 
tree. $\delta(\phi) = 0$. The less absolute value of $\delta(T)$
the more balancing the tree is. 

We define $\delta(T)$ as the {\em balance factor} of a binary search
tree.

% ================================================================
% Definition
% ================================================================
\section{Definition of AVL tree}
\index{AVL tree!definition}

An AVL tree is a special binary search tree, that all sub-trees 
satisfying the following criteria.

\be
  |\delta(T)| \leq 1
\ee

The absolute value of balance factor is less than or equal to 1, which
means there are only three valid values, -1, 0 and 1.

During the basic mutable tree operations such as insertion and deletion,
if the balance factor changes to any invalide value, some fixing has
to be performed to resume $|\delta|$ within 1. Most implementations utilize
tree rotations. In this chapter, we'll show the pattern matching solution
which is inspired by Okasaki's red-black tree solution\cite{okasaki}.
Because of this modify-fixing approach, AVL tree is also a kind of 
self-balancing binary search tree.

Of course we can compute the $\delta$ value recursively, another option
is to store the balance factor inside each nodes, and update them
when we modify the tree. The latter one avoid computing the same value
every time.

Based on this idea, we can add one data field $\delta$ to the original
binary search tree as the following C++ code exmample.

\lstset{language=C++}
\begin{lstlisting}
template <class T>
struct node{
  int delta;
  T key;
  node* left;
  node* right;
  node* parent;
};
\end{lstlisting}

In purely functional setting, some implementation use different 
constructor to store the $\delta$ information. for example in 
\cite{hackage}, there are 4 constructors, E, N, P, Z defined.
E for empty tree, N for tree with negative 1 balance factor,
P for tree with positive 1 balance factor and Z for zero case.

In this chapter, we'll explicitly store the balance factor inside
the node.

\lstset{language=Haskell}
\begin{lstlisting}
data AVLTree a = Empty
               | Br (AVLTree a) a (AVLTree a) Int 
\end{lstlisting}

The immutable operations, including looking up, finding the maximum
and minimum elements are all same as the binary search tree. We'll
skip them and focus on the mutable operations.

% ================================================================
%                 Insertion
% ================================================================
\section{Insertion}
\index{AVL tree!insertion}

TODO:
  Pattern matching insertion
  Traditional insertion
 
% ================================================================
%                 Deletion
% ================================================================

\section{Deletion}
\index{AVL tree!deletion}

  TODO: for functional setting, no need??? only imperative one.


\section{Chapter note}
AVL tree was invented in 1962 by Adelson-Velskii and Landis\cite{wiki}, 
\cite{TFATP}. The name AVL tree comes from the two inventors's name.

TODO: compare with Red-black tree.

  TODO: short summary and introduction to the following chatpers.

\begin{thebibliography}{99}

\bibitem{hackage}
Data.Tree.AVL http://hackage.haskell.org/packages/archive/AvlTree/4.2/doc/html/Data-Tree-AVL.html

\bibitem{okasaki}
Chris Okasaki. ``FUNCTIONAL PEARLS Red-Black Trees in a Functional Setting''. J. Functional Programming. 1998

\bibitem{wiki}
Wikipedia. ``AVL tree''. http://en.wikipedia.org/wiki/AVL\_tree

\bibitem{TFATP}
Guy Cousinear, Michel Mauny. ``The Functional Approach to Programming''. Cambridge University Press; English Ed edition (October 29, 1998). ISBN-13: 978-0521576819

\end{thebibliography}

\ifx\wholebook\relax\else
\end{document}
\fi
