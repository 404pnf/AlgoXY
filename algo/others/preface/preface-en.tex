\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}

%\input{../../../common.tex}
\input{../../common-en.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Preface}

\author{Liu~Xinyu
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
  }

\markboth{Preface}{AlgoXY}

\maketitle

% ================================================================
%                 Why
% ================================================================
\section{Why?}
\label{why}

It's quite often to be asked `Is algorithm useful?'. Some programmers
said that they seldom used any serious data structures or algorithms
in real work such as comerial application developing. Even when they need
some of them, there have already been provided in libraries. For example,
the C++ standard template library (STL) provides sort and selection
algorithms as well as the vector, queue, and set data structures.
It seems that knowing about how to use the library as a tool is quite 
enough.

Instead of answering this question directly, I would like to
say algorithms and data structures are critical in solving `interesting
problems', while if the problem is useful is another thing.

Let's start with two problems. It looks like both of them can be 
solved in brute-force way even by a fresh programmer.

% ================================================================
%      Mininum free ID problem. The power of algorithm
% ================================================================
\section{The smallest free ID problem, the power of algorithm}
\label{min-free}

This problem is discussed in Chapter 1 of Richard Bird's book \cite{Bird-book}. It's common that many applications and systems use ID (identifier)
to manage the objects and entities. At any time, some IDs are used, and
some of them are available for using. When some client tries to aquire
a new ID, we want to always allocate it the smallest available one.
Suppose ID is no-negative integers and all IDs in using are maintained 
in a list (or an array) which is not ordered. For example:

\begin{verbatim}
[18, 4, 8, 9, 16, 1, 14, 7, 19, 3, 0, 5, 2, 11, 6]
\end{verbatim}

How can you find the smallest free ID, which is 10, from the list?

It seems the solution is quite easy without need any serious algorithms.

\begin{algorithmic}[1]
\Function{Min-Free}{$A$}
  \State $x \gets 0$
  \Loop
    \If{$x \notin A$}
      \State \Return $x$
    \Else
      \State $x \gets x + 1$
    \EndIf
  \EndLoop
\EndFunction
\end{algorithmic}

Where the $\notin$ is realized like below. Here we use notation $[a, b)$
in Math to define a range from $a$ to $b$ with $b$ excluded.

\begin{algorithmic}[1]
\Function{`$\notin$'}{$x, X$}
  \For{$i \gets [1, LENGTH(X))$}
    \If{$x = X[i]$}
      \State \Return $False$
    \EndIf
  \EndFor
  \State \Return $True$
\EndFunction
\end{algorithmic}

Some languages do provide handy tool which wrap this linear time
process. For example in Python, this algorithm can be directly translate
as the following.

\lstset{language=Python}
\begin{lstlisting}
def brute_force(lst):
    i = 0
    while True:
        if i not in lst:
            return i
        i = i + 1
\end{lstlisting}

It seems this problem is trivial, However, There will be tons of millions of
IDs in a large system. The speed of this solution is poor in such case.
It takes $O(N^2)$ time, where $N$ is the length of the ID list.
In my computer (2 Cores 2.10 GHz, with 2G RAM), a C program with this 
solution takes average 5.4 seconds to search a minimum free number 
among 100,000 IDs\footnote{All programs can be downloaded along
with this series posts.}. And it takes more than 8 minutes to handle
a million of numbers.

\subsection{Improvement 1}
The key idea to improve the solution is based on a fact that for a
series of $N$ numbers $x_1, x_2, ..., x_N$, if there are free numbers,
not all of the $x_i$ are in range $[0, N)$, which means that 
$max(x_i) \geq N-1$. And we have the following fact.

\be
minfree(x_1, x_2, ..., x_N) \leq N
\ee

One solution is to use an array of $N+1$ flags to mark either a number
in range $[0, N]$ is free. 

\begin{algorithmic}[1]
\Function{Min-Free}{$A$}
  \State $F \gets [False, False, ..., False]$ where $LENGTH(F) = N+1$
  \For{$\forall x \in A$}
    \If{$x < N$}
      \State $F[x] \gets True$
    \EndIf
  \EndFor
  \For{$i \gets [0, N]$}
    \If{$F[i] = False$}
      \State \Return $i$
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}

Line 2 initializes a flag array all of $False$ values. This takes
$O(N)$ time. Then the algorithm scans all numbers in $A$ and mark
the relative flag to $True$ if the value is less than $N$, This 
step also takes $O(N)$ time. Finally, the algorithm performs a
linear time search to find the first flag with $False$ value.
So the total performance of this algorithm is $O(N)$. Note that
we use a $N+1$ flags instead of $N$ flags to cover the special case
that $sorted(A) = [0, 1, 2, ..., N-1]$.

Although the algorithm only takes $O(N)$ time, it needs extra
$O(N)$ spaces to store the flags.

This solution is much faster than the brute force one. In my 
computer, the relavant Python program takes 
average 0.02 second when deal with 100,000 numbers.

We haven't fine tune this algorithm yet. Observe that each time 
we have to allocate memory to create a $N-$element array of 
flags, and release the memory when finish. 
The memory allocation and release is very
expensive that they cost a lot of processing time. 

There are two ways which can provide minor improvement to 
this solution. One is to allocate the flags array in advance
and reuse it for all left calls of finding the smallest free
number. The other is to use bit-wise flags instead of a flag 
array.

% ================================================================
%                 Short summary
% ================================================================
\section{Notes and short summary}

% ================================================================
%                 Appendix
% ================================================================
\section{Appendix} \label{appendix}
%\appendix
All programs provided along with this article are free for
downloading.

\subsection{Prerequisite software}
GNU Make is used for easy build some of the program. For C++ and ANSI C programs,
GNU GCC and G++ 3.4.4 are used. 
For Haskell programs GHC 6.10.4 is used
for building. For Python programs, Python 2.5 is used for testing, for
Scheme/Lisp program, MIT Scheme 14.9 is used.

all source files are put in one folder. Invoke 'make' or 'make all'
will build C++ Program. 

There is no separate Haskell main program module, however, it is possible to run the program in GHCi.

\begin{itemize}
\item files

\end{itemize}

download position: http://sites.google.com/site/algoxy/otherheaps/otherheaps.zip

\begin{thebibliography}{99}

\bibitem{Bird-book}
Richard Bird. ``Pearls of functional algorithm design''. Cambridge University Press; 1 edition (November 1, 2010). ISBN-10: 0521513383

\bibitem{okasaki-book}
Chris Okasaki. ``Purely Functional Data Structures''. Cambridge university press, (July 1, 1999), ISBN-13: 978-0521663502

\bibitem{wiki-pascal-triangle}
Wikipedia, ``Pascal's triangle''. http://en.wikipedia.org/wiki/Pascal's\_triangle

\bibitem{lxy-bheap}
Liu Xinyu. ``Binary heaps with functional and imperative implementation'', https://sites.google.com/site/algoxy/bheap

\end{thebibliography}

\ifx\wholebook\relax \else
\end{document}
\fi
