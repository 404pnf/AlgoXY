\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}

%\input{../../../common.tex}
\input{../../common-en.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Preface}

\author{Liu~Xinyu
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
  }

\markboth{Preface}{AlgoXY}

\maketitle

% ================================================================
%                 Why
% ================================================================
\section{Why?}
\label{why}

It's quite often to be asked `Is algorithm useful?'. Some programmers
said that they seldom used any serious data structures or algorithms
in real work such as comerial application developing. Even when they need
some of them, there have already been provided in libraries. For example,
the C++ standard template library (STL) provides sort and selection
algorithms as well as the vector, queue, and set data structures.
It seems that knowing about how to use the library as a tool is quite 
enough.

Instead of answering this question directly, I would like to
say algorithms and data structures are critical in solving `interesting
problems', while if the problem is useful is another thing.

Let's start with two problems. It looks like both of them can be 
solved in brute-force way even by a fresh programmer. But...

% ================================================================
%      Mininum free ID problem. The power of algorithm
% ================================================================
\section{The smallest free ID problem, the power of algorithm}
\label{min-free}

This problem is discussed in Chapter 1 of Richard Bird's book \cite{Bird-book}. It's common that many applications and systems use ID (identifier)
to manage the objects and entities. At any time, some IDs are used, and
some of them are available for using. When some client tries to aquire
a new ID, we want to always allocate it the smallest available one.
Suppose ID is no-negative integers and all IDs in using are maintained 
in a list (or an array) which is not ordered. For example:

\begin{verbatim}
[18, 4, 8, 9, 16, 1, 14, 7, 19, 3, 0, 5, 2, 11, 6]
\end{verbatim}

How can you find the smallest free ID, which is 10, from the list?

It seems the solution is quite easy without need any serious algorithms.

\begin{algorithmic}[1]
\Function{Min-Free}{$A$}
  \State $x \gets 0$
  \Loop
    \If{$x \notin A$}
      \State \Return $x$
    \Else
      \State $x \gets x + 1$
    \EndIf
  \EndLoop
\EndFunction
\end{algorithmic}

Where the $\notin$ is realized like below. Here we use notation $[a, b)$
in Math to define a range from $a$ to $b$ with $b$ excluded.

\begin{algorithmic}[1]
\Function{`$\notin$'}{$x, X$}
  \For{$i \gets [1, LENGTH(X))$}
    \If{$x = X[i]$}
      \State \Return $False$
    \EndIf
  \EndFor
  \State \Return $True$
\EndFunction
\end{algorithmic}

Some languages do provide handy tool which wrap this linear time
process. For example in Python, this algorithm can be directly translate
as the following.

\lstset{language=Python}
\begin{lstlisting}
def brute_force(lst):
    i = 0
    while True:
        if i not in lst:
            return i
        i = i + 1
\end{lstlisting}

It seems this problem is trivial, However, There will be millions of
IDs in a large system. The speed of this solution is poor in such case.
It takes $O(N^2)$ time, where $N$ is the length of the ID list.
In my computer, a C program with this solution takes xxx time for 1 millions
of IDs.

% ================================================================
%                 Short summary
% ================================================================
\section{Notes and short summary}

% ================================================================
%                 Appendix
% ================================================================
\section{Appendix} \label{appendix}
%\appendix
All programs provided along with this article are free for
downloading.

\subsection{Prerequisite software}
GNU Make is used for easy build some of the program. For C++ and ANSI C programs,
GNU GCC and G++ 3.4.4 are used. 
For Haskell programs GHC 6.10.4 is used
for building. For Python programs, Python 2.5 is used for testing, for
Scheme/Lisp program, MIT Scheme 14.9 is used.

all source files are put in one folder. Invoke 'make' or 'make all'
will build C++ Program. 

There is no separate Haskell main program module, however, it is possible to run the program in GHCi.

\begin{itemize}
\item files

\end{itemize}

download position: http://sites.google.com/site/algoxy/otherheaps/otherheaps.zip

\begin{thebibliography}{99}

\bibitem{Bird-book}
Richard Bird. ``Pearls of functional algorithm design''. Cambridge University Press; 1 edition (November 1, 2010). ISBN-10: 0521513383

\bibitem{okasaki-book}
Chris Okasaki. ``Purely Functional Data Structures''. Cambridge university press, (July 1, 1999), ISBN-13: 978-0521663502

\bibitem{wiki-pascal-triangle}
Wikipedia, ``Pascal's triangle''. http://en.wikipedia.org/wiki/Pascal's\_triangle

\bibitem{lxy-bheap}
Liu Xinyu. ``Binary heaps with functional and imperative implementation'', https://sites.google.com/site/algoxy/bheap

\end{thebibliography}

\ifx\wholebook\relax \else
\end{document}
\fi
