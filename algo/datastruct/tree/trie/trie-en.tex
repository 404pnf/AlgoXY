\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
%\input{../../../common.tex}
\input{../../../common-en.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Trie, Patricia, and Suffix tree, with Functional and imperative implementation}

\author{Liu~Xinyu
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
%  Tel:   +86-1305-196-8666 \newline}
  }

\markboth{Trie, Patricia, and Suffix tree}
{imperative and functional implementation}

\maketitle

\ifx\wholebook\relax
\chapter{Trie, Patricia, and Suffix tree, with Functional and imperative implementation}

\section{abstract}
\else
\begin{abstract}
\fi
Trie, Patricia, and Suffix tree are important data structures in
information retreiving and manipulating. None of these data structures
are new. They were invented in 1960s. This post collects some
existing knowledge about them. Some functional and imperative
implementation are given in order to show the basic idea of these data structures.
There are multiple programming languages used, including, C++, Haskell, python and scheme/lisp.
C++ and python are mostly used to show the imperative implementation, while Haskell and Scheme are
used for functional purpose.

There may be mistakes in the post, please feel free to point out.

This post is generated by \LaTeXe, and provided with GNU FDL(GNU Free Documentation License).
Please refer to http://www.gnu.org/copyleft/fdl.html for detail.

\ifx\wholebook\relax\else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} Trie, Patricia, Radix tree, Suffix tree

%{\bfseries Corresponding Author:} Liu Xinyu

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

There isn't a seperate chapter about Trie, Patricia, ans Suffix tree
in CLRS book. While these data structure are very basic, especially in
information retrieving. Some of them are also widely used in
compiler design\cite{okasaki-int-map}, and bio-information area, such as
NDA pattern matching \cite{wiki-suffix-tree}.

In CLRS book index, Trie is redirected to Radix tree, while Radix tree
is described in Problem 12-1 \cite{CLRS}.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/radix-tree.eps}
        \caption{an Radix tree example in CLRS} \label{fig:radix-tree}
       \end{center}
\end{figure}

Figure \ref{fig:radix-tree} shows a radix tree contains the bit
strings 1011, 10, 011, 100 and 0. When searching for a key $k=b_0b_1...b_n$, we
take the first bit $b_0$ (MSB from left), check if it is 0 or 1, if it
is 0, we turn left, and turn right for 1. Then we take the 2nd bit and
repeat this search until we either meet a leaf or finish all n bits.

Note that radix tree needn't store any key in node at all. The
infomation are represented by edges in fact. The node with key string
in the above figure are only for illustration.

It is very natural to come to the idea `is it possible to represent
keys in integers instead of string, because integer can be denoted in
binary format?'. Such approach can save spaces and it is fast if we
can use bitwise manipulation.

I'll first show the integer Trie data structure and implementation in
section \ref{int-trie}. Then we can point out the drawbacks and go to
the improved data structure of integer Patricia in
section \ref{int-patricia}.
After that, I'll show alphabetic Trie and Patricia and list some
typicall use of them in textual manipulation engineering problems.
I'll show Suffix tree data structure and linear time contruction
algorithm in section \ref{suffix-tree}.

This article provides example implementation of Trie, Patricia and Suffix tree
in C, C++, Haskell, Python, and Scheme/Lisp languages. Some functional
implementation can be referenced from current Haskell packages \ref{hackage-int-map} 
\ref{hackage-bytestring-map}.

All source code can be downloaded in appendix \ref{appendix}, please 
refer to appendix for detailed information about build and run.

% ================================================================
%                 Int Trie
% ================================================================
\section{Integer Trie}
\label{int-trie}

Let's give a definition of the data structure in figure \ref{radix-trie}.
To be more accurate, it should be called as \emph{binary trie}. a binary
trie is a binary tree in which the placement of each key is controlled by
its bits, each 0 means ``go left at the next node'' and each 1 means ``go
right at the next node''\ref{okasaki-int-map}.

Because integers can be represented in binary format in computer, it is 
possible to store integer keys rather than 0,1 strings. When we insert an
integer as a new key to the trie, we take first bit, if it is 0, we recursively
insert the other bits to the left sub tree; if it is 1, we insert into right
sub tree.

However, there is a big problem if we treat the key as integer. Consider a binary
trie shows in figure \ref{fig:little-endian-trie}. If the keys are represented in 
string based on '0' and '1', all the three keys are different. While if they are
turned into integers, they are identical. So if we want to insert a data with integer
key 3, where should we put it into the trie?

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/little-endian-trie.ps}
        \caption{a little-endian trie} \label{fig:little-endian-trie}
       \end{center}
\end{figure}

If an integer is represented in 32-bits, and want to insert key 1 to a trie, it will end
up with a 32 level tree. There are 31 node has only 1 left sub tree and the last node has
a right sub tree. It is very inefficent in terms of space.

Chris Okasaki shows a method to solve this problem in \cite{okasaki-int-map}. Instead of 
normal big-endian integer, we can use little-endian integer as key. By using little-endian,
decimal integer 1 is represent as binary 1, if we insert it to an empty binary trie, we
get a trie with a root and a right leaf. It is only 1 level. For integer 3, it is 11 in 
birnary, we needn't add any prefix 0, the position in the trie is unique.

%=========================================================================
%       Definition of integer trie
%=========================================================================
\subsection{Definition of Integer Trie}
Trie is invented by Edward Fredkin. It comes from ``retrieval'', pronouces 
as /'tri:/ by the inventor, while it is pronouced /'trai/ ``try'' 
by other authors \cite{wiki-trie}.
The definition of little-endian binary trie is simple, we can reuse the structure
of binary tree, with its left sub tree to store 0 part and right tree to store 1 part.
The augment data can be stored as value.

\subsubsection*{Definition of little-edian interger trie in Haskell}
In trie, since a node may not contains value, so we use Haskell Maybe data to represent
this situation. A IntTrie node is either an empty node, or a branch node. The branch
node contains a left child a `Maybe' value and a right child. 

\lstset{language=Haskell}
\begin{lstlisting}
data IntTrie a = Empty 
               | Branch (IntTrie a) (Maybe a) (IntTrie a) -- left, value, right

type Key = Int

-- helpers
left :: IntTrie a -> IntTrie a
left (Branch l _ _) = l
left Empty = Empty

right :: IntTrie a -> IntTrie a
right (Branch _ _ r) = r
right Empty = Empty

value :: IntTrie a -> Maybe a
value (Branch _ v _) = v
value Empty = Nothing
\end{lstlisting}

In order to access the children and value some helper functions are given.

\subsubsection*{Definition of little-edian interger trie in Python}
The definition of integer trie in Python is shown as below

\lstset{language=Python}
\begin{lstlisting}
class IntTrie:
    def __init__(self):
        self.value = None
        self.left = self.right = None
\end{lstlisting}

left child and right child represent sub trie, and value is used to 
store actual data.

% ================================================================
%               Insertion of integer trie
% ================================================================
\subsection{Insertion of integer trie}
Since the key is little-endian, when we insert a key into trie, we take the
bit from right most (LSB). If it is 0, we go to the left child, and go to right
for 1. if the child is empty, we need create new node, and repeat this until
met the last bit (MSB) of the integer.

%\begin{algorithm}
\begin{algorithmic}
\STATE $INT-TRIE-INSERT(T, x, data)$
\IF{$T = NIL$}
   \STATE $T \leftarrow EmptyNode$ \ENDIF

  \STATE $p=T$
  \WHILE{$x \neq 0$}
    \IF{$EVEN(x) = TRUE$}
      \STATE $p \leftarrow LEFT(p)$
    \ELSE
      \STATE $p \leftarrow RIGHT(p)$
    \ENDIF
    \IF{$p = NIL$}
      \STATE $p \leftarrow EmptyNode$ \ENDIF
    \STATE $x \leftarrow x/2$
  \ENDWHILE
  \STATE $DATA(p) \leftarrow data$
\end{algorithmic}
%\end{algorithm}

\subsubsection*{Insertion of integer trie in Haskell}
To simply the problem, If user insert a data with key already exists, we simply
overwrite the previous stored data. This approach can be easily replaced with 
other methods, such as storing data as a linked list etc.

Insertion integer key into a trie can be implementated with Haskell as below.

\lstset{language=Haskell}
\begin{lstlisting}
insert :: IntTrie a -> Key -> a -> IntTrie a
insert t 0 x = Branch (left t) (Just x) (right t)
insert t k x = 
  if even k
       then Branch (insert (left t) (k `div` 2) x) (value t) (right t)
       else Branch (left t) (value t) (insert (right t) (k `div` 2) x)
\end{lstlisting}

If the key is zero, we just insert the data to current node, in other
cases, the program go down along the trie according to the last bit
of the key.

To test if this program, some test helper functions are provided.

\begin{lstlisting}
fromList :: [(Key, a)] -> IntTrie a
fromList xs = foldl ins Empty xs where
    ins t (k, v) = insert t k v

-- k = ... a2, a1, a0 ==> k' = ai * m + k, where m=2^i
toString :: (Show a)=>IntTrie a -> String
toString t = toStr t 0 1 where
    toStr Empty k m = "."
    toStr tr k m = "(" ++ (toStr (left tr) k (2*m)) ++
                      " " ++ (show k) ++ (valueStr (value tr)) ++
                      " " ++ (toStr (right tr) (m+k) (2*m)) ++ ")"
    valueStr (Just x) = ":" ++ (show x)
    valueStr _ = ""
\end{lstlisting}

fromList function can create a trie from a list of integer-data pairs.
toString function can turn a trie data structure to readable string
for printing. The following code shows a test.

\begin{lstlisting}
main = do
  putStrLn (toString (fromList [(1, 'x'), (4, 'y'), (5, 'z')]))
\end{lstlisting}

This will output:
\begin{verbatim}
(((. 0 (. 4:'y' .)) 0 .) 0 ((. 1 (. 5:'z' .)) 1:'x' .))
\end{verbatim}

Figure \ref{int-trie} shows this result. 
\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/int-trie.ps}
        \caption{An little-endian integer binary tree for the map \{$ 1 \rightarrow x, 4 \rightarrow y, 5 \rightarrow z$\}.} \label{fig:int-trie}
       \end{center}
\end{figure}

\subsubsection*{Insertion of integer trie in Python}
Imperative implementation of insertion in Python can be easily given by translating
the pseudocode of the algorithm.

\lstset{language=Python}
\begin{lstlisting}
def trie_insert(t, key, value = None):
    if t is None:
        t = IntTrie()

    p = t
    while key != 0:
        if key & 1 == 0:
            if p.left is None:
                p.left = IntTrie()
            p = p.left
        else:
            if p.right is None:
                p.right = IntTrie()
            p = p.right
        key = key>>1
    p.value = value
    return t
\end{lstlisting}

In order to test this insertion program, some test helpers are provided:

\begin{lstlisting}
def trie_to_str(t, prefix=0):
    to_str = lambda x: "%s" %x
    str="("+to_str(prefix)
    if not t.value is None:
        str += ":"+t.value
    if not t.left is None:
        str += ", "+trie_to_str(t.left, (prefix<<1))
    if not t.right is None:
        str += ", "+trie_to_str(t.right, (prefix<<1)+1)
    str+=")"
    return str

def list_to_trie(l):
    t = None
    for x in l:
        t = trie_insert(t, x)
    return t

def map_to_trie(m):
    t = None
    for k, v in m.items():
        t = trie_insert(t, k, v)
    return t
\end{lstlisting}

Function trie\_to\_str can print the contents of trie in pre-order,
It doesn't only print the value of the ndoe, but also print the edge information.

Function list\_to\_trie can repeatly insert a list of keys into a trie, since the
default argument of value is None, so all data relative to keys are empty. If the
data isn't empty, function map\_to\_trie can insert a list of key-value pairs into 
the trie.

Then a test classe is given to encapasulate test cases:

\begin{lstlisting}
class IntTrieTest:
    def run(self):
        self.test_insert()

    def test_insert(self):
        t = None
        t = trie_insert(t, 0);
        t = trie_insert(t, 1);
        t = trie_insert(t, 4);
        t = trie_insert(t, 5);
        print trie_to_str(t)
        t1 = list_to_trie([1, 4, 5])
        print trie_to_str(t1)
        t2 = map_to_trie({4:'y', 1:'x', 5:'z'})
        print trie_to_str(t2)

if __name__ == "__main__":
    IntTrieTest().run()
\end{lstlisting}

Running this program will print the following result.

\begin{verbatim}
(0, (0, (0, (1))), (1, (2, (5))))
(0, (0, (0, (1))), (1, (2, (5))))
(0, (0, (0, (1:y))), (1:x, (2, (5:z))))
\end{verbatim}

Please note that by printing 

% ================================================================
%               Look up in integer binary trie
% ================================================================
\subsection{Look up in integer binary trie} 

To look up a key in a little-endian integer binary trie. We take each
bit of the key from left (LSB), and go left or right according to if
the bit is 0, untill we consumes all bits. this algorithm can be described
as below pseudocode.

\begin{algorithmic}
\STATE $INT-TRIE-LOOKUP(T, x)$
  \WHILE{$x \neq 0$ and $T \neq NIL$}
    \IF{$EVEN(x) = TRUE$}
      \STATE $T \leftarrow LEFT(T)$
    \ELSE
      \STATE $T \leftarrow RIGHT(T)$
    \ENDIF
    \STATE $x \leftarrow x/2$
  \ENDWHILE
  \IF{$T \neq NIL$} \RETURN $DATA(T)$
  \ELSE \RETURN $NIL$ \ENDIF
\end{algorithmic}

\subsubsection*{Look up implemented in Haskell}
The algorithm in pseudocode is in imperative way, It can also be implemented 
recursivly like below Haskell program

\lstset{language=Haskell}
\begin{lstlisting}
search :: IntTrie a -> Key -> Maybe a
search Empty k = Nothing
search t 0 = value t
search t k = if even k then search (left t) (k `div` 2)
             else search (right t) (k `div` 2)
\end{lstlisting}

If trie is empty, we simply returns nothing; if key is zero we return the 
value of current node; in other case we recursively search either left
child or right child according to the LSB is 0 or not.

To test this program, we can write a smoke test case as following.

\begin{lstlisting}
testIntTrie = "t=" ++ (toString t) ++ 
              "\nsearch t 4: " ++ (show $ search t 4) ++
              "\nsearch t 0: " ++ (show $ search t 0)
    where
      t = fromList [(1, 'x'), (4, 'y'), (5, 'z')]

main = do
  putStrLn testIntTrie
\end{lstlisting}

This program will output these result.

\begin{verbatim}
t=(((. 0 (. 4:'y' .)) 0 .) 0 ((. 1 (. 5:'z' .)) 1:'x' .))
search t 4: Just 'y'
search t 0: Nothing
\end{verbatim}

% ================================================================
%               Int Patricia
% ================================================================
\section{Integer Patricia} 
\label{int-patricia}

It's very easy to find the drawbacks of integer binary trie. Trie wasts a lot of 
spaces. Note in figure \ref{int-trie}, all nodes except leafs store the real data.
Typically, an integer binary trie contains many nodes only have one child.
It is very easy to come to the idea for improvement, to compress the chained nodes
which have only one child. Patricia is such a data structure invented by 
Donald R. Morrison. Patricia means practical algorithm to retrieve information coded
in aphanumeric\cite{patricia-morrison}. Wikipedia redirect Patricia as Radix tree.

Chris Okasaki gave a implementation of Integer Patricia

\subsubsection*{Python helper function}
\lstset{language=Python}
\begin{lstlisting}
def set_color(nodes, colors):
    for (n, c) in zip(nodes, colors):
        n.color = c
\end{lstlisting}

\subsubsection*{Scheme/Lisp helper functions}

In order have a uniformed output like we defined the red black tree as a list of (left key color right).
I defined some helper functions to construct the red black tree and access the element of the tree.

\lstset{language=lisp}
\begin{lstlisting}
(define (make-rbtree c l k r) ;;color, left, key, right
  (list l k c r))

(define (key tree) (cadr tree))
(define (color tree) (caddr tree))
(define (left tree) 
  (if (null? tree) '() (car tree)))
(define (right tree)
  (if (null? tree) '() (cadddr tree)))

;; Test the color
(define (red? t)
  (if (null? t) '() (equal? (color t) "R")))

(define (black? t)
  (if (null? t) '() (equal? (color t) "B")))
\end{lstlisting}

\subsubsection*{C++ helper functions}

Similar to Python like imperative implementation, C++ provides left
and right rotation functions, here is the rotation program in SGI STL.

\lstset{language=c++}
\begin{lstlisting}
inline void 
_Rb_tree_rotate_left(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)
{
  _Rb_tree_node_base* __y = __x->_M_right;
  __x->_M_right = __y->_M_left;
  if (__y->_M_left !=0)
    __y->_M_left->_M_parent = __x;
  __y->_M_parent = __x->_M_parent;

  if (__x == __root)
    __root = __y;
  else if (__x == __x->_M_parent->_M_left)
    __x->_M_parent->_M_left = __y;
  else
    __x->_M_parent->_M_right = __y;
  __y->_M_left = __x;
  __x->_M_parent = __y;
}

inline void 
_Rb_tree_rotate_right(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)
{
  _Rb_tree_node_base* __y = __x->_M_left;
  __x->_M_left = __y->_M_right;
  if (__y->_M_right != 0)
    __y->_M_right->_M_parent = __x;
  __y->_M_parent = __x->_M_parent;

  if (__x == __root)
    __root = __y;
  else if (__x == __x->_M_parent->_M_right)
    __x->_M_parent->_M_right = __y;
  else
    __x->_M_parent->_M_left = __y;
  __y->_M_right = __x;
  __x->_M_parent = __y;
}
\end{lstlisting}

This code is more like the pseudo code presents in CLRS than the
python code, because My python program provides some bi-directional
assignment helper member functions.

% ================================================================
%                 Insertion
% ================================================================
\section{Insertion}

Insertion can violate the red black tree properties, so we need transform
the tree after insertion.

We can use the same insert function as defined in binary search tree, and 
then do some fix the resume the red black properties. One good practice is 
to always insert red node. as far as the new inserted node isn't the root.
We can keep all properties except number 4. It may bring two adjacent red
nodes.

Functional and imperative implementation have different fixing ways. One
is uniformed but has some overhead, the other is a bit complex but has 
higher performance.

\subsubsection*{Haskell red black insertion, functional}
As described by Chris Okasaki, there are total 4 cases which violate property 4.
All of them has 2 adjacent red nodes. However, they have a uniformed form
after fixing\cite{okasaki}. 

%\begin{figure}[htbp]
%       \begin{center}
%	\includegraphics[scale=0.5]{img/insert-fix.eps}
%        \caption{4 cases for balancing a red black tree after insertion} \label{fig:insert-fix}
%       \end{center}
%\end{figure}

Note that this transformation will move the redness one level up. So this is a bottom-up recursive fixing, the last step will make the root node red. According
to property 2, root is always black. So we need final fixing to revert the root
color to black. All these can be implemented as the following Haskell code.

\lstset{language=Haskell}
\begin{lstlisting}
insert::(Ord a)=>RBTree a -> a -> RBTree a
insert t x = makeBlack(ins t x) where  --[1]
    ins Empty x = Node R Empty x Empty --[2]
    ins (Node color l k r) x 
        | x < k     = balance color (ins l x) k r
        | otherwise = balance color l k (ins r x) --[3]
    makeBlack(Node _ l k r) = Node B l k r

balance::Color -> RBTree a -> a -> RBTree a -> RBTree a
balance B (Node R (Node R a x b) y c) z d = 
                Node R (Node B a x b) y (Node B c z d)
balance B (Node R a x (Node R b y c)) z d = 
                Node R (Node B a x b) y (Node B c z d)
balance B a x (Node R b y (Node R c z d)) = 
                Node R (Node B a x b) y (Node B c z d)
balance B a x (Node R (Node R b y c) z d) = 
                Node R (Node B a x b) y (Node B c z d)
balance color l k r = Node color l k r
\end{lstlisting}

Here are some explanation. For [1], the program always set the root
color as black, this is because of property 2; For [2], we always insert
a red leaf to satisfy all properties except number 4; For [3], I assume, 
there shouldn't be different nodes with equal key value. But it is not always
applicable. for example in chapter 14, ``Augmenting Data Structures'' in CLRS\cite{CLRS}, it enables such case. The use of otherwise allows user to do this.

In order to test this program, we can write something like below.

\begin{lstlisting}
-- helper function to build a red black tree from a list

listToRBTree::(Ord a)=>[a] -> RBTree a
listToRBTree lst = foldl insert Empty lst

-- Helper function for pretty printing
instance Show a => Show (RBTree a) where
    show Empty = "."
    show (Node c l k r) = "(" ++ show l ++ " " ++ 
                          show k ++ ":" ++ show c ++ " " ++ 
                          show r ++ ")"

main = do
  putStrLn (show (listToRBTree [11, 2, 14, 1, 7, 15, 5, 8, 4]))
  putStrLn (show (listToRBTree [1, 2, 3, 4, 5, 6, 7, 8]))
\end{lstlisting}

This program will output:
\begin{verbatim}
(((. 1:B .) 2:B ((. 4:R .) 5:B .)) 7:B (((. 8:R .) 11:B .) 14:B (. 15:B .)))
(((. 1:B .) 2:B (. 3:B .)) 4:B ((. 5:B .) 6:B (. 7:B (. 8:R .))))
\end{verbatim}

They are trees as shown below.

%\begin{figure}[htbp]
%       \begin{center}
%	\includegraphics[scale=0.4]{img/insert-haskell.ps}
%        \caption{Haskell insert results} 
%       \end{center}
%\end{figure}

\subsubsection*{Scheme/Lisp red black tree insertion, functional}

Scheme/Lisp version of insert is very similar, since there is no pattern matching
in Scheme, we use normal condition to do the similar things.

\lstset{language=Lisp}
\begin{lstlisting}
(define (rb-insert tree x)
  (define (make-black t)
    (make-rbtree "B" (left t) (key t) (right t)))
  (define (ins t x)
    (cond ((null? t) (make-rbtree "R" '() x '()))
	  ((< x (key t)) (balance (color t) 
                                  (ins (left t) x) (key t) (right t)))
	  (else (balance (color t) (left t) (key t) (ins (right t) x)))))
  (make-black (ins tree x)))
\end{lstlisting}

And the core function balance which can fix the red-red violation is as below.

\begin{lstlisting}
(define (balance c l k r)
  (if (equal? c "B")
      (cond ((and (red? l) (red? (left l)))
	     (make-rbtree "R" 
			  (make-rbtree "B" (left (left l)) 
                                           (key (left l)) 
                                           (right (left l)))
			  (key l)
			  (make-rbtree "B" (right l) k r)))
	    ((and (red? l) (red? (right l)))
	     (make-rbtree "R"
			  (make-rbtree "B" (left l) (key l) (left (right l)))
			  (key (right l))
			  (make-rbtree "B" (right (right l)) k r)))
	    ((and (red? r) (red? (right r)))
	     (make-rbtree "R" 
			  (make-rbtree "B" l k (left r))
			  (key r)
			  (make-rbtree "B" (left (right r)) 
                                           (key (right r)) 
                                           (right (right r)))))
	    ((and (red? r) (red? (left r)))
	     (make-rbtree "R"
			  (make-rbtree "B" l k (left (left r)))
			  (key (left r))
			  (make-rbtree "B" (right (left r)) 
                                           (key r) 
                                           (right r))))
	    (else (make-rbtree c l k r)))
      (make-rbtree c l k r)))
\end{lstlisting}

This program can be test with a similar test cases as below:

\begin{lstlisting}
(define (list->rbtree lst)
  (fold-left rb-insert '() lst))

(define t1 (list->rbtree '(11 2 14 1 7 15 5 8 4)))
(define t2 (list->rbtree '(1 2 3 4 5 6 7 8)))
\end{lstlisting}

If we evaluate t1 and t2, it will output the results like this.

\begin{verbatim}
t1
;Value 11: (((() 1 "B" ()) 2 "B" ((() 4 "R" ()) 5 "B" ())) 7 "B" (((() 8 "R" ()) 
11 "B" ()) 14 "B" (() 15 "B" ())))

t2
;Value 12: (((() 1 "B" ()) 2 "B" (() 3 "B" ())) 4 "B" ((() 5 "B" ()) 6 "B" (() 
7 "B" (() 8 "R" ()))))
\end{verbatim}


\subsubsection*{Python red black tree insertion, imperative}

The python version imperative implementation uses the method described in CLRS.

\lstset{language=Python}
\begin{lstlisting}
def rb_insert(t, key): #returns the new root
    root = t
    x = Node(key)
    parent = None
    while(t):
        parent = t
        if(key < t.key):
            t = t.left
        else:
            t = t.right
    if parent is None: #tree is empty
        root = x
    elif key < parent.key:
        parent.set_left(x)
    else:
        parent.set_right(x)
    return rb_insert_fix(root, x)
\end{lstlisting}

Compare the above source code and the one in binary search tree\cite{bst-lxy}. The only difference are we simplified the program by using set\_left()/set\_right() member functions, and there is a rb\_insert\_fix() function call to fix the red node violation.

There are 3 cases described in CLRS, and if we take the left-right symmetric into consideration. there are total 6 cases. Among them two cases can be merged together, because they are all have uncle node in red color, we can toggle the parent color and uncle color to black and set grand parent color to red. After this merge the 5 cases fixing version can be implemented as the following.

\begin{lstlisting}
# Fix the red->red violation
def rb_insert_fix(t, x):
    while(x.parent and x.parent.color==RED):
        if x.uncle().color == RED:
            #case 1: ((a:R x:R b) y:B c:R) ==> ((a:R x:B b) y:R c:B)
            set_color([x.parent, x.grandparent(), x.uncle()],
                      [BLACK, RED, BLACK])
            x = x.grandparent()
        else:
            if x.parent == x.grandparent().left:
                if x == x.parent.right:
                    #case 2: ((a x:R b:R) y:B c) ==> case 3
                    x = x.parent
                    t=left_rotate(t, x)
                # case 3: ((a:R x:R b) y:B c) ==> (a:R x:B (b y:R c))
                set_color([x.parent, x.grandparent()], [BLACK, RED])
                t=right_rotate(t, x.grandparent())
            else:
                if x == x.parent.left:
                    #case 2': (a x:B (b:R y:R c)) ==> case 3'
                    x = x.parent
                    t = right_rotate(t, x)
                # case 3': (a x:B (b y:R c:R)) ==> ((a x:R b) y:B c:R)
                set_color([x.parent, x.grandparent()], [BLACK, RED])
                t=left_rotate(t, x.grandparent())
    t.color = BLACK
    return t
\end{lstlisting}

To test the insertion function. We use some similar helper functions and test functions defined in binary search tree\cite{bst-lxy}.

\begin{lstlisting}
def rbtree_clone(t):
    n = None
    if t != None:
        n = Node(t.key, t.color)
        n.set_children(rbtree_clone(t.left), rbtree_clone(t.right))
    return n

def rbtree_to_str(t):
    if t is None:
        return "."
    else:
        color = {RED:"R", BLACK:"B"}
        return "("+rbtree_to_str(t.left)+ " " + str(t.key) +":"+
               color[t.color]+" " + rbtree_to_str(t.right)+")"

def list_to_tree(l):
    tree = None
    for x in l:
        tree = rb_insert(tree, x)
    return tree

class Test:
    def __init__(self):
        self.t2=Node(11, BLACK) # as figure 13.4 in CLRS
        self.t2.set_children(Node(2), Node(14, BLACK))
        self.t2.left.set_children(Node(1, BLACK), Node(7, BLACK))
        self.t2.right.set_right(Node(15))
        self.t2.left.right.set_children(Node(5), Node(8))
        print "t2, CLRS fig 13.4:\n", rbtree_to_str(self.t2)

    def run(self):
        self.test_insert()

    def test_insert(self):
        t = rbtree_clone(self.t2)
        t = rb_insert(t, 4)
        print "t2: after insert 4\n", rbtree_to_str(t)
        t = list_to_tree([5, 2, 7, 1, 4, 6, 9, 3, 8])
        print "list->tree, create t1 by insert\n", rbtree_to_str(t)
\end{lstlisting}

Here we use the example tree present in CLRS as in figure \ref{fig:rb-insert-clrs}.

%\begin{figure}[htbp]
%       \begin{center}
%	\includegraphics[scale=0.5]{img/rb-insert-clrs.eps}
%        \caption{insertion and fixing} \label{fig:rb-insert-clrs}
%       \end{center}
%\end{figure}

The program will output 2 trees in console.

\begin{verbatim}
t2, CLRS fig 13.4:
(((. 1:B .) 2:R ((. 5:R .) 7:B (. 8:R .))) 11:B (. 14:B (. 15:R .)))
t2: after insert 4
(((. 1:B .) 2:R ((. 4:R .) 5:B .)) 7:B ((. 8:B .) 11:R (. 14:B (. 15:R .))))
list->tree, create t1 by insert
(((. 1:B .) 2:R ((. 3:R .) 4:B .)) 5:B ((. 6:B .) 7:R ((. 8:R .) 9:B .)))
\end{verbatim}

After insert element 4 into the first tree the result will be like in figure \ref{fig:rb-insert-clrs} (d), the second test case shows a tree which is created from a list as shown in figure \ref{fig:python-insert}.

%\begin{figure}[htbp]
%       \begin{center}
%	\includegraphics[scale=0.5]{img/python-insert.ps}
%        \caption{insert from a list} \label{fig:python-insert}
%       \end{center}
%\end{figure}

\subsubsection*{C++ red black tree insertion}

The C++ SGI STL implementation of red black tree also adopts the
concept of the sentinel as described in CLRS. Every time we initialize
an empty red black tree, it create such sentinel first.

\lstset{language=c++}
\begin{lstlisting}
void _M_empty_initialize() {
  _S_color(_M_header) = _S_rb_tree_red; // used to distinguish header from 
                                      // __root, in iterator.operator++
  _M_root() = 0;
  _M_leftmost() = _M_header;
  _M_rightmost() = _M_header;
}
\end{lstlisting}

Where the left sides are accessor operators, which returns the
reference of color, and other fields etc. There is a good explanation
in \cite{hj-stl}.

C++ SGI STL version of insertion provided two options,
insert\_unique() and insert\_equal(), we only present one of them in
this post.

\begin{lstlisting}
template <class _Key, class _Value, class _KeyOfValue, ...>
typename _Rb_tree<_Key,_Value,_KeyOfValue, ...>::iterator
_Rb_tree<_Key,_Value,_KeyOfValue, ...>
  ::insert_equal(const _Value& __v)
{
  _Link_type __y = _M_header;
  _Link_type __x = _M_root();
  while (__x != 0) {
    __y = __x;
    __x = _M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ? 
            _S_left(__x) : _S_right(__x);
  }
  return _M_insert(__x, __y, __v);
}
\end{lstlisting}

In order to focus on the algorithm itself, I replace the allocator and
the compare template parameter with '...'. The insert will first use a 
while loop to locate where the new value should be inserted. then it
call \_M\_insert() function to do the real insertion. Where x is the
the insert position, y point to the parent of x.

Next, SGI STL will call the core insert function which is defined as
the following.

\begin{lstlisting}
template <class _Key, class _Value, class _KeyOfValue, ...>
typename _Rb_tree<_Key,_Value,_KeyOfValue, ...>::iterator
_Rb_tree<_Key,_Value,_KeyOfValue, ...>
  ::_M_insert(_Base_ptr __x_, _Base_ptr __y_, const _Value& __v)
{
  _Link_type __x = (_Link_type) __x_;
  _Link_type __y = (_Link_type) __y_;
  _Link_type __z;

  if (__y == _M_header || __x != 0 || 
      _M_key_compare(_KeyOfValue()(__v), _S_key(__y))) {
    __z = _M_create_node(__v);
    _S_left(__y) = __z;               // also makes _M_leftmost() = __z 
                                      //    when __y == _M_header
    if (__y == _M_header) {
      _M_root() = __z;
      _M_rightmost() = __z;
    }
    else if (__y == _M_leftmost())
      _M_leftmost() = __z;   // maintain _M_leftmost() pointing to min node
  }
  else {
    __z = _M_create_node(__v);
    _S_right(__y) = __z;
    if (__y == _M_rightmost())
      _M_rightmost() = __z;  // maintain _M_rightmost() pointing to max node
  }
  _S_parent(__z) = __y;
  _S_left(__z) = 0;
  _S_right(__z) = 0;
  _Rb_tree_rebalance(__z, _M_header->_M_parent);
  ++_M_node_count;
  return iterator(__z);
}
\end{lstlisting}

Most codes in this function deal with the leftmost and rightmost
members. They point to the minimum and maximum node in the tree. after
create the node with allocator, the program calls rebalance function
to fix the red-red violation.

\begin{lstlisting}
inline void 
_Rb_tree_rebalance(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)
{
  __x->_M_color = _S_rb_tree_red;
  while (__x != __root && __x->_M_parent->_M_color == _S_rb_tree_red) {
    if (__x->_M_parent == __x->_M_parent->_M_parent->_M_left) {
      _Rb_tree_node_base* __y = __x->_M_parent->_M_parent->_M_right;
      if (__y && __y->_M_color == _S_rb_tree_red) {
        __x->_M_parent->_M_color = _S_rb_tree_black;
        __y->_M_color = _S_rb_tree_black;
        __x->_M_parent->_M_parent->_M_color = _S_rb_tree_red;
        __x = __x->_M_parent->_M_parent;
      }
      else {
        if (__x == __x->_M_parent->_M_right) {
          __x = __x->_M_parent;
          _Rb_tree_rotate_left(__x, __root);
        }
        __x->_M_parent->_M_color = _S_rb_tree_black;
        __x->_M_parent->_M_parent->_M_color = _S_rb_tree_red;
        _Rb_tree_rotate_right(__x->_M_parent->_M_parent, __root);
      }
    }
    else {
      _Rb_tree_node_base* __y = __x->_M_parent->_M_parent->_M_left;
      if (__y && __y->_M_color == _S_rb_tree_red) {
        __x->_M_parent->_M_color = _S_rb_tree_black;
        __y->_M_color = _S_rb_tree_black;
        __x->_M_parent->_M_parent->_M_color = _S_rb_tree_red;
        __x = __x->_M_parent->_M_parent;
      }
      else {
        if (__x == __x->_M_parent->_M_left) {
          __x = __x->_M_parent;
          _Rb_tree_rotate_right(__x, __root);
        }
        __x->_M_parent->_M_color = _S_rb_tree_black;
        __x->_M_parent->_M_parent->_M_color = _S_rb_tree_red;
        _Rb_tree_rotate_left(__x->_M_parent->_M_parent, __root);
      }
    }
  }
  __root->_M_color = _S_rb_tree_black;
}
\end{lstlisting}

In the first line of this function, we always set the new added node as
red color to keep all properties except number 1 and number 4.

Note the last line of the fixing function, it force the color of root
to be black in order to keep the red black tree property 1. Inside the
while loop, there is a big if-else. All things in the if and else are
very similar to each other except they are left-right symmetric. the
logic conforms to the pseudo code in CLRS very well. I skip the detail
explanation. Please refer to \cite{hj-stl} page 260 to find the test cases.

If we compare the results from the functional implementation and from the imperative one, we can 
find there is difference. Even if we insert the same element into the same red black tree, the
results varies. This is because the functional way focus on expressive of the program, and there 
is a bit performance overhead in it. Okasaki discussed about the difference in his paper\cite{okasaki}.
And he show the result that the computation time is still $O(log n)$. It is possible to use a 
similar way to the imperative implementation. And that's a kind of fine tune in the 'balance()'
function. But it will loss the expressive merit.

% ================================================================
%                 Deletion
% ================================================================

\section{Deletion}

Deletion is more complex than insertion. Both functional and imperative implementation 
need face more cases to fix. Deletion may also violate the red black tree properties,
so we need fix it after the normal insertion as described in binary search tree\cite{bst-lxy}.

The deletion wasn't been discussed in Okasaki's paper\cite{okasaki}. I referred to a
handout of CLRS course\cite{lyn}. The problem only happens if you try to delete a black node.
Because it will violate the property 4 of red black tree, which means the number of black
node in the path may decreased so that it is not uniformed black-height any more.

CLRS proposed a 'doubly-black' approach to resume property 4. However in the real fixing
program, there is no explicit expression of the doubly-black node. I decided to use
this concept in this post

\subsubsection*{Haskell red black tree deletion, functional}

In order to express the 'doubly-node', I added a definition of it both in color and in node.

\lstset{language=Haskell}
\begin{lstlisting}
data Color = R | B | BB deriving (Show, Eq) -- BB: doubly black for deletion
data RBTree a = Empty
              | Node Color (RBTree a) a (RBTree a)
              | BBEmpty -- doubly black empty
\end{lstlisting}

Different from the basic deletion of binary search tree. I used the one like below:
\begin{itemize}
\item If the node to be deleted has an empty left child, use the right child to replace it;
\item If the right child is empty, use the left child to replace it;
\item If both children are not empty, use the minimum one in the right child to replace it, and
slice the minimum one out.
\end{itemize}

After it, if the node to be sliced out is black, we need fix the tree to keep the red black
properties.

\begin{lstlisting}
delete::(Ord a)=>RBTree a -> a -> RBTree a
delete t x = blackenRoot(del t x) where
    del Empty _ = Empty
    del (Node color l k r) x 
        | x < k = fixDB color (del l x) k r --[1]
        | x > k = fixDB color l k (del r x)
        -- x == k, delete this node
        | isEmpty l = if color==B then makeBlack r else r --[2]
        | isEmpty r = if color==B then makeBlack l else l
        | otherwise = fixDB color l k' (del r k') where k'= key (mint r)
    blackenRoot (Node _ l k r) = Node B l k r
    blackenRoot _ = Empty

makeBlack::RBTree a -> RBTree a
makeBlack (Node B l k r) = Node BB l k r -- doubly black
makeBlack (Node _ l k r) = Node B l k r
makeBlack Empty = BBEmpty
makeBlack t = t
\end{lstlisting}

Let me explain it a bit. The mint function as shown in \cite{bst-lxy} can help to find the 
minimum of a tree. While the isEmpty helper function can test if a node is empty. Let's review 
them here:

\begin{lstlisting}
-- helper functions
key::RBTree a -> a
key (Node _ _ k _) = k

left::RBTree a -> RBTree a
left (Node _ l _ _) = l
left _ = Empty

isEmpty::RBTree a -> Bool
isEmpty Empty = True
isEmpty _ = False

mint::RBTree a -> RBTree a
mint t = if isEmpty (left t) then t else mint (left t)
\end{lstlisting}

The blackenRoot function is used to keep the property 2, that the root of a red black tree
must be black. In line [2], if the color of the sliced root is black, I'll make the root 
of the sub-tree which will replace the deleted one be black. This can help to keep the property
4, so the black-height will not decreased.

For makeBlack() function, If the root is red, it will change it to black; if the root node is 
already black, it will mark it as 'doubly-black', and if it is empty, it will mark it as a 
doubly-black empty node by BBEmpty.

Next, we must use a function to fix the 'doubly-black' by rotation and color changes.

\begin{lstlisting}
-- Core function for delete, to solve the uniform black height violation.
-- refer to CLRS
fixDB::Color -> RBTree a -> a -> RBTree a -> RBTree a
fixDB color BBEmpty k Empty = Node BB Empty k Empty
fixDB color BBEmpty k r = Node color Empty k r
fixDB color Empty k BBEmpty = Node BB Empty k Empty
fixDB color l k BBEmpty = Node color l k Empty
-- the sibling is black, and it has one red child
fixDB color a@(Node BB _ _ _) x (Node B (Node R b y c) z d) = 
      Node color (Node B (makeBlack a) x b) y (Node B c z d)
fixDB color a@(Node BB _ _ _) x (Node B b y (Node R c z d)) = 
      Node color (Node B (makeBlack a) x b) y (Node B c z d)
fixDB color (Node B a x (Node R b y c)) z d@(Node BB _ _ _) = 
      Node color (Node B a x b) y (Node B c z (makeBlack d))
fixDB color (Node B (Node R a x b) y c) z d@(Node BB _ _ _) = 
      Node color (Node B a x b) y (Node B c z (makeBlack d))
-- the sibling and its 2 children are all black, propagate the blackness up
fixDB color a@(Node BB _ _ _) x (Node B b@(Node B _ _ _) y c@(Node B _ _ _))
    = makeBlack (Node color (makeBlack a) x (Node R b y c))
fixDB color (Node B a@(Node B _ _ _) x b@(Node B _ _ _)) y c@(Node BB _ _ _)
    = makeBlack (Node color (Node R a x b) y (makeBlack c))
-- the sibling is red
fixDB B a@(Node BB _ _ _) x (Node R b y c) = fixDB B (fixDB R a x b) y c
fixDB B (Node R a x b) y c@(Node BB _ _ _) = fixDB B a x (fixDB R b y c)
-- otherwise
fixDB color l k r = Node color l k r
\end{lstlisting}

The first 4 lines are used to fix the doubly black empty node by pattern matching.
If one of the child is doubly black, and the other one isn't empty, we can safely
recover the doubly black empty to normal empty node. Like the below figure, if we
want to delete the node 4 from the sub tree, because left child of node 4 is empty, 
and the color is black, so the program will make the right child of node 4 black.
Since the right child of node 4 is also empty, so it will use a doubly black node
to replace node 4. Which means for node 5, it then has a doubly empty left child
and has a right child with root node 6. In such case we can safely change the
double black empty to normal empty node. which won't violate any red black properties.

On the other hand, if a node has an doubly black empty node and the other one is
also empty, we have to push the doubly black up one level. For example, if we want
to delete node 1 from the sub tree, because it's left child is empty, so the program
will use a doubly black empty node to replace 1. Then node 2 has a left BBEmpty and
has a right empty. In such case we must mark node 2 as doubly black after change its
left child back to empty.

%\begin{figure}[htbp]
%       \begin{center}
%	\includegraphics[scale=0.5]{img/db-fix.ps}
%        \caption{example sub tree} \label{fig:exmple-tree}
%       \end{center}
%\end{figure}

After these 4 lines pattern matching program, there won't be any doubly black empty
node in the tree, we can go down to process other cases.

Then we entered the case that the sibling of the doubly black node is black and it
has one red child. In such case, we can fix the doubly blackness with one rotation.
Actually there are 4 different situation's in this case, all of them can be transform
to one form. They are shown in the figure \ref{fig:del-case1}. These cases are described
in CLRS as case 3 and case 4.

%\begin{figure}[htbp]
%       \begin{center}
%	\includegraphics[scale=0.4]{img/del-case1.eps}
%        \caption{case 1, fix the doubly black by rotation} \label{fig:del-case1}
%       \end{center}
%\end{figure}

In the figure, the doubly black node are shown in black circle with 2 edges.

After these 4 cases, the program entered another case. In this case, not only the sibling
of the doubly black node is black, but also its two children are black. We can change to color
of the sibling node to red and propagate the doubly black one level up to the parent node.

Let's review the 2 lines which are applied to this case. They are shown in figure \ref{fig:del-case2}.

\begin{lstlisting}
-- the sibling and its 2 children are all black, propagate the blackness up
fixDB color a@(Node BB _ _ _) x (Node B b@(Node B _ _ _) y c@(Node B _ _ _))
    = makeBlack (Node color (makeBlack a) x (Node R b y c))
fixDB color (Node B a@(Node B _ _ _) x b@(Node B _ _ _)) y c@(Node BB _ _ _)
    = makeBlack (Node color (Node R a x b) y (makeBlack c))
\end{lstlisting}

%\begin{figure}[htbp]
%       \begin{center}
%	\includegraphics[scale=0.4]{img/del-case2.eps}
%        \caption{case 2, propagate the blackness up.} \label{fig:del-case2}
%       \end{center}
%\end{figure}

These two cases are described in CLRS as case 2.

Next, we entered the final case. In this case, the sibling of the doubly black node is red.
We can do a rotation to change this case to case 1. the source code and the figures are shown
as below.

\begin{lstlisting}
-- the sibling is red
fixDB B a@(Node BB _ _ _) x (Node R b y c) = fixDB B (fixDB R a x b) y c
fixDB B (Node R a x b) y c@(Node BB _ _ _) = fixDB B a x (fixDB R b y c)
\end{lstlisting}

%\begin{figure}[htbp]
%       \begin{center}
%	\includegraphics[scale=0.4]{img/del-case3.eps}
%        \caption{case 3, the sibling of the doubly black is red.} \label{fig:del-case3}
%       \end{center}
%\end{figure}

This two cases are described in CLRS as case 1.

By fixing the doubly black node with the above 3 cases, There are two termination conditions
which the program will stop at. One is the case 1, The doubly black node was eliminated. The
other 2 cases may continuously propagate the doubly black node from bottom to top till the root.
Finally the program will mark the root node as black anyway, so the doubly blackness will be
removed.

we can test this delete program by using the following test cases:

\begin{lstlisting}
t1=listToRBTree [11, 2, 14, 1, 7, 15, 5, 8, 4]

testDel = "\ntest del 4: " ++ show (delete t1 4) ++
          "\ntest del 5: " ++ show (delete t1 5) ++
          "\ntest del 2: " ++ show (delete t1 2) ++
          "\ntest del 7: " ++ show (delete t1 7) ++
          "\ntest del 14: " ++ show (delete t1 14)

main = do
  putStrLn testDel
\end{lstlisting}

The program will output the result as below.

\begin{verbatim}
test del 4: (((. 1:B .) 2:B (. 5:B .)) 7:B (((. 8:R .) 11:B .) 14:B (. 15:B .)))
test del 5: (((. 1:B .) 2:B (. 4:B .)) 7:B (((. 8:R .) 11:B .) 14:B (. 15:B .)))
test del 2: (((. 1:B .) 4:B (. 5:B .)) 7:B (((. 8:R .) 11:B .) 14:B (. 15:B .)))
test del 7: (((. 1:B .) 2:B ((. 4:R .) 5:B .)) 8:B ((. 11:B .) 14:B (. 15:B .)))
test del 14: (((. 1:B .) 2:B ((. 4:R .) 5:B .)) 7:B (((. 8:R .) 11:B .) 15:B .))
\end{verbatim}

\subsubsection*{Python deletion, imperative}

Imperative deletion method is well discussed in CLRS. Since I added some helper member functions
in the red black tree definition. The delete method without the fixing part can be much simpler
than the one I give in \cite{bst-lxy}. Similar to the functional approach, I explicitly defined
the doubly black concept.

\lstset{language=Python}
\begin{lstlisting}
RED = 0
BLACK = 1
DOUBLY_BLACK = 2
\end{lstlisting}

There is small trick if I define doubly black color as integer 2, I can use color+1 to represent
doubly blackness later.

\lstset{language=Python}
\begin{lstlisting}
def rb_delete(t, x):
    if x is None: return t
    (parent, db) = (x.parent, None)
    if x.left is None:
        x.replace_by(x.right)
        db=x.right
    elif x.right is None:
        x.replace_by(x.left)
        db=x.left
    else:
        y = tree_min(x.right)
        (parent, db)=(y.parent, y.right)
        x.key = y.key
        y.replace_by(y.right)
        x=y
    if x.color == BLACK:
        t=rb_delete_fix(t, make_black(parent, db))
    remove_node(x)
    return t
\end{lstlisting}

The major difference is in the tail part. If the sliced out node is black, the program will
try a fixing procedure to re-balance the red black tree. The parameter pass to the fixing
function includes the tree and the doubly black node. In order to locate the doubly black
node. I provide a function make\_black(). It is implemented like this.

\begin{lstlisting}
def make_black(parent, x):
    if x is None:
        if is_leaf(parent):
            parent.color = DOUBLY_BLACK
        return parent
    else:
        x.color = x.color + 1
        return x

def is_leaf(x):
    if x is None: return False
    return (x.left is None) and (x.right is None)
\end{lstlisting}

In the delete function, I use parent to record the parent pointer of the node to be deleted. 
And variable db is point to the root of the sub tree which will replace x. db may be empty.
make\_black() function will check this predication. If it (the db) is empty, and the parent is a leaf
node (which means parent has a one child empty and another child doubly black empty), we make
the parent node doubly black. else we change the color of it (the db) to either black or doubly
black by increasing the color value by 1. please refer to the BBEmpty section in functional 
implementation for detail.

This delete function also use some read-only querying method, such as tree\_min(), they are defined
as same as in \cite{bst-lxy}. Let's review them again.

\begin{lstlisting}
def tree_min(t):
    while(t!=None and t.left != None):
        t = t.left
    return t

def remove_node(x):
    if (x is None): return
    x.parent = x.left = x.right = None

def tree_search(t, x):
    while(t!=None and t.key != x):
        if(x < t.key): t = t.left
        else: t = t.right
    return t
\end{lstlisting}

Next we go to the core function of the delete fixing procedure. Basically it is strictly implemented
based on CLRS.

\begin{lstlisting}
def rb_delete_fix(t, db):
    if db is None: return None # remove the root from a leaf tree
    while(db!=t and db.color==DOUBLY_BLACK):
        if db.sibling() != None:
            # case 1:  the sibling is red, (transform to make it black)
            if is_red(db.sibling()): 
                set_color([db.parent, db.sibling()],[RED, BLACK])
                if(db == db.parent.left):
                    t=left_rotate(t, db.parent)
                else:
                    t=right_rotate(t, db.parent)
            # case 3, 4: the sibling is black, and one nephew is red
            elif is_black(db.sibling()) and is_red(db.sibling().left): 
                if db == db.parent.left:
                    colors=[BLACK, BLACK, db.parent.color]
                    set_color([db, db.parent, 
                                   db.sibling().left], colors)
                    t=right_rotate(t, db.sibling())
                    t=left_rotate(t, db.parent)
                else:
                    colors=[BLACK, BLACK, db.parent.color, BLACK]
                    set_color([db, db.parent, db.sibling(), 
                                   db.sibling().left], colors)
                    t=right_rotate(t, db.parent)
            elif is_black(db.sibling()) and is_red(db.sibling().right):
                if db == db.parent.left:
                    colors=[BLACK, BLACK, db.parent.color, BLACK]
                    set_color([db, db.parent, db.sibling(), 
                                   db.sibling().right], colors)
                    t=left_rotate(t, db.parent)
                else:
                    colors=[BLACK, BLACK, db.parent.color]
                    set_color([db, db.parent, db.sibling().right], colors)
                    t=left_rotate(t, db.sibling())
                    t=right_rotate(t, db.parent)
            # case 2: the sibling and both nephews are black. 
            # (move the blackness up)
            elif is_black(db.sibling()) and (not is_red(db.sibling().left)) 
                   and (not is_red(db.sibling().right)):
               set_color([db, db.sibling()], [BLACK, RED])
               db.parent.color=db.parent.color+1
               db = db.parent
            # a sibling without child is invalid case, because it 
            # violate property 5
        else: # no sibling, we can move blackness up
            db.color = BLACK
            db.parent.color = db.parent.color+1
            db = db.parent
    t.color=BLACK
    return t
\end{lstlisting}

There is a slight difference from CLRS, I found either the sibling is on the left or on
the right, case 1 in the program can be applied in same way, so I pulled it up. There are
also 2 helper function to test if a node is red node or black node as below.

\begin{lstlisting}
def is_red(x):
    if x is None: return False
    return x.color == RED

def is_black(x):
    if x is None: return False
    return x.color == BLACK
\end{lstlisting}

In order to test the delete function for red black tree, I defined some similar helper
functions. The test cases are something like below.

\begin{lstlisting}
class Test:
    ...
    def __assert(self, msg, x, y):
        if(x == y): msg = msg + "OK."
        else: msg = msg + str(x) + "!=" + str(y) + "Fail."
        print msg

    def __test_del_n(self, tree, n):
        t = rbtree_clone(tree)
        t = rb_delete(t, tree_search(t, n))
        print "del ", n, ": ", rbtree_to_str(t)
        self.__assert("search after del: ", tree_search(t, n), None)

    def test_delete(self):
        for i in range(1, 10):
            self.__test_del_n(self.t1, i)
        self.__test_del_n(self.t1, 11) #del a non-exist value
        t = Node(1, BLACK) #leaf case
        self.__test_del_n(t, 1)
\end{lstlisting}

It will output the result in console.

\begin{verbatim}
del  1 :  ((. 2:R ((. 3:R .) 4:B .)) 5:B ((. 6:B .) 7:R ((. 8:R .) 9:B .)))
search after del: OK.
del  2 :  (((. 1:B .) 3:R (. 4:B .)) 5:B ((. 6:B .) 7:R ((. 8:R .) 9:B .)))
search after del: OK.
del  3 :  (((. 1:B .) 2:R (. 4:B .)) 5:B ((. 6:B .) 7:R ((. 8:R .) 9:B .)))
search after del: OK.
del  4 :  (((. 1:B .) 2:R (. 3:B .)) 5:B ((. 6:B .) 7:R ((. 8:R .) 9:B .)))
search after del: OK.
del  5 :  (((. 1:B .) 2:R ((. 3:R .) 4:B .)) 6:B (. 7:R ((. 8:R .) 9:B .)))
search after del: OK.
del  6 :  (((. 1:B .) 2:R ((. 3:R .) 4:B .)) 5:B (. 7:R ((. 8:R .) 9:B .)))
search after del: OK.
del  7 :  (((. 1:B .) 2:R ((. 3:R .) 4:B .)) 5:B ((. 6:B .) 8:R (. 9:B .)))
search after del: OK.
del  8 :  (((. 1:B .) 2:R ((. 3:R .) 4:B .)) 5:B ((. 6:B .) 7:R (. 9:B .)))
search after del: OK.
del  9 :  (((. 1:B .) 2:R ((. 3:R .) 4:B .)) 5:B ((. 6:B .) 7:R (. 8:B .)))
search after del: OK.
del  11 :  (((. 1:B .) 2:R ((. 3:R .) 4:B .)) 5:B ((. 6:B .) 7:R ((. 8:R .) 9:B .)))
search after del: OK.
del  1 :  .
search after del: OK.
\end{verbatim}

\subsubsection*{Scheme/Lisp deletion, functional}

Scheme/Lisp version of red-black tree deletion need more logical conditions 
without pattern matching. I defined some delete specific helper functions first.

\lstset{language=lisp}
\begin{lstlisting}
(define (dblack? t)
  (if (null? t) '() (equal? (color t) "BB")))

(define (set-color c t)
  (make-rbtree c (left t) (key t) (right t)))

(define (leaf? x)
  (if (null? x) '() (and (null? (left x)) (null? (right x)))))

(define (make-black parent t)
  (if (null? t)
      (if (leaf? parent) (set-color "BB" parent) parent)
      (if (red? t) (set-color "B" t) (set-color "BB" t))))

(define (tree-min tree) 
  (if (null? (left tree)) 
      tree 
      (tree-min (left tree)))) 
\end{lstlisting}

Function dblack is used to test if a node is doubly black. As same as Haskell
and Python version, I used explicit doubly black color in implementation. Function
set-color actually doesn't change the color of a node, (so no ! in the function
name) it create a new tree with specified color. Function leaf can help
to test if a node has both its children empty.

Function make-black is more
similar to the python version than the Haskell version. It takes 2 parameters,
one is the parent node, the other is the node we want to make it black.
This function can cover the doubly black empty case. In such case, it will
change the color of the parent node as doubly black if necessary.

The last helper function tree-min is as same as the one in binary search tree
\cite{bst-lxy}. It can help to find the minimum value in a tree.

With these helper functions, I defined the delete function as the following.

\begin{lstlisting}
(define (rb-delete tree x) ;; x is a value, not a node
  (define (blacken-root t)
    (if (null? t) '() (set-color "B" t)))
  (define (del t x)
    (cond ((null? t) '())
	  ((< x (key t)) (fix-dblack (color t) 
				     (del (left t) x)
				     (key t)
				     (right t)))
	  ((> x (key t)) (fix-dblack (color t)
				     (left t)
				     (key t)
				     (del (right t) x)))
	  ((null? (left t)) (if (black? t)
				(make-black t (right t))
				(right t)))
	  ((null? (right t)) (if (black? t)
				 (make-black t (left t))
				 (left t)))
	  (else (let ((newkey (key (tree-min (right t)))))
		  (fix-dblack (color t)
			      (left t)
			      newkey
			      (del (right t) newkey))))))
  (blacken-root (del tree x)))
\end{lstlisting}

Compare this implementation with the Haskell one, we can find they
are very same to each other. Most of the part is similar to the 
normal binary search tree deletion, however, it must fix the red
black tree property violation if we slice a black node out.

The core function to fixing this violation is defined like this.

\begin{lstlisting}
(define (fix-dblack c l k r)
  (cond 
   ;;case 1, the sibling is black, and it has one red child
   ((and (dblack? l) (black? r) (red? (left r)))
    (make-rbtree c 
		 (make-rbtree "B" (set-color "B" l) k (left (left r)))
		 (key (left r))
		 (make-rbtree "B" (right (left r)) (key r) (right r))))
   ((and (dblack? l) (black? r) (red? (right r)))
    (make-rbtree c
		 (make-rbtree "B" (set-color "B" l) k (left r))
		 (key r)
		 (set-color "B" (right r))))
   ((and (dblack? r) (black? l) (red? (right l)))
    (make-rbtree c
		 (make-rbtree "B" (left l) (key l) (left (right l)))
		 (key (right l))
		 (make-rbtree "B" (right (right l)) k (set-color "B" r))))
   ((and (dblack? r) (black? l) (red? (left l)))
    (make-rbtree c
		 (set-color "B" (left l))
		 (key l)
		 (make-rbtree "B" (right l) k (set-color "B" r))))
   ;;case 2, the sibling and its 2 children are all black,
   ;;        propagate the blackness up
   ((and (dblack? l) (black? r) (black? (left r)) (black? (right r)))
    (make-black '() (make-rbtree c
				 (set-color "B" l)
				 k
				 (set-color "R" r))))
   ((and (dblack? r) (black? l) (black? (left l)) (black? (right l)))
    (make-black '() (make-rbtree c
				 (set-color "R" l)
				 k
				 (set-color "B" r))))
   ;;case 3, the silbing is red
   ((and (dblack? l) (red? r))
    (fix-dblack "B" (fix-dblack "R" l k (left r)) (key r) (right r)))
   ((and (dblack? r) (red? l))
    (fix-dblack "B" (left l) (key l) (fix-dblack "R" (right l) k r)))
   (else (make-rbtree c l k r))))
\end{lstlisting}

Here is all about red black tree deletion in Scheme/Lisp. We can
test it with the following cases.

\begin{lstlisting}
(define (test-del) 
  (display (rb-delete t1 4)) (newline) 
  (display (rb-delete t1 5)) (newline) 
  (display (rb-delete t1 2)) (newline) 
  (display (rb-delete t1 7)) (newline) 
  (display (rb-delete t1 14)) (newline) 
  (display (rb-delete t1 3)))
\end{lstlisting}

If we evaluate the test-del in scheme R-E-P-L, the results are shown
like this.

\begin{verbatim}
(test-del)
(((() 1 B ()) 2 B (() 5 B ())) 7 B (((() 8 R ()) 11 B ()) 14 B (() 15 B ())))
(((() 1 B ()) 2 B (() 4 B ())) 7 B (((() 8 R ()) 11 B ()) 14 B (() 15 B ())))
(((() 1 B ()) 4 B (() 5 B ())) 7 B (((() 8 R ()) 11 B ()) 14 B (() 15 B ())))
(((() 1 B ()) 2 B ((() 4 R ()) 5 B ())) 8 B ((() 11 B ()) 14 B (() 15 B ())))
(((() 1 B ()) 2 B ((() 4 R ()) 5 B ())) 7 B ((() 8 B ()) 11 B (() 15 B (() 15 B ()))))
(((() 1 B ()) 2 B ((() 4 R ()) 5 B ())) 7 B (((() 8 R ()) 11 B ()) 14 B (() 15 B ())))
\end{verbatim}

The results are identify with the one output by Haskell.

\subsubsection*{C++ red black tree deletion}

I left C++ version of delete be the last one in this post because it
is most complex part. 
In C++ SGI STL, red black tree is deleted by passing a iterator as the
parameter. It represents the position where the node should be
deleted.

\lstset{language=C++}
\begin{lstlisting}
template <class _Key, class _Value, ...>
inline void _Rb_tree<_Key, ...>
  ::erase(iterator __position)
{
  _Link_type __y = 
    (_Link_type) _Rb_tree_rebalance_for_erase(__position._M_node,
                                              _M_header->_M_parent,
                                              _M_header->_M_left,
                                              _M_header->_M_right);
  destroy_node(__y);
  --_M_node_count;
}
\end{lstlisting}

The core algorithm is located in the rebalace for erase function as
the following.

\begin{lstlisting}
inline _Rb_tree_node_base*
_Rb_tree_rebalance_for_erase(_Rb_tree_node_base* __z,
                             _Rb_tree_node_base*& __root,
                             _Rb_tree_node_base*& __leftmost,
                             _Rb_tree_node_base*& __rightmost)
{
  _Rb_tree_node_base* __y = __z;
  _Rb_tree_node_base* __x = 0;
  _Rb_tree_node_base* __x_parent = 0;
  if (__y->_M_left == 0)     // __z has at most one non-null child. y == z.
    __x = __y->_M_right;     // __x might be null.
  else
    if (__y->_M_right == 0)  // __z has exactly one non-null child. y == z.
      __x = __y->_M_left;    // __x is not null.
    else {                   // __z has two non-null children.  Set __y to
      __y = __y->_M_right;   //   __z's successor.  __x might be null.
      while (__y->_M_left != 0)
        __y = __y->_M_left;
      __x = __y->_M_right;
    }
  if (__y != __z) {          // relink y in place of z.  y is z's successor
    __z->_M_left->_M_parent = __y; 
    __y->_M_left = __z->_M_left;
    if (__y != __z->_M_right) {
      __x_parent = __y->_M_parent;
      if (__x) __x->_M_parent = __y->_M_parent;
      __y->_M_parent->_M_left = __x;      // __y must be a child of _M_left
      __y->_M_right = __z->_M_right;
      __z->_M_right->_M_parent = __y;
    }
    else
      __x_parent = __y;  
    if (__root == __z)
      __root = __y;
    else if (__z->_M_parent->_M_left == __z)
      __z->_M_parent->_M_left = __y;
    else 
      __z->_M_parent->_M_right = __y;
    __y->_M_parent = __z->_M_parent;
    __STD::swap(__y->_M_color, __z->_M_color);
    __y = __z;
    // __y now points to node to be actually deleted
  }
  else {                        // __y == __z
    __x_parent = __y->_M_parent;
    if (__x) __x->_M_parent = __y->_M_parent;   
    if (__root == __z)
      __root = __x;
    else 
      if (__z->_M_parent->_M_left == __z)
        __z->_M_parent->_M_left = __x;
      else
        __z->_M_parent->_M_right = __x;
    if (__leftmost == __z) 
      if (__z->_M_right == 0)        // __z->_M_left must be null also
        __leftmost = __z->_M_parent;
    // makes __leftmost == _M_header if __z == __root
      else
        __leftmost = _Rb_tree_node_base::_S_minimum(__x);
    if (__rightmost == __z)  
      if (__z->_M_left == 0)         // __z->_M_right must be null also
        __rightmost = __z->_M_parent;  
    // makes __rightmost == _M_header if __z == __root
      else                      // __x == __z->_M_left
        __rightmost = _Rb_tree_node_base::_S_maximum(__x);
  }
  if (__y->_M_color != _S_rb_tree_red) { 
    while (__x != __root && (__x == 0 || __x->_M_color == _S_rb_tree_black))
      if (__x == __x_parent->_M_left) {
        _Rb_tree_node_base* __w = __x_parent->_M_right;
        if (__w->_M_color == _S_rb_tree_red) {
          __w->_M_color = _S_rb_tree_black;
          __x_parent->_M_color = _S_rb_tree_red;
          _Rb_tree_rotate_left(__x_parent, __root);
          __w = __x_parent->_M_right;
        }
        if ((__w->_M_left == 0 || 
             __w->_M_left->_M_color == _S_rb_tree_black) &&
            (__w->_M_right == 0 || 
             __w->_M_right->_M_color == _S_rb_tree_black)) {
          __w->_M_color = _S_rb_tree_red;
          __x = __x_parent;
          __x_parent = __x_parent->_M_parent;
        } else {
          if (__w->_M_right == 0 || 
              __w->_M_right->_M_color == _S_rb_tree_black) {
            if (__w->_M_left) __w->_M_left->_M_color = _S_rb_tree_black;
            __w->_M_color = _S_rb_tree_red;
            _Rb_tree_rotate_right(__w, __root);
            __w = __x_parent->_M_right;
          }
          __w->_M_color = __x_parent->_M_color;
          __x_parent->_M_color = _S_rb_tree_black;
          if (__w->_M_right) __w->_M_right->_M_color = _S_rb_tree_black;
          _Rb_tree_rotate_left(__x_parent, __root);
          break;
        }
      } else {                  // same as above, with _M_right <-> _M_left.
        _Rb_tree_node_base* __w = __x_parent->_M_left;
        if (__w->_M_color == _S_rb_tree_red) {
          __w->_M_color = _S_rb_tree_black;
          __x_parent->_M_color = _S_rb_tree_red;
          _Rb_tree_rotate_right(__x_parent, __root);
          __w = __x_parent->_M_left;
        }
        if ((__w->_M_right == 0 || 
             __w->_M_right->_M_color == _S_rb_tree_black) &&
            (__w->_M_left == 0 || 
             __w->_M_left->_M_color == _S_rb_tree_black)) {
          __w->_M_color = _S_rb_tree_red;
          __x = __x_parent;
          __x_parent = __x_parent->_M_parent;
        } else {
          if (__w->_M_left == 0 || 
              __w->_M_left->_M_color == _S_rb_tree_black) {
            if (__w->_M_right) __w->_M_right->_M_color = _S_rb_tree_black;
            __w->_M_color = _S_rb_tree_red;
            _Rb_tree_rotate_left(__w, __root);
            __w = __x_parent->_M_left;
          }
          __w->_M_color = __x_parent->_M_color;
          __x_parent->_M_color = _S_rb_tree_black;
          if (__w->_M_left) __w->_M_left->_M_color = _S_rb_tree_black;
          _Rb_tree_rotate_right(__x_parent, __root);
          break;
        }
      }
    if (__x) __x->_M_color = _S_rb_tree_black;
  }
  return __y;
}
\end{lstlisting}

In order to focus on the core algorithm, Let's put our eye on the
while loop. In case the deleted node is not red, it will break the red
black tree property number 5. Then we entered the while loop until
either we move the doubly blackness up to root or solved it only by
making color changes. Inside the while, be outer if-else each deal
with 3 cases. They are left-right symmetric to each other. Those 3
cases covers the sibling is red; the sibling and one nephew are black;
and the sibling with both nephew are all black.

\section{Appendix} \label{appendix}
%\appendix
All programs except the SGI STL C++ are provided along with this article. They are free for downloading.
\begin{itemize}
\item RBTree.hs, Haskell version of red black tree, with test cases. I compiled
and tested it with GHC 6.10.4.
\item rbtree.py, Python version of the red black tree, with test cases. Tested
with Python 2.5.1
\item rbtree.scm, Scheme version of the red black tree and test cases. Tested
with MIT/Scheme 14.9
\end{itemize}

SGI STL C++ implementation of red black tree can be found from here:
http://www.sgi.com/tech/stl/stl\_tree.h

Besides them, I use graphviz to draw most of the figures in this post. In order to
translate the red black tree output to dot language scripts. I wrote a python program.
it can be used like this.

\begin{verbatim}
./rbt2dot.py -o foo.dot "(((. 1:B .) 2:B .) 3:R ((. 4:B .) 5:B (. 6:B  .)))"
\end{verbatim}

This helper scripts can also be downloaded with this article.

download position: http://sites.google.com/site/algoxy/rbtree/rbtree.zip

\begin{thebibliography}{99}

\bibitem{CLRS}
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. 
``Introduction to Algorithms, Second Edition''. ISBN:0262032937. The MIT Press. 2001

\bibitem{okasaki-int-map}
Chris Okasaki and Andrew Gill. ``Fast Mergeable Integer
Maps''. Workshop on ML, September 1998, pages 77-86, http://www.cse.ogi.edu/~andy/pub/finite.htm

\bibitem{patricia-morrison}
D.R. Morrison, ``PATRICIA -- Practical Algorithm To Retrieve  Information Coded In Alphanumeric", Journal of the ACM, 15(4), October 1968, pages 514-534.

\bibitem{wiki-suffix-tree}
Suffix Tree, Wikipedia. http://en.wikipedia.org/wiki/Suffix\_tree

\bibitem{wiki-trie}
Trie, Wikipedia. http://en.wikipedia.org/wiki/Trie

\end{thebibliography}

\ifx\wholebook\relax\else
\end{document}
\fi
