\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
%\input{../../../common.tex}
\input{../../../common-en.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Trie, Patricia, and Suffix tree, with Functional and imperative implementation}

\author{Liu~Xinyu
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
%  Tel:   +86-1305-196-8666 \newline}
  }

\markboth{Trie, Patricia, and Suffix tree}
{imperative and functional implementation}

\maketitle

\ifx\wholebook\relax
\chapter{Trie, Patricia, and Suffix tree, with Functional and imperative implementation}

\section{abstract}
\else
\begin{abstract}
\fi
Trie, Patricia, and Suffix tree are important data structures in
information retreiving and manipulating. None of these data structures
are new. They were invented in 1960s. This post collects some
existing knowledge about them. Some functional and imperative
implementation are given in order to show the basic idea of these data structures.
There are multiple programming languages used, including, C++, Haskell, python and scheme/lisp.
C++ and python are mostly used to show the imperative implementation, while Haskell and Scheme are
used for functional purpose.

There may be mistakes in the post, please feel free to point out.

This post is generated by \LaTeXe, and provided with GNU FDL(GNU Free Documentation License).
Please refer to http://www.gnu.org/copyleft/fdl.html for detail.

\ifx\wholebook\relax\else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} Trie, Patricia, Radix tree, Suffix tree

%{\bfseries Corresponding Author:} Liu Xinyu

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

There isn't a seperate chapter about Trie, Patricia, ans Suffix tree
in CLRS book. While these data structure are very basic, especially in
information retrieving. Some of them are also widely used in
compiler design\cite{okasaki-int-map}, and bio-information area, such as
DNA pattern matching \cite{wiki-suffix-tree}.

In CLRS book index, Trie is redirected to Radix tree, while Radix tree
is described in Problem 12-1 \cite{CLRS}.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/radix-tree.eps}
        \caption{an Radix tree example in CLRS} \label{fig:radix-tree}
       \end{center}
\end{figure}

Figure \ref{fig:radix-tree} shows a radix tree contains the bit
strings 1011, 10, 011, 100 and 0. When searching for a key $k=b_0b_1...b_n$, we
take the first bit $b_0$ (MSB from left), check if it is 0 or 1, if it
is 0, we turn left, and turn right for 1. Then we take the 2nd bit and
repeat this search until we either meet a leaf or finish all n bits.

Note that radix tree needn't store any key in node at all. The
infomation are represented by edges in fact. The node with key string
in the above figure are only for illustration.

It is very natural to come to the idea `is it possible to represent
keys in integers instead of string, because integer can be denoted in
binary format?'. Such approach can save spaces and it is fast if we
can use bitwise manipulation.

I'll first show the integer Trie data structure and implementation in
section \ref{int-trie}. Then we can point out the drawbacks and go to
the improved data structure of integer Patricia in
section \ref{int-patricia}.
After that, I'll show alphabetic Trie and Patricia and list some
typicall use of them in textual manipulation engineering problems.
I'll show Suffix tree data structure and linear time contruction
algorithm in section \ref{suffix-tree}.

This article provides example implementation of Trie, Patricia and Suffix tree
in C, C++, Haskell, Python, and Scheme/Lisp languages. Some functional
implementation can be referenced from current Haskell packages \ref{hackage-int-map} 
\ref{hackage-bytestring-map}.

All source code can be downloaded in appendix \ref{appendix}, please 
refer to appendix for detailed information about build and run.

% ================================================================
%                 Int Trie
% ================================================================
\section{Integer Trie}
\label{int-trie}

Let's give a definition of the data structure in figure \ref{radix-trie}.
To be more accurate, it should be called as \emph{binary trie}. a binary
trie is a binary tree in which the placement of each key is controlled by
its bits, each 0 means ``go left at the next node'' and each 1 means ``go
right at the next node''\cite{okasaki-int-map}.

Because integers can be represented in binary format in computer, it is 
possible to store integer keys rather than 0,1 strings. When we insert an
integer as a new key to the trie, we take first bit, if it is 0, we recursively
insert the other bits to the left sub tree; if it is 1, we insert into right
sub tree.

However, there is a problem if we treat the key as integer. Consider a binary
trie shows in figure \ref{fig:big-endian-trie}. If the keys are represented in 
string based on '0' and '1', all the three keys are different. While if they are
turned into integers, they are identical. So if we want to insert a data with integer
key 3, where should we put it into the trie?

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/big-endian-trie.ps}
        \caption{a big-endian trie} \label{fig:big-endian-trie}
       \end{center}
\end{figure}

One approach is to treat all prefix zero as effective bits.
Suppose an integer is represented in 32-bits, If we want to insert key 1 to a trie, 
it will end up with a 32 level tree. 
There are 31 node has only 1 left sub tree and the last node has
a right sub tree. It is very inefficent in terms of space.

Chris Okasaki shows a method to solve this problem in \cite{okasaki-int-map}. Instead of 
normal big-endian integer, we can use little-endian integer as key. By using little-endian,
decimal integer 1 is represent as binary 1, if we insert it to an empty binary trie, we
get a trie with a root and a right leaf. It is only 1 level. For integer 3, it is 11 in 
birnary, we needn't add any prefix 0, the position in the trie is unique.

%=========================================================================
%       Definition of integer trie
%=========================================================================
\subsection{Definition of Integer Trie}
Trie is invented by Edward Fredkin. It comes from ``retrieval'', pronouces 
as /'tri:/ by the inventor, while it is pronouced /'trai/ ``try'' 
by other authors \cite{wiki-trie}.
The definition of little-endian binary trie is simple, we can reuse the structure
of binary tree, with its left sub tree to store 0 part and right tree to store 1 part.
The augment data can be stored as value.

\subsubsection*{Definition of little-edian interger trie in Haskell}
In trie, since a node may not contains value, so we use Haskell Maybe data to represent
this situation. A IntTrie node is either an empty node, or a branch node. The branch
node contains a left child a `Maybe' value and a right child. 

\lstset{language=Haskell}
\begin{lstlisting}
data IntTrie a = Empty 
               | Branch (IntTrie a) (Maybe a) (IntTrie a) -- left, value, right

type Key = Int

-- helpers
left :: IntTrie a -> IntTrie a
left (Branch l _ _) = l
left Empty = Empty

right :: IntTrie a -> IntTrie a
right (Branch _ _ r) = r
right Empty = Empty

value :: IntTrie a -> Maybe a
value (Branch _ v _) = v
value Empty = Nothing
\end{lstlisting}

In order to access the children and value some helper functions are given.

\subsubsection*{Definition of little-edian interger trie in Python}
The definition of integer trie in Python is shown as below

\lstset{language=Python}
\begin{lstlisting}
class IntTrie:
    def __init__(self):
        self.value = None
        self.left = self.right = None
\end{lstlisting}

left child and right child represent sub trie, and value is used to 
store actual data.

% ================================================================
%               Insertion of integer trie
% ================================================================
\subsection{Insertion of integer trie}
Since the key is little-endian, when we insert a key into trie, we take the
bit from right most (LSB). If it is 0, we go to the left child, and go to right
for 1. if the child is empty, we need create new node, and repeat this until
met the last bit (MSB) of the integer.

%\begin{algorithm}
\begin{algorithmic}
\STATE $INT-TRIE-INSERT(T, x, data)$
\IF{$T = NIL$}
   \STATE $T \leftarrow EmptyNode$ \ENDIF

  \STATE $p=T$
  \WHILE{$x \neq 0$}
    \IF{$EVEN(x) = TRUE$}
      \STATE $p \leftarrow LEFT(p)$
    \ELSE
      \STATE $p \leftarrow RIGHT(p)$
    \ENDIF
    \IF{$p = NIL$}
      \STATE $p \leftarrow EmptyNode$ \ENDIF
    \STATE $x \leftarrow x/2$
  \ENDWHILE
  \STATE $DATA(p) \leftarrow data$
\end{algorithmic}
%\end{algorithm}

\subsubsection*{Insertion of integer trie in Haskell}
To simply the problem, If user insert a data with key already exists, we simply
overwrite the previous stored data. This approach can be easily replaced with 
other methods, such as storing data as a linked list etc.

Insertion integer key into a trie can be implementated with Haskell as below.

\lstset{language=Haskell}
\begin{lstlisting}
insert :: IntTrie a -> Key -> a -> IntTrie a
insert t 0 x = Branch (left t) (Just x) (right t)
insert t k x = 
  if even k
       then Branch (insert (left t) (k `div` 2) x) (value t) (right t)
       else Branch (left t) (value t) (insert (right t) (k `div` 2) x)
\end{lstlisting}

If the key is zero, we just insert the data to current node, in other
cases, the program go down along the trie according to the last bit
of the key.

To test if this program, some test helper functions are provided.

\begin{lstlisting}
fromList :: [(Key, a)] -> IntTrie a
fromList xs = foldl ins Empty xs where
    ins t (k, v) = insert t k v

-- k = ... a2, a1, a0 ==> k' = ai * m + k, where m=2^i
toString :: (Show a)=>IntTrie a -> String
toString t = toStr t 0 1 where
    toStr Empty k m = "."
    toStr tr k m = "(" ++ (toStr (left tr) k (2*m)) ++
                      " " ++ (show k) ++ (valueStr (value tr)) ++
                      " " ++ (toStr (right tr) (m+k) (2*m)) ++ ")"
    valueStr (Just x) = ":" ++ (show x)
    valueStr _ = ""
\end{lstlisting}

fromList function can create a trie from a list of integer-data pairs.
toString function can turn a trie data structure to readable string
for printing. This is a modified in-order tree traverse, since the number
stored is in little-endian, the program store the $2^m$ to calculate
the keys. The following code shows a test.

\begin{lstlisting}
main = do
  putStrLn (toString (fromList [(1, 'a'), (4, 'b'), (5, 'c'), (9, 'd')]))
\end{lstlisting}

This will output:
\begin{verbatim}
(((. 0 (. 4:'b' .)) 0 .) 0 (((. 1 (. 9:'d' .)) 1 (. 5:'c' .)) 1:'a' .))
\end{verbatim}

Figure \ref{int-trie} shows this result. 
\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/int-trie.ps}
        \caption{An little-endian integer binary trie for the map 
          \{$ 1 \rightarrow a, 4 \rightarrow b, 5 \rightarrow c, 9 \rightarrow d$\}.} 
        \label{fig:int-trie}
       \end{center}
\end{figure}

\subsubsection*{Insertion of integer trie in Python}
Imperative implementation of insertion in Python can be easily given by translating
the pseudocode of the algorithm.

\lstset{language=Python}
\begin{lstlisting}
def trie_insert(t, key, value = None):
    if t is None:
        t = IntTrie()

    p = t
    while key != 0:
        if key & 1 == 0:
            if p.left is None:
                p.left = IntTrie()
            p = p.left
        else:
            if p.right is None:
                p.right = IntTrie()
            p = p.right
        key = key>>1
    p.value = value
    return t
\end{lstlisting}

In order to test this insertion program, some test helpers are provided:

\begin{lstlisting}
def trie_to_str(t, prefix=0, depth=0):
    to_str = lambda x: "%s" %x
    str="("+to_str(prefix)
    if t.value is not None:
        str += ":"+t.value
    if t.left is not None:
        str += ", "+trie_to_str(t.left, prefix, depth+1)
    if t.right is not None:
        str += ", "+trie_to_str(t.right, (1<<depth)+prefix, depth+1)
    str+=")"
    return str

def list_to_trie(l):
    t = None
    for x in l:
        t = trie_insert(t, x)
    return t

def map_to_trie(m):
    t = None
    for k, v in m.items():
        t = trie_insert(t, k, v)
    return t
\end{lstlisting}

Function trie\_to\_str can print the contents of trie in pre-order,
It doesn't only print the value of the ndoe, but also print the edge information.

Function list\_to\_trie can repeatly insert a list of keys into a trie, since the
default argument of value is None, so all data relative to keys are empty. If the
data isn't empty, function map\_to\_trie can insert a list of key-value pairs into 
the trie.

Then a test classe is given to encapasulate test cases:

\begin{lstlisting}
class IntTrieTest:
    def run(self):
        self.test_insert()

    def test_insert(self):
        t = None
        t = trie_insert(t, 0);
        t = trie_insert(t, 1);
        t = trie_insert(t, 4);
        t = trie_insert(t, 5);
        print trie_to_str(t)
        t1 = list_to_trie([1, 4, 5])
        print trie_to_str(t1)
        t2 = map_to_trie({4:'b', 1:'a', 5:'c', 9:'d'})
        print trie_to_str(t2)

if __name__ == "__main__":
    IntTrieTest().run()
\end{lstlisting}

Running this program will print the following result.

\begin{verbatim}
(0, (0, (0, (4))), (1, (1, (5))))
(0, (0, (0, (4))), (1, (1, (5))))
(0, (0, (0, (4:b))), (1:a, (1, (1, (9:d)), (5:c))))
\end{verbatim}

Please note that by pre-ordre traverse trie, we can get a 'lexical' order
result of the keys. For instance, the last result print the little-endian
format of key 1, 4, 5, 9 as below.

\begin{verbatim}
001
1
1001
101
\end{verbatim}

They are in lexcical order. We'll go back to this feature of trie later in 
alphabetic trie section.

% ================================================================
%               Look up in integer binary trie
% ================================================================
\subsection{Look up in integer binary trie} 

To look up a key in a little-endian integer binary trie. We take each
bit of the key from left (LSB), and go left or right according to if
the bit is 0, untill we consumes all bits. this algorithm can be described
as below pseudocode.

\begin{algorithmic}
\STATE $INT-TRIE-LOOKUP(T, x)$
  \WHILE{$x \neq 0$ and $T \neq NIL$}
    \IF{$EVEN(x) = TRUE$}
      \STATE $T \leftarrow LEFT(T)$
    \ELSE
      \STATE $T \leftarrow RIGHT(T)$
    \ENDIF
    \STATE $x \leftarrow x/2$
  \ENDWHILE
  \IF{$T \neq NIL$} \RETURN $DATA(T)$
  \ELSE \RETURN $NIL$ \ENDIF
\end{algorithmic}

\subsubsection*{Look up implemented in Haskell}
The algorithm in pseudocode is in imperative way, It can also be implemented 
recursivly like below Haskell program

\lstset{language=Haskell}
\begin{lstlisting}
search :: IntTrie a -> Key -> Maybe a
search Empty k = Nothing
search t 0 = value t
search t k = if even k then search (left t) (k `div` 2)
             else search (right t) (k `div` 2)
\end{lstlisting}

If trie is empty, we simply returns nothing; if key is zero we return the 
value of current node; in other case we recursively search either left
child or right child according to the LSB is 0 or not.

To test this program, we can write a smoke test case as following.

\begin{lstlisting}
testIntTrie = "t=" ++ (toString t) ++ 
              "\nsearch t 4: " ++ (show $ search t 4) ++
              "\nsearch t 0: " ++ (show $ search t 0)
    where
      t = fromList [(1, 'a'), (4, 'b'), (5, 'c'), (9, 'd')]

main = do
  putStrLn testIntTrie
\end{lstlisting}

This program will output these result.

\begin{verbatim}
t=(((. 0 (. 4:'b' .)) 0 .) 0 (((. 1 (. 9:'d' .)) 1 (. 5:'c' .)) 1:'a' .))
search t 4: Just 'b'
search t 0: Nothing
\end{verbatim}

\subsubsection*{Look up implemented in Python}
By translate the algorithm in pseudocode, we can easily get a python 
implementation.

\lstset{language=Python}
\begin{lstlisting}
def lookup(t, key):
    while key != 0 and (t is not None):
        if key & 1 == 0:
            t = t.left
        else:
            t = t.right
        key = key>>1
    if t is not None:
        return t.value
    else:
        return None
\end{lstlisting}

In this implementation, instead of using even-odd property, bit-wise
manipulation is used to test if a bit is 0 or 1.

Here is the smoke test of the lookup function.

\begin{lstlisting}
class IntTrieTest:
    #...
    def test_lookup(self):
        t = map_to_trie({4:'y', 1:'x', 5:'z'})
        print "look up 4: ", lookup(t, 4)
        print "look up 5: ", lookup(t, 5)
        print "look up 0: ", lookup(t, 0)
\end{lstlisting}

The output of the test cases is as below.

\begin{verbatim}
look up 4:  y
look up 5:  z
look up 0:  None
\end{verbatim}

% ================================================================
%               Int Patricia
% ================================================================
\section{Integer Patricia Tree} 
\label{int-patricia}

It's very easy to find the drawbacks of integer binary trie. Trie wasts a lot of 
spaces. Note in figure \ref{int-trie}, all nodes except leafs store the real data.
Typically, an integer binary trie contains many nodes only have one child.
It is very easy to come to the idea for improvement, to compress the chained nodes
which have only one child. Patricia is such a data structure invented by 
Donald R. Morrison in 1968. Patricia means practical algorithm to retrieve information coded
in aphanumeric\cite{patricia-morrison}. Wikipedia redirect Patricia as Radix tree.

Chris Okasaki gave his implementation of Integer Patricia tree in paper \cite{okasaki-int-map}. 
If we merge the chained nodes which have only one child together in figure \ref{fig:int-trie},
We can get a patricia as shown in figure \ref{fig:little-endian-patricia}.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/little-endian-patricia.ps}
        \caption{Little endian patricia for the map 
                        \{$ 1 \rightarrow a, 4 \rightarrow b, 5 \rightarrow c, 9 \rightarrow d$\}.} 
        \label{fig:little-endian-patricia}
       \end{center}
\end{figure}

From this figure, we can found that they keys of sibling nodes have the longest common prefix.
They only branches out at certain bit. It means that we can save a lot of data by storing the common
prefix. 

Different from integer Trie, using big-endian integer in Patricia doesn't cause the problem mentioned
in section \ref{int-trie}. Becasue all zero bits before MSB can be just omitted to save space. Big-endian
interger is more natural than little-endian integer. Chris Okasaki list some significant advantages
of big-endian Patricia trees \cite{okasaki-int-map}.

% ================================================================
%                 Definition of int patricia tree
% ================================================================
\subsection{Definition of Integer Patricia tree}
Integer Patricia tree is a speical kind of binary tree, it is
\begin{itemize}
\item either a leaf node contains an integer key and a value
\item or a branch node, contains a left child and a right child. The
integer keys of two children shares the longest common prefix bits,
the next bit of the left child's key is zero while it is one for right
child's key.
\end{itemize}

\subsubsection*{Definition of big-endian integer Patricia tree in Haskell}
If we translate the above recurisive definition to Haskell, we can get
below Integer Patrica Tree code.

\lstset{language=Haskell}
\begin{lstlisting}
data IntTree a = Empty 
               | Leaf Key a
               | Branch Prefix Mask (IntTree a) (IntTree a) -- prefix, mask, left, right

type Key = Int
type Prefix = Int
type Mask = Int
\end{lstlisting}

In order to tell from which bit the left and right children differ, a
mask is recorded by the branch node. Typically, a mask is $2^n$, all
lower bits than n doesn't belong to common prefix

\subsubsection*{Definition of big-endian integer Patricia tree in Python}
Such definition can be represent in Python similarly. Some helper
functions are provided for easy operation later on.

\lstset{language=Python}
\begin{lstlisting}
class IntTree:
    def __init__(self, key = None, value = None):
        self.key = key
        self.value = value
        self.prefix = self.mask = None
        self.left = self.right = None

    def set_children(self, l, r):
        self.left = l
        self.right = r

    def replace_child(self, x, y):
        if self.left == x:
            self.left = y
        else:
            self.right = y

    def is_leaf(self):
        return self.left is None and self.right is None

    def get_prefix(self):
        if self.prefix is None:
            return self.key
        else:
            return self.prefix
\end{lstlisting}

% ================================================================
%                 Insertion of int patricia tree
% ================================================================
\subsection{Insertion of Integer Patricia tree}
When insert a key into a integer Patricia tree, if the tree is empty,
we can just create a leaf node with the given key and data. (as shown
in figure \ref{fig:int-patricia-insert-a}).

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=1]{img/int-patricia-insert-a.ps}
        \caption{(a). Insert key 12 to an empty patricia tree.}
        \label{fig:int-patricia-insert-a}
       \end{center}
\end{figure}

If the tree only contains a leaf node x, we can create a branch, put the new
key and data as a leaf y of the branch. To determin if the new leaf y
should be left node or right node. We need find the longest common prefix
of x and y, for example if key(x) is 12 (1100 in binary), key(y) is 15
(1111 in binary), then the longest common prefix is $11oo$. The $o$
denotes the bits we don't care about. we can use an integer to mask
the those bits. In this case, the mask number is 4 (100 in binary).
The next bit after the prefix presents $2^1$. It's 0 in key(x), while
it is 1 in key(y). So we put x as left child and y as right
child. Figure \ref{fig:int-patricia-insert-b} shows this case.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=1]{img/int-patricia-insert-b.ps}
        \caption{(b). Insert key 15 to the result tree in (a).}
        \label{fig:int-patricia-insert-b}
       \end{center}
\end{figure}

If the tree is neither empty, nor a leaf node, we need firstly check
if the key to be inserted matches common prefix with root node. If it
does, then we can recursively insert the key to the left child or right child
according to the next bit. For instance, if we want to
insert key 14 (1110 in binary) to the result tree in figure 
\ref{fig:int-patricia-insert-b}, since it has common prefix $11oo$,
and the next bit (the bit of $2^1$) is 1, so we tried to insert 14 to
the right child. Otherwise, if the key to be inserted desn't match the
common prefix with the root node, we need branch a new leaf
node. Figure \ref{fig:int-patricia-insert-c} shows these 2 different cases.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/int-patricia-insert-c.ps}
	\includegraphics[scale=0.5]{img/int-patricia-insert-d.ps}
        \caption{(c). Insert key 14 to the ressult tree in (b);
	(d). Insert key 5 to the result tree in (b).}
        \label{fig:int-patricia-insert-c}
       \end{center}
\end{figure}

Summarize the above cases, the insertion of integer patricia can be described
with the following algorithm.

\begin{algorithmic}
\STATE $INT-PATRICIA-INSERT(T, x, data)$
\IF{$T = NIL$}
   \STATE $T \leftarrow CREATE-LEAF(x, data)$
   \RETURN $T$
\ENDIF

\STATE $y \leftarrow T$
\STATE $p \leftarrow NIL$
\WHILE{$y$ is not $LEAF$ and $MATCH(x, PREFIX(y), MASK(y))$}
  \STATE $p \leftarrow y$
  \IF{$ZERO(x, MASK(y)) = TRUE$}
    \STATE $y \leftarrow LEFT(y)$
  \ELSE
    \STATE $y \leftarrow RIGHT(y)$
  \ENDIF
\ENDWHILE

\IF{$LEAF(y) = TRUE$ and $x = KEY(y)$}
  \STATE $DATA(y) \leftarrow data$ 
\ELSE
  \STATE $z \leftarrow BRANCH(y, CREATE-LEAF(x, data))$
  \IF{$p = NIL$}
    \STATE $T \leftarrow z$
  \ELSE
    \IF{$LEFT(p) = y$}
      \STATE $LEFT(p) \leftarrow z$
    \ELSE
      \STATE $RIGHT(p) \leftarrow z$
    \ENDIF
  \ENDIF
\ENDIF
\RETURN $T$
\end{algorithmic}

In the above algorithm, MATCH procedure test if an integer key $x$, has 
the same prefix of node y above the mask bit. For instance,
Suppose the prefix of node y can be denoted as 
$p(n), p(n-1), ..., p(i), ..., p(0)$ in binary, key x is
$k(n), k(n-1), ..., k(i), ..., k(0)$, and mask of node y is 
$100...0=2^i$, if and only if $p(j)=k(j)$ for all $i \leq j \leq n$, 
we say the key matches.

\subsubsection*{Insertion of big-endian integer Patricia tree in Haskell}
Insertion of big-endian integer Patricia tree can be implemented in Haskell
by Change the above algorithm to recursive approach.

\lstset{language=Haskell}
\begin{lstlisting}
-- usage: insert tree key x
insert :: IntTree a -> Key -> a -> IntTree a
insert t k x 
   = case t of
       Empty -> Leaf k x
       Leaf k' x' -> if k==k' then Leaf k x
                     else join k (Leaf k x) k' t -- t@(Leaf k' x')
       Branch p m l r
          | match k p m -> if zero k m
                           then Branch p m (insert l k x) r
                           else Branch p m l (insert r k x)
          | otherwise -> join k (Leaf k x) p t -- t@(Branch p m l r)
\end{lstlisting}

The match, zero and join functions in this program are defined as below.
\begin{lstlisting}
-- join 2 nodes together.
-- (prefix1, tree1) ++ (prefix2, tree2)
--  1. find the longest common prefix == lcp(prefix1, prefix2), where
--         prefix1 = a(n),a(n-1),...a(i+1),a(i),x...
--         prefix2 = a(n),a(n-1),...a(i+1),a(i),y...
--         prefix  = a(n),a(n-1),...a(i+1),a(i),00...0
--  2. mask bit = 100...0b (=2^i)
--         so mask is something like, 1,2,4,...,128,256,...
--  3. if      x=='0', y=='1' then (tree1=>left, tree2=>right), 
--     else if x=='1', y=='0' then (tree2=>left, tree1=>right).
join :: Prefix -> IntTree a -> Prefix -> IntTree a -> IntTree a
join p1 t1 p2 t2 = if zero p1 m then Branch p m t1 t2
                                else Branch p m t2 t1 
    where
      (p, m) = lcp p1 p2

-- 'lcp' means 'longest common prefix'
lcp :: Prefix -> Prefix -> (Prefix, Mask)
lcp p1 p2 = (p, m) where
    m = bit (highestBit (p1 `xor` p2))
    p = mask p1 m

-- get the order of highest bit of 1.
-- For a number x = 00...0,1,a(i-1)...a(1)
-- the result is i
highestBit :: Int -> Int
highestBit x = if x==0 then 0 else 1+highestBit (shiftR x 1)

-- For a number x = a(n),a(n-1)...a(i),a(i-1),...,a(0)
-- and a mask m = 100..0 (=2^i)
-- the result of mask x m is a(n),a(n-1)...a(i),00..0
mask :: Int -> Mask -> Int
mask x m = (x .&. complement (m-1)) -- complement means bitwise not.

-- Test if the next bit after mask bit is zero
-- For a number x = a(n),a(n-1)...a(i),1,...a(0)
-- and a mask   m = 100..0 (=2^i)
-- because the bit next to a(i) is 1, so the result is False
-- For a number y = a(n),a(n-1)...a(i),0,...a(0) the result is True.
zero :: Int -> Mask -> Bool
zero x m = x .&. (shiftR m 1) == 0

-- Test if a key matches a prefix above of the mask bit
-- For a prefix: p(n),p(n-1)...p(i)...p(0)
--     a key:    k(n),k(n-1)...k(i)...k(0)
-- and a mask:                 100..0 = (2^i)
-- If and only if p(j)==k(j), i<=j<=n the result is True
match :: Key -> Prefix -> Mask -> Bool
match k p m = (mask k m) == p
\end{lstlisting}

In order to test the above insertion program, some test helper functions
are provided.

\begin{lstlisting}
-- Generate a Int Patricia tree from a list
-- Usage: fromList [(k1, x1), (k2, x2),..., (kn, xn)]
fromList :: [(Key, a)] -> IntTree a
fromList xs = foldl ins Empty xs where
    ins t (k, v) = insert t k v

toString :: (Show a)=>IntTree a -> String
toString t =
    case t of
      Empty -> "."
      Leaf k x -> (show k) ++ ":" ++ (show x)
      Branch p m l r -> "[" ++ (show p) ++ "@" ++ (show m) ++ "]" ++ 
                        "(" ++ (toString l) ++ ", " ++ (toString r) ++ ")"

\end{lstlisting}

With these helpers, insertion can be test as the following.

\begin{lstlisting}
testIntTree = "t=" ++ (toString t) 
    where
      t = fromList [(1, 'x'), (4, 'y'), (5, 'z')]

main = do
  putStrLn testIntTree
\end{lstlisting}

This test will output:

\begin{verbatim}
t=[0@8](1:'x', [4@2](4:'y', 5:'z'))
\end{verbatim}

This result means the program creates a Patrica tree shown in Figure \ref{fig:int-patricia-haskell-insert}.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=1]{img/int-patricia-haskell-insert.ps}
        \caption{Insert map $1 \rightarrow x, 4 \rightarrow y, 5 \rightarrow z$ into a big-endian integer Patricia tree.}
        \label{fig:int-patricia-haskell-insert}
       \end{center}
\end{figure}

\subsubsection*{Insertion of big-endian integer Patricia tree in Python}
In order to simplify the operation, I added prefix and mask member
variables to the Patricia tree difinition in Python
implementation. Also there are some helper methods are provided.

\lstset{language=Python}
\begin{lstlisting}
class IntTree:
    def __init__(self, key = None, value = None):
        self.key = key
        self.value = value
        self.prefix = self.mask = None
        self.left = self.right = None

    def set_children(self, l, r):
        self.left = l
        self.right = r

    def replace_child(self, x, y):
        if self.left == x:
            self.left = y
        else:
            self.right = y

    def is_leaf(self):
        return self.left is None and self.right is None

    def get_prefix(self):
        if self.prefix is None:
            return self.key
        else:
            return self.prefix
\end{lstlisting}

The main insertion program can be realized as the following.

\begin{lstlisting}
def insert(t, key, value = None):
    if t is None:
        t = IntTree(key, value)
        return t

    node = t
    parent = None
    while(True):
        if match(key, node):
            parent = node
            if zero(key, node.mask):
                node = node.left
            else:
                node = node.right
        else:
            if node.is_leaf() and key == node.key:
                node.value = value
            else:
                new_node = branch(node, IntTree(key, value))
                if parent is None:
                    t = new_node
                else:
                    parent.replace_child(node, new_node)
            break
    return t
\end{lstlisting}

Where the sub prodedure of match, branch, lcp etc. are given as below.

\begin{lstlisting}
def maskbit(x, mask):
    return x & (~(mask-1))

def match(key, tree):
    if tree.is_leaf():
        return False
    return maskbit(key, tree.mask) == tree.prefix

def zero(x, mask):
    return x & (mask>>1) == 0

def lcp(p1, p2):
    diff = (p1 ^ p2)
    mask=1
    while(diff!=0):
        diff>>=1
        mask<<=1
    return (maskbit(p1, mask), mask)

def branch(t1, t2):
    t = IntTree()
    (t.prefix, t.mask) = lcp(t1.get_prefix(), t2.get_prefix())
    if zero(t1.get_prefix(), t.mask):
        t.set_children(t1, t2)
    else:
        t.set_children(t2, t1)
    return t
\end{lstlisting}

To convert a list or a map into a Patricia tree, we can repeatly
insert the elements one by one.

\begin{lstlisting}
def list_to_patricia(l):
    t = None
    for x in l:
        t = insert(t, x)
    return t

def map_to_patricia(m):
    t = None
    for k, v in m.items():
        t = insert(t, k, v)
    return t
\end{lstlisting}

In order to have smoke test of the above insertion program, some test
cases and output helper are given.

\begin{lstlisting}
def to_string(t):
    to_str = lambda x: "%s" %x
    if t is None:
        return ""
    if t.is_leaf():
        str = to_str(t.key)
        if t.value is not None:
            str += ":"+to_str(t.value)
        return str
    str ="["+to_str(t.prefix)+"@"+to_str(t.mask)+"]"
    str+="("+to_string(t.left)+","+to_string(t.right)+")"
    return str

class IntTreeTest:
    def run(self):
        self.test_insert()

    def test_insert(self):
        print "test insert"
        t = list_to_patricia([6])
        print to_string(t)
        t = list_to_patricia([6, 7])
        print to_string(t)
        t = map_to_patricia({1:'x', 4:'y', 5:'z'})
        print to_string(t)

if __name__ == "__main__":
    IntTreeTest().run()
\end{lstlisting}

The program will output a similar result as the Haskell one.

\begin{verbatim}
test insert
6
[6@2](6,7)
[0@8](1:x,[4@2](4:y,5:z))
\end{verbatim}

% ================================================================
%                 Lookup in int patricia tree
% ================================================================
\subsection{Look up in Integer Patricia tree}
Consider the property of integer Patricia tree, to look up a
key, we test if the key has common prefix with the root, if yes, we
then check the next bit differs from common prefix is zero or one. If
it is zero, we then do look up in the left child, else we turn to
right.

In case we reach a leaf node, we can directly check if the key of the
leaf is equal to what we are looking up. This algorithm can be
described with the following pseudo code.

\begin{algorithmic}
\STATE $INT-PATRICIA-LOOK-UP(T, x)$
  \IF{$T = NIL$}
    \RETURN $NIL$ \ENDIF

  \WHILE{$T$ is not $LEAF$ and $MATCH(x, PREFIX(T), MASK(T))$}
    \IF{$ZERO(x, MASK(T))$}
      \STATE $T \leftarrow LEFT(T)$
    \ELSE
      \STATE $T \leftarrow RIGHT(T)$
    \ENDIF
  \ENDWHILE

  \IF{$T$ is $LEAF$ and $KEY(T)=x$}
    \RETURN $DATA(T)$ 
  \ELSE
    \RETURN $NIL$
  \ENDIF
\end{algorithmic}

\subsubsection*{Look up in big-endian integer Patricia tree in Haskell}
By changing the above algorithm into recursive approach, we can get
Haskell version of looking up program.

\lstset{language=Haskell}
\begin{lstlisting}
-- look up a key
search :: IntTree a -> Key -> Maybe a
search t k 
  = case t of
      Empty -> Nothing
      Leaf k' x -> if k==k' then Just x else Nothing
      Branch p m l r 
             | match k p m -> if zero k m then search l k
                              else search r k
             | otherwise -> Nothing
\end{lstlisting}

And we can test this program with looking up some keys in the
previously created Patricia tree.

\begin{lstlisting}
testIntTree = "t=" ++ (toString t) ++ "\nsearch t 4: " ++ (show $ search t 4) ++
              "\nsearch t 0: " ++ (show $ search t 0)
    where
      t = fromList [(1, 'x'), (4, 'y'), (5, 'z')]

main = do
  putStrLn testIntTree
\end{lstlisting}

The output result is as the following.

\begin{verbatim}
t=[0@8](1:'x', [4@2](4:'y', 5:'z'))
search t 4: Just 'y'
search t 0: Nothing
\end{verbatim}

\subsubsection*{Look up in big-endian integer Patricia tree in Python}
With Python, we can directly translate the pseudo code into valid
program.

\lstset{language=Python}
\begin{lstlisting}
def lookup(t, key):
    if t is None:
        return None
    while (not t.is_leaf()) and match(key, t):
        if zero(key, t.mask):
            t = t.left
        else:
            t = t.right
    if t.is_leaf() and t.key == key:
        return t.value
    else:
        return None
\end{lstlisting}

We can verify this program by some simple smoke test cases.

\begin{lstlisting}
print "test look up"
t = map_to_patricia({1:'x', 4:'y', 5:'z'})
print "look up 4: ", lookup(t, 4)
print "look up 0: ", lookup(t, 0)
\end{lstlisting}

We can get similar output as below.

\begin{verbatim}
test look up
look up 4:  y
look up 0:  None
\end{verbatim}

% ================================================================
%                 Alphabetic trie
% ================================================================
\section{Alphabetic Trie}
Integer based Trie and Patricia Tree can be a good start point. Such
technical plays important role in Compiler implementation. Okasaki
pointed that the widely used Haskell Compiler GHC (Glasgow Haskell 
Compiler), utilizes a similar implementation for serverl years before
1998 \cite{okasaki-int-map}. 

While if we extend the type of the key from integer to aphabetic
value, Trie and Patricia tree can be very useful in textual manipulation
engineering problems.

% ================================================================
%                 Definition of Alphabetic trie
% ================================================================
\subsection{Definition of alphabetic Trie}
If the key is alphabetic value, just left and right children can't
represent all values. For English, there are 26 letters and each can
be lower case or upper case. If we don't care about case, one solution
is to limit the number of branches (children) to 26. Some simplified
ANSI C implementation of Trie are defined by using an array of 26
letters. This can be illustrated as in Figure \ref{fig:trie-of-26}.

\begin{figure}[htbp]
  \begin{center}
    \includegraphics[scale=0.5]{img/trie-of-26.ps}
      \caption{A Trie with 26 branches, with key a, an, another, bool,
    boy and zoo inserted.}
      \label{fig:trie-of-26}
  \end{center}
\end{figure}

In each node, not all branches may contain data. for instance, in the
above figure, the root node only has its branches represent letter a,
b, and z have sub trees. Other branches such as for letter c, is
empty. For other nodes, empty branches (point to nil) are not shown.

I'll give such simplified implementation in ANSI C in later section,
however, before we go to the detailed source code, let's consider some
alternatives. 

In case of language other than English, there may be more letters than 26, 
and if we need
solve case sensitive problem. we face a problem of dynamic size of sub
branches. There are 2 typical method to represent children, one is by
using Hash table, the other is by using map. We'll show these two types
of method in Python and C++.

\subsubsection*{Definition of aphabetic Trie in ANSI C}
ANSI C implementation is to illustrate a simplified approach limited only
to insensitive English language case. The program can't deal with letters 
other than lower case 'a' to 'z' such as digits, space, tab etc.

\lstset{language=C}
\begin{lstlisting}
struct Trie{
  struct Trie* children[26];
  void* data;
};
\end{lstlisting}

In order to initialize/destroy the children and data, I also provide 2 helper
functions.

\begin{lstlisting}
struct Trie* create_node(){
  struct Trie* t = (struct Trie*)malloc(sizeof(struct Trie));
  int i;
  for(i=0; i<26; ++i)
    t->children[i]=0;
  t->data=0;
  return t;
}

void destroy(struct Trie* t){
  if(!t)
    return;

  int i;
  for(i=0; i<26; ++i)
    destroy(t->children[i]);

  if(t->data)
    free(t->data);
  free(t);
}
\end{lstlisting}

Note that, the destroy function uses recursive approach to free all
children nodes.

\subsubsection*{Definition of alphabetic Trie in Haskell}
We can use Haskell record syntax to get some ``free'' accessor
functions\cite{wiki-trie}. 

\lstset{language=Haskell}
\begin{lstlisting}
data Trie a = Trie { value :: Maybe a
                   , children :: [(Char, Trie a)]}

empty = Trie Nothing []
\end{lstlisting}

Neither Map nor Hash table is used, just a list of pairs can realize
the same purpose. Function empty can help to create an empty Trie
node. This implementation doesn't constrain the key values to lower
case English letters, it can actually contains any values of 'Char' type.

\subsubsection*{Definition of alphabetic Trie in Python}
In Python version, we can use Hash table as the data structure to
represent children nodes.

\lstset{language=Python}
\begin{lstlisting}
class Trie:
    def __init__(self):
        self.value = None
        self.children = {}
\end{lstlisting}

% ================================================================
%                 Insertion of Alphabetic trie
% ================================================================
\subsection{Insertion of aplhabetic trie}
To insert a key with type of string into a Trie, we pick the first letter
from the key string. Then check from the root node, we examine which branch
among the children represents this letter. If the branch is null, we then
create an empty node. After that, we pick the next letter from the key string
and pick the proper branch from the grand children of the root.

We repeat the above process till finishing all the letters of the key. 
At this time point, we can finally set the data to be inserted as the value 
of the node.

Note that the value of root node of Trie is always empty.

The below pseudo code describes the above insertion algorithm.

\begin{algorithmic}
\STATE $TRIE-INSERT(T, key, data)$
\IF{$T = NIL$}
   \STATE $T \leftarrow EmptyNode$ \ENDIF

  \STATE $p=T$
  \FOR{each $c$ in $key$}
    \IF{$CHILDREN(p)[c] = NIL$}
      \STATE $CHILDREN(p)[c] \leftarrow EmptyNode$
    \ENDIF
    \STATE $p \leftarrow CHILDREN(p)[c]$
  \ENDFOR
  \STATE $DATA(p) \leftarrow data$
  \RETURN $T$
\end{algorithmic}

\subsubsection*{Simplified insertion of alphabetic trie in ANSI C}
Go on with the above ANSI C definition, because only lower case 
English letter is supported, we can use plan array manipulation
to do the insertion.

\lstset{language=C}
\begin{lstlisting}
struct Trie* insert(struct Trie* t, const char* key, void* value){
  if(!t)
    t=create_node();

  struct Trie* p =t;
  while(*key){
    int c = *key - 'a';
    if(!p->children[c])
      p->children[c] = create_node();
    p = p->children[c];
    ++key;
  }
  p->data = value;
  return t;
}
\end{lstlisting}

In order to test the above program, some helper functions
to print content of the Trie is provided as the following.

\begin{lstlisting}
void print_trie(struct Trie* t, const char* prefix){
  printf("(%s", prefix);
  if(t->data)
    printf(":%s", (char*)(t->data));
  int i;
  for(i=0; i<26; ++i){
    if(t->children[i]){
      printf(", ");
      char* new_prefix=(char*)malloc(strlen(prefix+1)*sizeof(char));
      sprintf(new_prefix, "%s%c", prefix, i+'a');
      print_trie(t->children[i], new_prefix);
    }
  }
  printf(")");
}
\end{lstlisting}

After that, we can test the insertion program with such test
cases.
                                   
\begin{lstlisting}
struct Trie* test_insert(){
  struct Trie* t=0;
  t = insert(t, "a", 0);
  t = insert(t, "an", 0);
  t = insert(t, "another", 0);
  t = insert(t, "boy", 0);
  t = insert(t, "bool", 0);
  t = insert(t, "zoo", 0);
  print_trie(t, "");
  return t;
}

int main(int argc, char** argv){
  struct Trie* t = test_insert();
  destroy(t);
  return 0;
}
\end{lstlisting}

This program will output a Trie like this.

\begin{verbatim}
(, (a, (an, (ano, (anot, (anoth, (anothe, (another))))))), 
(b, (bo, (boo, (bool)), (boy))), (z, (zo, (zoo))))
\end{verbatim}

It is exactly the Trie as shown in figure \ref{fig:trie-of-26}.

\subsubsection*{Insertion of alphabetic trie in Haskell}
To realize the insertion in Haskell, The only thing we need do is
to translate the for-each loop into recursive call. 

\lstset{language=Haskell}
\begin{lstlisting}
insert :: Trie a -> String -> a -> Trie a
insert t []     x = Trie (Just x)  (children t)
insert t (k:ks) x = Trie (value t) (ins (children t) k ks x) where
    ins [] k ks x = [(k, (insert empty ks x))]
    ins (p:ps) k ks x = if fst p == k 
                        then (k, insert (snd p) ks x):ps
                        else p:(ins ps k ks x)
\end{lstlisting}

If the key is empty, the program reaches the trivial terminator case.
It just set the value. In other case, it examine the children recursively.
Each element of the children is a pair, contains a character and
a branch. 

Some helpef funcitons are provided as the following.

\begin{lstlisting}
fromList :: [(String, a)] -> Trie a
fromList xs = foldl ins empty xs where
    ins t (k, v) = insert t k v

toString :: (Show a)=> Trie a -> String
toString t = toStr t "" where
    toStr t prefix = "(" ++ prefix ++ showMaybe (value t) ++ 
                     (concat (map (\(k, v)-> ", " ++ toStr v (prefix++[k])))
                                 (children t))
                     ++ ")"
    showMaybe Nothing = ""
    showMaybe (Just x)  = ":" ++ show x
\end{lstlisting}

The fromList function provide an easy way to repeatly extract
key-value pairs from a list and insert them into a Trie.

Function toString can print the Trie in a modified pre-order way.

We can test the above program with the below test cases.

\begin{lstlisting}
testTrie = "t=" ++ (toString t)
    where 
      t = fromList [("a", 1), ("an", 2), ("another", 7), ("boy", 3), 
                   ("bool", 4), ("zoo", 3)]

main = do
  putStrLn testTrie
\end{lstlisting}

The program outputs:

\begin{verbatim}
t=(, (a:1, (an:2, (ano, (anot, (anoth, (anothe, (another:7))))))), 
(b, (bo, (boy:3), (boo, (bool:4)))), (z, (zo, (zoo:3))))
\end{verbatim}

It is identical to the ANSI C result exept the values we inserted.

\subsubsection*{Insertion of alphabetic trie in C++}
in C++...

\lstset{language=C++}
\begin{lstlisting}
...
\end{lstlisting}


\subsubsection*{Insertion of alphabetic trie in Python}
in python...

\lstset{language=Python}
\begin{lstlisting}
...
\end{lstlisting}

\subsubsection*{Insertion of alphabetic trie in Scheme/Lisp}
in scheme/lisp...

\lstset{language=lisp}
\begin{lstlisting}
...
\end{lstlisting}

% ================================================================
%                 Look up in Alphabetic trie
% ================================================================
\subsection{Look up in aplhabetic trie}
Insertion...

Pseudocode...

\subsubsection*{Look up in alphabetic trie in Haskell}
in haskell...

\lstset{language=Haskell}
\begin{lstlisting}
...
\end{lstlisting}

\subsubsection*{Look up in alphabetic trie in C++}
in C++...

\lstset{language=C++}
\begin{lstlisting}
...
\end{lstlisting}


\subsubsection*{Look up in alphabetic trie in Python}
in python...

\lstset{language=Python}
\begin{lstlisting}
...
\end{lstlisting}

\subsubsection*{Look up in alphabetic trie in Scheme/Lisp}
in scheme/lisp...

\lstset{language=lisp}
\begin{lstlisting}
...
\end{lstlisting}

% ================================================================
%                 Alphabetic Patricia Tree
% ================================================================
\section{Alphabetic Patricia Tree}
Alphabetic patricia...

% ================================================================
%                 Definition of Alphabetic Patricia Tree
% ================================================================
\subsection{Definition of alphabetic Patricia Tree}
Definition...

\subsubsection*{Definition of alphabetic Patricia Tree in Haskell}
in Haskell...

\lstset{language=Haskell}
\begin{lstlisting}
...
\end{lstlisting}

\subsubsection*{Definition of alphabetic Patricia Tree in Python}
in Python...

\lstset{language=Python}
\begin{lstlisting}
...
\end{lstlisting}

% ================================================================
%                 Insertion of Alphabetic Patrica Tree
% ================================================================
\subsection{Insertion of aplhabetic Patricia Tree}
Insertion...

Pseudocode...

\subsubsection*{Insertion of alphabetic Patrica Tree in Haskell}
in haskell...

\lstset{language=Haskell}
\begin{lstlisting}
...
\end{lstlisting}

\subsubsection*{Insertion of alphabetic Patricia in C++}
in C++...

\lstset{language=C++}
\begin{lstlisting}
...
\end{lstlisting}


\subsubsection*{Insertion of alphabetic Patrica Tree in Python}
in python...

\lstset{language=Python}
\begin{lstlisting}
...
\end{lstlisting}

\subsubsection*{Insertion of alphabetic Patrica Tree in Scheme/Lisp}
in scheme/lisp...

\lstset{language=lisp}
\begin{lstlisting}
...
\end{lstlisting}

% ================================================================
%                 Look up in Alphabetic Patrica Tree
% ================================================================
\subsection{Look up in aplhabetic Patricia Tree}
Insertion...

Pseudocode...

\subsubsection*{Look up in alphabetic Patrica Tree in Haskell}
in haskell...

\lstset{language=Haskell}
\begin{lstlisting}
...
\end{lstlisting}

\subsubsection*{Look up in alphabetic Patrica Tree in C++}
in C++...

\lstset{language=C++}
\begin{lstlisting}
...
\end{lstlisting}


\subsubsection*{Look up in alphabetic Patricia Tree in Python}
in python...

\lstset{language=Python}
\begin{lstlisting}
...
\end{lstlisting}

\subsubsection*{Look up in alphabetic Patricia Tree in Scheme/Lisp}
in scheme/lisp...

\lstset{language=lisp}
\begin{lstlisting}
...
\end{lstlisting}

% ================================================================
%                 Trie and Patrica used in Industry
% ================================================================
\section{Trie and Patricia used in Industry}
...

% ================================================================
%                 Suffix Trie
% ================================================================
\section{Suffix Trie}
...

\subsection{construction of suffix trie}
...

\section{Suffix Tree}
...

\subsection{construction algorithms of suffix tree}

\section{Suffix tree used in Industry}

% ================================================================
%                 Appendix
% ================================================================
\section{Appendix} \label{appendix}
%\appendix
All programs provided along with this article. They are free for downloading.
\begin{itemize}
\item IntTrie.hs, Haskell version of little-endian integer Trie, with test cases. I compiled
and tested it with GHC 6.10.4.
\item inttrie.cpp,
\item inttrie.py, Python version of little-endian integer Trie, with test cases. Tested
with Python 2.5.1
\item inttrie.scm,
\item IntPatricia.hs, integer Patricia tree implemented in
Haskell. Tested with GCH 6.10.4. 
\item intpatricia.cpp,
\item intpatricia.py, integer Patricia tree implemented in
Python. Tested with Python 2.5.1
\item intpatricia.scm
\item trie.c, Alphabetic Trie only for lowercase English language,
implemented in ANSI C. Tested with GNU GCC 3.4.4
\item Trie.hs, Alphabetic Trie, implemented in Haskell. Tested with
GHC 6.10.4.
\item trie.cpp,
\item trie.py, Alphabetic Trie, implemented in Python. Tested with
Python 2.5.1.
\item trie.scm,
\item Patricia.hs,
\item patricia.cpp,
\item patricia.py,
\item patricia.scm,
\item xxx.scm, Scheme version of xxxx and test cases. Tested
with MIT/Scheme 14.9
\end{itemize}

Besides them, I use graphviz to draw most of the figures in this post. In order to
translate the Trie, Patrica and Suffix Tree output to dot language scripts. I wrote a python program.
it can be used like this.

\begin{verbatim}
trie2dot.py -o foo.dot -t patricia "1:x, 4:y, 5:z"
trie2dot.py -o foo.dot -t trie "001:one, 101:five, 100:four"
\end{verbatim}

This helper scripts can also be downloaded with this article.

download position: http://sites.google.com/site/algoxy/trie/trie.zip

\begin{thebibliography}{99}

\bibitem{CLRS}
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. 
``Introduction to Algorithms, Second Edition''. ISBN:0262032937. The MIT Press. 2001

\bibitem{okasaki-int-map}
Chris Okasaki and Andrew Gill. ``Fast Mergeable Integer
Maps''. Workshop on ML, September 1998, pages 77-86, http://www.cse.ogi.edu/~andy/pub/finite.htm

\bibitem{patricia-morrison}
D.R. Morrison, ``PATRICIA -- Practical Algorithm To Retrieve  Information Coded In Alphanumeric", Journal of the ACM, 15(4), October 1968, pages 514-534.

\bibitem{wiki-suffix-tree}
Suffix Tree, Wikipedia. http://en.wikipedia.org/wiki/Suffix\_tree

\bibitem{wiki-trie}
Trie, Wikipedia. http://en.wikipedia.org/wiki/Trie

\end{thebibliography}

\ifx\wholebook\relax\else
\end{document}
\fi
