\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
%\input{../../../common.tex}
\input{../../../common-en.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Comparison of imperative and functional implementation of red black tree}

\author{Liu~Xinyu
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
%  Tel:   +86-1305-196-8666 \newline}
  }

\markboth{Red black tree}
{imperative and functional implementation}

\maketitle

\ifx\wholebook\relax
\chapter{Comparision of imperative and functional implementation of red black tree}

\section{abstract}
\else
\begin{abstract}
\fi
This post provides the functional and imperative implementation of red black tree. There are
multiple programming languages used, including, C++(on going), Haskell, python and scheme/lisp(on going).
C++ and python are mostly used to show the imperative implementation, while Haskell and Scheme are
used for functional purpose.

It's hard to say if imperative is better than functional and vice versa. Chris Okasaki gave a very expressive implementation for insertion\cite{okasaki}. While the imperative one has better performance.

There may be mistakes in the post, please feel free to point out.

This post is generated by \LaTeXe, and provided with GNU FDL(GNU Free Documentation License).
Please refer to http://www.gnu.org/copyleft/fdl.html for detail.

\ifx\wholebook\relax\else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} Red Black tree, imperative, functional, C++, Haskell, Python, Scheme/Lisp

%{\bfseries Corresponding Author:} Liu Xinyu

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

Red black tree is one type of the balanced binary search trees. Binary search tree as described
in my previous post\cite{bst-lxy} suffers from below case.

If you try to insert a sequence of number 1, 2, 3, ..., n to a binary search tree. you will get a tree like this.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/unbalanced.ps}
        \caption{unbalanced tree} \label{fig:unbalanced-tree}
       \end{center}
\end{figure}

This is a extreme unbalanced binary search tree. In average case, we benifit from binary search tree by $O(log n)$ search time. But in this extream case, the search time is only $O(n)$. It's no better than a normal link-list.

In order to avoid such case, we can shuffle the input sequence by randomized algorithm, such as described in Section 12.4 in CLRS\cite{CLRS}. However, this is not always work, for example the input is fed from user interactively, and the tree need to be built after each input.

Red black tree is one of the most popular and widely used approach to sovle this unbalancing problem. It's a type of self-balancing binary search tree\cite{wiki}. Red black tree is one of the equivalent form of 2-3-4 tree. That is to say, for any 2-3-4 tree, there are at least one red black tree has the same data order. By using color changing and rotation, red black tree provides a very simple and straightforward way to keep the tree balancing.

We call a binary search tree red black tree if it satisfies the following 5 properites\cite{CLRS}.

\begin{enumerate}
\item Every node is either red or black.
\item The root is black.
\item Every leaf (NIL) is black.
\item If a node is red, then both its children are black.
\item For each node, all paths from the node to descendant leaves contain the same number of black nodes.
\end{enumerate}

Why this 5 properties can ensure the red black tree is well balanced? Because they have a key charicteristic, the longest path from root to a leaf can't be as 2 times longer than the shortest path.

Please note the 4th property, which means there won't be 2 adjacent red nodes. so the shortest path only contains black nodes, any paths longer than the shortest one has interval red nodes. According to property 5, all paths have the same number of black nodes, this finally ensure there won't be any path is 2 times longer than others\cite{wiki}.

All read only operations such as search, min/max are as same as in binary search tree. While only the insertion and deletion are special.

This article provides implementation of insertion and deletion for red black tree in C++(on going), Haskell, Python, and Scheme/Lisp(on going) languages. Most imperative algorithms confirms to CLRS\cite{CLRS}. While for functional implementation, thanks for Chris Okasaki very much. He found a very expressive way\cite{okasaki} of insertion.

All completed source code can be downloaded in appendix \ref{appendix}, please refer to appendix for detailed information about build and run.

% ================================================================
% Definition
% ================================================================
\section{Definition}
\label{definition}

The definition of red black tree is very similar to the binary search tree.
In imperative implementation, it has one more color member to denote if the node is red or black. The parent member is critical in red black tree, because
it need back-track in insertion and deletion to keep the balancing properties.
I added some member functions to the definition to help simplify the operations
in node connection change.

\subsubsection*{Python definition, imperative}
\lstset{language=python}
\begin{lstlisting}
RED = 0
BLACK = 1

class Node:
    def __init__(self, key, color = RED):
        self.key = key;
        self.color = color;
        self.left = self.right = self.parent = None

    def set_left(self, x):
        self.left = x
        if x != None:
            x.parent = self

    def set_right(self, x):
        self.right = x
        if x != None:
            x.parent = self

    def set_children(self, x, y):
        self.set_left(x)
        self.set_right(y)

    #parent<->self ==> parent<->y
    def replace_by(self, y):    
        if self.parent is None:
            if y!= None: y.parent = None
        elif self.parent.left == self:
            self.parent.set_left(y)
        else:
            self.parent.set_right(y)
        self.parent = None

    def sibling(self):
        if self.parent.left == self:
            return self.parent.right
        else:
            return self.parent.left

    def uncle(self):
        return self.parent.sibling()

    def grandparent(self):
        return self.parent.parent
\end{lstlisting}

Note that, in case we set a node y as a child of node y, we don't only
make the left or right child point to y, but also make y's parent point to x.
So this is bi-directional assignment. The same thing happens in replace\_by()
member function, when we try to replace a node x with another node y, we
mean make y connect to x's parent as a child. I also provide sibling, uncle,
and grandparent members, those meanings are straightforward.

\subsubsection*{Haskell definition, recursive}
Instead of provide 2 different constructors for red and black node, a color
data is passed to node contructor. It makes the definition very similar to the 
one in binary search tree.

\lstset{language=haskell}
\begin{lstlisting}
data Color = R | B deriving (Show, Eq) 
data RBTree a = Empty
              | Node Color (RBTree a) a (RBTree a)
\end{lstlisting}

% ================================================================
% Rotation and helper functions
% ================================================================
\subsection{Rotation and helper functions} \label{helper-fun}

Rotation is one of the key operations to in red black tree. we know that
different binary search tree can have the data in same order by in-order walk.
Rotation can keep the data order while changing the tree. 

In functional implementation, we can use pattern matching and data construction.
So there is no need to provide rotation functions at all (see below sections).
While the imperative rotation can be simplified a lot by using the member functions we defined.

\subsubsection*{Python rotation functions}
\lstset{language=Python}
\begin{lstlisting}
# (a x (b y c)) ==> ((a x b) y c)
def left_rotate(t, x):
    (parent, y) = (x.parent, x.right)
    (a, b, c)   = (x.left, y.left, y.right)
    x.replace_by(y)
    x.set_children(a, b)
    y.set_children(x, c)
    if parent is None:
        t=y
    return t

# (a x (b y c)) <== ((a x b) y c)
def right_rotate(t, y):
    (parent, x) = (y.parent, y.left)
    (a, b, c)   = (x.left, x.right, y.right)
    y.replace_by(x)
    y.set_children(b, c)
    x.set_children(a, y)
    if parent is None:
        t = x
    return t
\end{lstlisting}

I also provide a function for batch color setting. It accept two lists,
one is list of nodes, the other is list of colors. It helps to set color
to each node in order.

\subsubsection*{Python helper function}
\lstset{language=Python}
\begin{lstlisting}
def set_color(nodes, colors):
    for (n, c) in zip(nodes, colors):
        n.color = c
\end{lstlisting}

% ================================================================
%                 Insertion
% ================================================================
\section{Insertion}

Insertion can violate the red black tree properties, so we need transform
the tree after insertion.

We can use the same insert function as defined in binary search tree, and 
then do some fix the resume the red black properties. One good practice is 
to always insert red node. as far as the new inserted node isn't the root.
We can keep all properties except number 4. It may bring two adjacent red
nodes.

Functional and imperative implementation have different fixing ways. One
is uniformed but has some overhead, the other is a bit complex but has 
higher performance.

\subsubsection*{Haskell red black insertion, functional}
As described by Chris Okasaki, there are total 4 cases which violate property 4.
All of them has 2 adjacent red nodes. However, they have a uniformed form
after fixing\cite{okasaki}. 

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/insert-fix.eps}
        \caption{4 cases for balancing a red black tree after insertion} \label{fig:insert-fix}
       \end{center}
\end{figure}

Note that this transformation will move the redness one level up. So this is a bottom-up recursive fixing, the last step will make the root node red. According
to property 2, root is always black. So we need final fixing to revert the root
color to black. All these can be implemented as the following Haskell code.

\lstset{language=Haskell}
\begin{lstlisting}
insert::(Ord a)=>RBTree a -> a -> RBTree a
insert t x = makeBlack(ins t x) where  --[1]
    ins Empty x = Node R Empty x Empty --[2]
    ins (Node color l k r) x 
        | x < k     = balance color (ins l x) k r
        | otherwise = balance color l k (ins r x) --[3]
    makeBlack(Node _ l k r) = Node B l k r

balance::Color -> RBTree a -> a -> RBTree a -> RBTree a
balance B (Node R (Node R a x b) y c) z d = 
                Node R (Node B a x b) y (Node B c z d)
balance B (Node R a x (Node R b y c)) z d = 
                Node R (Node B a x b) y (Node B c z d)
balance B a x (Node R b y (Node R c z d)) = 
                Node R (Node B a x b) y (Node B c z d)
balance B a x (Node R (Node R b y c) z d) = 
                Node R (Node B a x b) y (Node B c z d)
balance color l k r = Node color l k r
\end{lstlisting}

Here are some explaination. For [1], the program always set the root
color as black, this is because of property 2; For [2], we always insert
a red leaf to satisify all properties except number 4; For [3], I assume, 
there shouldn't be different nodes with equal key value. But it is not always
applicable. for example in chapter 14, ``Augmenting Data Structures'' in CLRS\cite{CLRS}, it enables such case. The use of otherwise allows user to do this.

In order to test this program, we can write something like below.

\begin{lstlisting}
-- helper function to build a red black tree from a list

listToRBTree::(Ord a)=>[a] -> RBTree a
listToRBTree lst = foldl insert Empty lst

-- Helper function for pretty printing
instance Show a => Show (RBTree a) where
    show Empty = "."
    show (Node c l k r) = "(" ++ show l ++ " " ++ 
                          show k ++ ":" ++ show c ++ " " ++ 
                          show r ++ ")"

main = do
  putStrLn (show (listToRBTree [11, 2, 14, 1, 7, 15, 5, 8, 4]))
  putStrLn (show (listToRBTree [1, 2, 3, 4, 5, 6, 7, 8]))
\end{lstlisting}

This program will output:
\begin{verbatim}
(((. 1:B .) 2:B ((. 4:R .) 5:B .)) 7:B (((. 8:R .) 11:B .) 14:B (. 15:B .)))
(((. 1:B .) 2:B (. 3:B .)) 4:B ((. 5:B .) 6:B (. 7:B (. 8:R .))))
\end{verbatim}

They are trees as shown below.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/insert-haskell.ps}
        \caption{Haskell insert results} 
       \end{center}
\end{figure}

\subsubsection*{Python red black tree insertion, imperative}

The python version imperative implementation uses the method described in CLRS.

\lstset{language=Python}
\begin{lstlisting}
def rb_insert(t, key): #returns the new root
    root = t
    x = Node(key)
    parent = None
    while(t):
        parent = t
        if(key < t.key):
            t = t.left
        else:
            t = t.right
    if parent is None: #tree is empty
        root = x
    elif key < parent.key:
        parent.set_left(x)
    else:
        parent.set_right(x)
    return rb_insert_fix(root, x)
\end{lstlisting}

Compare the above source code and the one in binary search tree\cite{bst-lxy}. The only difference are we simplfied the program by using set\_left()/set\_right() member functions, and there is a rb\_insert\_fix() function call to fix the red node violation.

There are 3 cases described in CLRS, and if we take the left-right symmetric into consideration. there are total 6 cases. Among them two cases can be merged together, because they are all have uncle node in red color, we can toggle the parent color and uncle color to black and set grand parent color to red. After this merge the 5 cases fixing verson can be implemented as the following.

\begin{lstlisting}
# Fix the red->red violation
def rb_insert_fix(t, x):
    while(x.parent and x.parent.color==RED):
        if x.uncle().color == RED:
            #case 1: ((a:R x:R b) y:B c:R) ==> ((a:R x:B b) y:R c:B)
            set_color([x.parent, x.grandparent(), x.uncle()],
                      [BLACK, RED, BLACK])
            x = x.grandparent()
        else:
            if x.parent == x.grandparent().left:
                if x == x.parent.right:
                    #case 2: ((a x:R b:R) y:B c) ==> case 3
                    x = x.parent
                    t=left_rotate(t, x)
                # case 3: ((a:R x:R b) y:B c) ==> (a:R x:B (b y:R c))
                set_color([x.parent, x.grandparent()], [BLACK, RED])
                t=right_rotate(t, x.grandparent())
            else:
                if x == x.parent.left:
                    #case 2': (a x:B (b:R y:R c)) ==> case 3'
                    x = x.parent
                    t = right_rotate(t, x)
                # case 3': (a x:B (b y:R c:R)) ==> ((a x:R b) y:B c:R)
                set_color([x.parent, x.grandparent()], [BLACK, RED])
                t=left_rotate(t, x.grandparent())
    t.color = BLACK
    return t
\end{lstlisting}

To test the insertion function. We use some similar helper functions and test functions defined in binary search tree\cite{bst-lxy}.

\begin{lstlisting}
def rbtree_clone(t):
    n = None
    if t != None:
        n = Node(t.key, t.color)
        n.set_children(rbtree_clone(t.left), rbtree_clone(t.right))
    return n

def rbtree_to_str(t):
    if t is None:
        return "."
    else:
        color = {RED:"R", BLACK:"B"}
        return "("+rbtree_to_str(t.left)+ " " + str(t.key) +":"+
               color[t.color]+" " + rbtree_to_str(t.right)+")"

def list_to_tree(l):
    tree = None
    for x in l:
        tree = rb_insert(tree, x)
    return tree

class Test:
    def __init__(self):
        self.t2=Node(11, BLACK) # as figure 13.4 in CLRS
        self.t2.set_children(Node(2), Node(14, BLACK))
        self.t2.left.set_children(Node(1, BLACK), Node(7, BLACK))
        self.t2.right.set_right(Node(15))
        self.t2.left.right.set_children(Node(5), Node(8))
        print "t2, CLRS fig 13.4:\n", rbtree_to_str(self.t2)

    def run(self):
        self.test_insert()

    def test_insert(self):
        t = rbtree_clone(self.t2)
        t = rb_insert(t, 4)
        print "t2: after insert 4\n", rbtree_to_str(t)
        t = list_to_tree([5, 2, 7, 1, 4, 6, 9, 3, 8])
        print "list->tree, create t1 by insert\n", rbtree_to_str(t)
\end{lstlisting}

Here we use the example tree present in CLRS as in figure \ref{fig:rb-insert-clrs}.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/rb-insert-clrs.eps}
        \caption{insertion and fixing} \label{fig:rb-insert-clrs}
       \end{center}
\end{figure}

The program will output 2 trees in console.

\begin{verbatim}
t2, CLRS fig 13.4:
(((. 1:B .) 2:R ((. 5:R .) 7:B (. 8:R .))) 11:B (. 14:B (. 15:R .)))
t2: after insert 4
(((. 1:B .) 2:R ((. 4:R .) 5:B .)) 7:B ((. 8:B .) 11:R (. 14:B (. 15:R .))))
list->tree, create t1 by insert
(((. 1:B .) 2:R ((. 3:R .) 4:B .)) 5:B ((. 6:B .) 7:R ((. 8:R .) 9:B .)))
\end{verbatim}

After insert element 4 into the first tree the result will be like in figure \ref{fig:rb-insert-clrs} (d), the second test case shows a tree which is created from a list as shown in figure \ref{fig:python-insert}.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/python-insert.ps}
        \caption{insert from a list} \label{fig:python-insert}
       \end{center}
\end{figure}

If we compare the results from the functional implementaion and from the imperative one, we can 
find there is difference. Even if we insert the same element into the same red black tree, the
results varies. This is because the functional way focus on expressive of the program, and there 
is a bit performance overhead in it. Okasaki discussed about the difference in his paper\cite{okasaki}.
And he show the result that the computation time is still $O(log n)$. It is possible to use a 
similar way to the imperactive implementation. And that's a kind of fine tune in the 'balance()'
function. But it will loss the expressive merit.

% ================================================================
%                 Deletion
% ================================================================

\section{Deletion}

Deletion is more complex than insertion. Both funtional and imperative implementaion 
need face more cases to fix. Deletion may also violate the red black tree properties,
so we need fix it after the normal insertion as decribed in binary search tree\cite{bst-lxy}.

The deletion wasn't been discussed in Okasaki's paper\cite{okasaki}. I refered to a
handout of CLRS course\cite{lyn}. The problem only happens if you try to delete a black node.
Because it will violate the property 4 of red black tree, which means the number of black
node in the path may decresed so that it is not uniformed black-height any more.

CLRS proposed a 'doubly-black' approach to resume property 4. However in the real fixing
program, there is no explicit expression of the doubly-black node. I decided to use
this concept in this post

\subsubsection*{Haskell red black tree deletion, functional}

In order to express the 'doubly-node', I added a defition of it both in color and in node.

\lstset{language=Haskell}
\begin{lstlisting}
data Color = R | B | BB deriving (Show, Eq) -- BB: doubly black for deletion
data RBTree a = Empty
              | Node Color (RBTree a) a (RBTree a)
              | BBEmpty -- doubly black empty
\end{lstlisting}

Differenet from the basic deletion of binary search tree. I used the one like below:
\begin{itemize}
\item If the node to be deleted has an empty left child, use the right child to replace it;
\item If the right child is empty, use the left child to replace it;
\item If both children are not empty, use the minimum one in the right child to replace it, and
slice the minimum one out.
\end{itemize}

After it, if the node to be sliced out is black, we need fix the tree to keep the red black
properties.

\begin{lstlisting}
delete::(Ord a)=>RBTree a -> a -> RBTree a
delete t x = blackenRoot(del t x) where
    del Empty _ = Empty
    del (Node color l k r) x 
        | x < k = fixDB color (del l x) k r --[1]
        | x > k = fixDB color l k (del r x)
        -- x == k, delete this node
        | isEmpty l = if color==B then makeBlack r else r --[2]
        | isEmpty r = if color==B then makeBlack l else l
        | otherwise = fixDB color l k' (del r k') where k'= key (mint r)
    blackenRoot (Node _ l k r) = Node B l k r
    blackenRoot _ = Empty

makeBlack::RBTree a -> RBTree a
makeBlack (Node B l k r) = Node BB l k r -- doubly black
makeBlack (Node _ l k r) = Node B l k r
makeBlack Empty = BBEmpty
makeBlack t = t
\end{lstlisting}

Let me explain it a bit. The mint function as shown in \cite{bst-lxy} can help to find the 
minimum of a tree. While the isEmpty helper function can test if a node is empty. Let's review 
them here:

\begin{lstlisting}
-- helper functions
key::RBTree a -> a
key (Node _ _ k _) = k

left::RBTree a -> RBTree a
left (Node _ l _ _) = l
left _ = Empty

isEmpty::RBTree a -> Bool
isEmpty Empty = True
isEmpty _ = False

mint::RBTree a -> RBTree a
mint t = if isEmpty (left t) then t else mint (left t)
\end{lstlisting}

The blackenRoot function is used to keep the property 2, that the root of a red black tree
must be black. In line [2], if the color of the sliced root is black, I'll make the root 
of the subtree which will replace the deleted one be black. This can help to keep the property
4, so the black-height will not decreased.

For makeBlack() function, If the root is red, it will change it to black; if the root node is 
already black, it will mark it as 'doubly-black', and if it is empty, it will mark it as a 
doubly-black empty node by BBEmpty.

Next, we must use a function to fix the 'doubly-black' by rotation and color changes.

\begin{lstlisting}
-- Core function for delete, to solve the uniform black height violation.
-- refer to CLRS
fixDB::Color -> RBTree a -> a -> RBTree a -> RBTree a
fixDB color BBEmpty k Empty = Node BB Empty k Empty
fixDB color BBEmpty k r = Node color Empty k r
fixDB color Empty k BBEmpty = Node BB Empty k Empty
fixDB color l k BBEmpty = Node color l k Empty
-- the sibling is black, and it has one red child
fixDB color a@(Node BB _ _ _) x (Node B (Node R b y c) z d) = 
      Node color (Node B (makeBlack a) x b) y (Node B c z d)
fixDB color a@(Node BB _ _ _) x (Node B b y (Node R c z d)) = 
      Node color (Node B (makeBlack a) x b) y (Node B c z d)
fixDB color (Node B a x (Node R b y c)) z d@(Node BB _ _ _) = 
      Node color (Node B a x b) y (Node B c z (makeBlack d))
fixDB color (Node B (Node R a x b) y c) z d@(Node BB _ _ _) = 
      Node color (Node B a x b) y (Node B c z (makeBlack d))
-- the sibling and its 2 children are all black, propagate the blackness up
fixDB color a@(Node BB _ _ _) x (Node B b@(Node B _ _ _) y c@(Node B _ _ _))
    = makeBlack (Node color (makeBlack a) x (Node R b y c))
fixDB color (Node B a@(Node B _ _ _) x b@(Node B _ _ _)) y c@(Node BB _ _ _)
    = makeBlack (Node color (Node R a x b) y (makeBlack c))
-- the sibling is red
fixDB B a@(Node BB _ _ _) x (Node R b y c) = fixDB B (fixDB R a x b) y c
fixDB B (Node R a x b) y c@(Node BB _ _ _) = fixDB B a x (fixDB R b y c)
-- otherwise
fixDB color l k r = Node color l k r
\end{lstlisting}



\begin{verbatim}
test del 17:    Node (Node (Node (Node Empty 2 Empty) 3 (Node Empty 4 
Empty)) 6 (Node Empty 7 (Node (Node Empty 9 Empty) 13 Empty))) 15 
(Node Empty 18 (Node Empty 20 Empty))
test del 7:     Node (Node (Node (Node Empty 2 Empty) 3 (Node Empty 4 
Empty)) 6 (Node (Node Empty 9 Empty) 13 Empty)) 15 (Node (Node Empty 
17 Empty) 18 (Node Empty 20 Empty))
test del 6:     Node (Node (Node (Node Empty 2 Empty) 3 (Node Empty 4 
Empty)) 7 (Node (Node Empty 9 Empty) 13 Empty)) 15 (Node (Node Empty 
17 Empty) 18 (Node Empty 20 Empty))
test del 15:    Node (Node (Node (Node Empty 2 Empty) 3 (Node Empty 4 
Empty)) 6 (Node Empty 7 (Node (Node Empty 9 Empty) 13 Empty))) 17 
(Node Empty 18 (Node Empty 20 Empty))
test del non-exist:     Node (Node (Node (Node Empty 2 Empty) 3 (Node 
Empty 4 Empty)) 6 (Node Empty 7 (Node (Node Empty 9 Empty) 13 Empty))) 
15 (Node (Node Empty 17 Empty) 18 (Node Empty 20 Empty))
\end{verbatim}

\subsubsection*{C++ deletion, imperative}

C++ version is more complex because it need set the parent properly.
While we can pass the pointer to the node which will be deleted to the function,
so that search is no more needed. The function will return the root
of the result tree.

\lstset{language=C++}
\begin{lstlisting}
template<class T>
node<T>* del(node<T>* tree, node<T>* x){
  if(!x)
    return tree;

  node<T>* root(tree);
  node<T>* old_x(x);
  node<T>* parent(x->parent);

  if(x->left == 0)
    x = x->right;
  else if(x->right == 0)
    x = x->left;
  else{
    node<T>* y=min(x->right);
    x->value = y->value;
    if(y->parent != x)
      y->parent->left = y->right;
    else
      x->right = y->right;

    remove_node(y);
    return root;
  }

  if(x)
    x->parent = parent;

  if(!parent)
    root = x; //remove node of a tree
  else
    if(parent->left == old_x)
      parent->left = x;
    else
      parent->right = x;

  remove_node(old_x);
  return root;
}
\end{lstlisting}

If the node to be deleted is empty, the function simply returns the original tree.
In other cases, it will first record the root of the tree, create a copy pointer
to x, and to its parent.

If either of the children is empty, the program just splice x out. If it has two
none-empty children, we first located the minimum of right child, replace the key
of x to y's, then splice y out. Note that the helper function remove\_node() is
used.

Finally we reset the parent. If the parent pointer we copied before is empty, it
means that we are deleting the root node, so we need return the new root. After
the parent is set properly, we finally remove the old x from memory.

The test cases and result are shows as below.

\begin{lstlisting}
void test_del_n(int n){
  node<int>* empty(0);
  node<int>* t1=clone_tree(tree);
  t1=del(t1, search(t1, n));
  std::cout<<"del "<<n<<":\n"<<tree_to_str(t1)<<"\n";
  assert_("search after del: ", search(t1, n), empty);
  delete t1;
}

test_del_n(17);
test_del_n(7);
test_del_n(6);
test_del_n(15);
test_del_n(1); //try to del a non-exist val
\end{lstlisting}

Because the deletion function in C++ inplace change the tree, so I cloned the test 
tree for each testing. The clone\_tree() function is defined in section \ref{helper-fun}.

The result of these test case is as below.
\begin{verbatim}
del 17:
((((empty), 2, (empty)), 3, ((empty), 4, (empty))), 6, ((empty), 7, 
(((empty), 9, (empty)), 13, (empty)))), 15, ((empty), 18, ((empty), 
20, (empty)))
search after del: 0 OK.
del 7:
((((empty), 2, (empty)), 3, ((empty), 4, (empty))), 6, (((empty), 9, 
(empty)), 13, (empty))), 15, (((empty), 17, (empty)), 18, ((empty), 
20, (empty)))
search after del: 0 OK.
del 6:
((((empty), 2, (empty)), 3, ((empty), 4, (empty))), 7, (((empty), 9, 
(empty)), 13, (empty))), 15, (((empty), 17, (empty)), 18, ((empty), 
20, (empty)))
search after del: 0 OK.
del 15:
((((empty), 2, (empty)), 3, ((empty), 4, (empty))), 6, ((empty), 7, 
(((empty), 9, (empty)), 13, (empty)))), 17, ((empty), 18, ((empty), 
20, (empty)))
search after del: 0 OK.
del 1:
((((empty), 2, (empty)), 3, ((empty), 4, (empty))), 6, ((empty), 7, 
(((empty), 9, (empty)), 13, (empty)))), 15, (((empty), 17, (empty)), 
18, ((empty), 20, (empty)))
search after del: 0 OK.
\end{verbatim}

\subsubsection*{Python deletion, imperative}
Python version is very similar to C++, but it needn't free memory because
of GC support.

\lstset{language=Python}
\begin{lstlisting}
def tree_delete(t, x):
    if (x is None): return t
    [root, old_x, parent] = [t, x, x.parent]
    if (x.left is None):
        x = x.right
    elif (x.right is None):
        x = x.left
    else:
        y = tree_min(x.right)
        x.key = y.key
        if (y.parent != x):
            y.parent.left = y.right
        else:
            x.right = y.right
        remove_node(y)
        return root
    if (x != None):
        x.parent = parent
    if (parent != None):
        root = x
    else:
        if(parent.left == old_x): parent.left = x
        else: parent.right = x
    remove_node(old_x)
    return root
\end{lstlisting}

This function can be tested as below:

\begin{lstlisting}
def __test_del_n(self, n):
    t = clone_tree(self.tree)
    t = tree_delete(t, tree_search(t, n))
    print "del ", n, ": ", tree_to_str(t)
    self.__assert("search after del: ", tree_search(t, n), None)

def test_del(self):
    self.__test_del_n(17)
    self.__test_del_n(7)
    self.__test_del_n(6)
    self.__test_del_n(15)
    self.__test_del_n(1) #del a non-exist value
\end{lstlisting}

The test result is as same as C++.

\subsubsection*{Scheme/Lisp deletion, recursive}

\lstset{language=lisp}
\begin{lstlisting}
(define (tree-delete tree v)
  (cond ((null? tree) tree)
	((< v (key tree)) (make-tree (tree-delete (left tree) v)
				     (key tree)
				     (right tree)))
	((> v (key tree)) (make-tree (left tree)
				     (key tree)
				     (tree-delete (right tree) v)))
	((null? (left tree)) (right tree))
	((null? (right tree)) (left tree))
	(else (let ((newkey (key (tree-min (right tree)))))
		(make-tree (left tree)
			   newkey
			   (tree-delete (right tree) newkey))))))
\end{lstlisting}

Test cases are like the following.

\begin{lstlisting}
(define (test-del)
  (display (tree-delete t1 17)) (newline)
  (display (tree-delete t1 7)) (newline)
  (display (tree-delete t1 6)) (newline)
  (display (tree-delete t1 15)) (newline)
  (display (tree-delete t1 5)))
\end{lstlisting}

It will output the result in emulator as below.

\begin{verbatim}
(test-del)
((((() 2 ()) 3 (() 4 ())) 6 (() 7 ((() 9 ()) 13 ()))) 15 (() 18 (() 20 ())))
((((() 2 ()) 3 (() 4 ())) 6 ((() 9 ()) 13 ())) 15 ((() 17 ()) 18 (() 20 ())))
((((() 2 ()) 3 (() 4 ())) 7 ((() 9 ()) 13 ())) 15 ((() 17 ()) 18 (() 20 ())))
((((() 2 ()) 3 (() 4 ())) 6 (() 7 ((() 9 ()) 13 ()))) 17 (() 18 (() 20 ())))
((((() 2 ()) 3 (() 4 ())) 6 (() 7 ((() 9 ()) 13 ()))) 15 ((() 17 ()) 18 (() 
20 ())))
;Unspecified return value
\end{verbatim}

\section{Randomly built binary search tree}
In CRLS\cite{CLRS}, it described about randomly built binary search tree.
Ramdomly building can help to avoid (decrease the possibility) unbalanced
binary trees.

This can be easily implemented in imperative way, such as by C++ and Python.
Before call build\_tree() or list\_to\_tree() function, we can call random
process, to shuffle the list or collection. The same approach can also be
used in Scheme/Lisp. While for pure functional programming language, such as
Haskell, randomization violate the property of pure function. We have to
use alternative approach such as Monad.

There are more solution to ensure the tree is balanced, such as red black tree,
please refer to other posts for detailed implementation.

\section{Appendix} \label{appendix}
%\appendix
All programs are provided along with this article. They are free for downloading.
\begin{itemize}
\item bstree.cpp, C++ version of binary seach tree, including all test cases. I 
compiled and tested it with GUN G++ 3.4.4.
\item BSTree.hs, Haskell version of binary search tree, with test cases. I compiled
and tested it with GHC 6.10.4.
\item bstree.py, Python version of the binary search tree, with test cases. Tested
with Python 2.5.1
\item bstree.scm, Scheme version of the binary search tree and test cases. Tested
with MIT/Scheme 14.9
\end{itemize}
download position: http://sites.google.com/site/algoxy/bstree/bstree.zip

\begin{thebibliography}{99}

\bibitem{CLRS}
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. 
``Introduction to Algorithms, Second Edition''. ISBN:0262032937. The MIT Press. 2001

\bibitem{okasaki}
Chris Okasaki. ``FUNCTIONAL PEARLS Red-Black Trees in a Functional Setting''. J. Functional Programming. 1998

\bibitem{bst-lxy}
Liu Xinyu. ``Comparison of imperative and functional implementation of binary search tree''. http://sites.google.com/site/algoxy/bstree

\bibitem{wiki}
Wikipedia. ``Red-black tree''. http://en.wikipedia.org/wiki/Red-black\_tree

\bibitem{lyn}
Lyn Turbak. ``Red-Black Trees''. cs.wellesley.edu/~cs231/fall01/red-black.pdf Nov. 2, 2001.

\bibitem{hj-stl}
Hou Jie. ``The annotated STL sources (using SGI STL)''. ISBN:7-5609-2699-1 http://press.hust.edu.cn. 2002.

\end{thebibliography}

\ifx\wholebook\relax\else
\end{document}
\fi
