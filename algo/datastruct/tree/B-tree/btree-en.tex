\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
%\input{../../../common.tex}
\input{../../../common-en.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{B-Trees with Functional and imperative implementation}

\author{Liu~Xinyu
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
%  Tel:   +86-1305-196-8666 \newline}
  }

\markboth{B-Trees}{Imperative and Functional}

\maketitle

\ifx\wholebook\relax
\chapter{B-Trees with Functional and imperative implementation}

\section{abstract}
\else
\begin{abstract}
\fi
B-Trees are introduced by CLRS book as one of the advanced data
structure. It is important to the modern file systems, some of them
are implemented based on B+ tree, which is extended from B-tree.
It is also widely used in many database system. This post provides
some implementation of B-trees both in imperative way as described in
CLRS books and in functional way with a kind of modify-and-fix
approach. There are multiple programming languages used, including
C++, Haskell, Python and Scheme/Lisp.

There may be mistakes in the post, please feel free to point out.

This post is generated by \LaTeXe, and provided with GNU FDL(GNU Free Documentation License).
Please refer to http://www.gnu.org/copyleft/fdl.html for detail.

\ifx\wholebook\relax \else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} B-Trees

%{\bfseries Corresponding Author:} Liu Xinyu

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

In CLRS book, B-tree is introduced with the the problem of how to accessting a
large block of data on magnetic discks or secondary storage devices\cite{CLRS}.
B-tree is commonly used in databases and filesystems.

It is also helpful to understand B-tree as a generalization of balanced binary
search tree\cite{wiki-b-tree}.

Refer to the Figure \ref{fig:btree-example}, It is easy to found the difference
and similarity of B-tree regarding to binary search tree.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/btree-example.ps}
        \caption{An example of B-Tree} \label{fig:btree-example}
       \end{center}
\end{figure}

Let's review the definition of binary search tree.

.....

If we extend this definition to allow multiple keys and children, we get the 
below definition.

Finally, if we added some constraints to make the tree balanced, we get the
definition of B-tree.

... 

In this post, I'll first introduce How to generate B-trees by insertion
algorithm. Two different methods will be explained. One method is discussed in CLRS
book, the other is a kind of modify-fix approach which quite similar to the
algorithm Okasaki used in red-black tree\cite{okasaki-rbtree}. This method
is also discussed in wikipedia\cite{wiki-b-tree}. After that, how to delete
element from B-tree is explained. As the last part, algorithm for searching 
in B-tree is also provided.

This article provides example implementation in C, C++, Haskell, Python, and 
Scheme/Lisp languages. 

All source code can be downloaded in appendix \ref{appendix}, please 
refer to appendix for detailed information about build and run.

% ================================================================
%                 Insertion
% ================================================================
\section{Insertion}
\label{btree-insertion}


%=========================================================================
%       Split before insertion
%=========================================================================
\subsection{Split before insert method}
\label{split before insertion}


% ================================================================
%               Insert and fix method 
% ================================================================
\subsection{Insert then fix method}

% ================================================================
%               Deletion
% ================================================================
\section{Deletion} 

% ================================================================
%               Merge before delete method
% ================================================================
\subsection{Merge before delete method} 

\subsubsection{Merge before delete algorithm implemented imperatively}


% ================================================================
%               Delete and fix method
% ================================================================

\subsection{Delete and fix method}

\subsection{Delete and fix algorithm implemented functionaly}

% ================================================================
%               Searching
% ================================================================
\section{Searching} 

\subsection{Imperative search algorithm}

\subsection{Functional search algorithm}

% ================================================================
%                 Short summary
% ================================================================
\section{Notes and short summary}


% ================================================================
%                 Appendix
% ================================================================
\section{Appendix} \label{appendix}
%\appendix
All programs provided along with this article are free for
downloading.

\subsection{Prerequisite software}
GNU Make is used for easy build some of the program. For C++ and ANSI C programs,
GNU GCC and G++ 3.4.4 are used. 
For Haskell programs GHC 6.10.4 is used
for building. For Python programs, Python 2.5 is used for testing, for
Scheme/Lisp program, MIT Scheme 14.9 is used.

all source files are put in one folder. Invoke 'make' or 'make all'
will build C++ and Haskell program. 

Run 'make Haskell' will separate build Haskell program. the executable
file is ``happ'' (with .exe
in Window like OS). It is also possible to run the program in GHCi.

\subsection{Tools}

Besides them, I use graphviz to draw most of the figures in this post. In order to
translate the Trie, Patrica and Suffix Tree output to dot language scripts. I wrote a python program.
it can be used like this.

\begin{verbatim}
st2dot -o filename.dot -t type "string"
\end{verbatim}

Where filename.dot is the output file for the dot script, type can be
either trie or tree, the default value is tree. it can generate suffix
Trie/tree from the string input and turns the tree/Trie into dot script.

This helper scripts can also be downloaded with this article.

download position: http://sites.google.com/site/algoxy/stree/stree.zip

\begin{thebibliography}{99}

\bibitem{CLRS}
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. ``Introduction to Algorithms, Second Edition''. The MIT Press, 2001. ISBN: 0262032937.

\bibitem{wiki-b-tree}
B-tree, Wikipedia. http://en.wikipedia.org/wiki/B-tree

\end{thebibliography}

\ifx\wholebook\relax \else
\end{document}
\fi
