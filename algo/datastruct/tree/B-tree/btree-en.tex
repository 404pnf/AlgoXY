\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
%\input{../../../common.tex}
\input{../../../common-en.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{B-Trees with Functional and imperative implementation}

\author{Liu~Xinyu
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
%  Tel:   +86-1305-196-8666 \newline}
  }

\markboth{B-Trees}{Imperative and Functional}

\maketitle

\ifx\wholebook\relax
\chapter{B-Trees with Functional and imperative implementation}

\section{abstract}
\else
\begin{abstract}
\fi
B-Tree is introduced by CLRS book as one of the advanced data
structures. It is important to the modern file systems, some of them
are implemented based on B+ tree, which is extended from B-tree.
It is also widely used in many database systems. This post provides
some implementation of B-trees both in imperative way as described in
CLRS books and in functional way with a kind of modify-and-fix
approach. There are multiple programming languages used, including
C++, Haskell, Python and Scheme/Lisp.

There may be mistakes in the post, please feel free to point out.

This post is generated by \LaTeXe, and provided with GNU FDL(GNU Free Documentation License).
Please refer to http://www.gnu.org/copyleft/fdl.html for detail.

\ifx\wholebook\relax \else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} B-Trees

%{\bfseries Corresponding Author:} Liu Xinyu

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

In CLRS book, B-tree is introduced with the the problem of how to access a
large block of data on magnetic disks or secondary storage devices\cite{CLRS}.
B-tree is commonly used in databases and filesystems.

It is also helpful to understand B-tree as a generalization of balanced binary
search tree\cite{wiki-b-tree}.

Refer to the Figure \ref{fig:btree-example}, It is easy to found the difference
and similarity of B-tree regarding to binary search tree.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/btree-example.ps}
        \caption{An example of B-Tree} \label{fig:btree-example}
       \end{center}
\end{figure}

Let's review the definition of binary search tree \cite{lxy-bst}.

A binary search tree is 
\begin{itemize}
\item either an empty node;
\item or a node contains 3 parts, a value, a left child which is a
binary search tree and a right child which is also a binary search tree.
\end{itemize}

An it satisfies the constraint that.
\begin{itemize}
\item all the values in left child tree is less than the value of of this node;
\item the value of this node is less than any values in its right child tree.
\end{itemize}

The constraint can be represented as the following. for any node $n$,
it satisfies the below equation.

\begin{equation}
\forall x \in LEFT(n), \forall y \in RIGHT(n) \\
\Rightarrow VALUE(x)<VALUE(n)<VALUE(y)
\end{equation}

If we extend this definition to allow multiple keys and children, we get the 
below definition.

A B-tree is 
\begin{itemize}
\item either an empty node;
\item or a node contains $n$ keys, and $n+1$ children, each child is
also a B-Tree, we denote these keys and childrens as $key_1, key_2,
..., key_n$ and $c_1, c_2, ..., c_n, c_{n+1}$.
\end{itemize}

Figure \ref{fig:btree-node} illustrates a B-Tree node.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/btree-node.ps}
        \caption{A B-Tree node} \label{fig:btree-node}
       \end{center}
\end{figure}

The keys and children in a node satisfy the following order constraints.

\begin{itemize}
\item Keys are stored in nondecreasing order. that is $key_1 \leq
key_2 \leq ... \leq key_n$;
\item for each $key_i$, all values stored in child $c_i$ are no bigger 
than $key_i$, while all values stored in child $c_{i+1}$ are no less
than $key_i$.
\end{itemize}

The constraints can be representd as in equation ref{eq:btree-order}
as well.

\begin{equation}
\forall x_i \in c_i, i=0, ..., n, \Rightarrow x_1 \leq key_1 \leq
x_2 \leq key_2 \leq ... \leq x_n \leq key_n \leq x_{n+1}
\end{equation}

Finally, if we added some constraints to make the tree balanced, we get the
complete definition of B-tree.

\begin{itemize}
\item All leaves have the same depth;
\item We define an integral number, $t$, as the {\em minumum degree} of a 
B-tree;
    \begin{itemize}
        \item each node can have at most $2t-1$ keys;
        \item each node can have at least $t-1$ keys, except the root;
    \end{itemize}
\end{itemize}

In this post, I'll first introduce How to generate B-trees by insertion
algorithm. Two different methods will be explained. One method is discussed in CLRS
book, the other is a kind of modify-fix approach which quite similar to the
algorithm Okasaki used in red-black tree\cite{okasaki-rbtree}. This method
is also discussed in wikipedia\cite{wiki-b-tree}. After that, how to delete
element from B-tree is explained. As the last part, algorithm for searching 
in B-tree is also provided.

This article provides example implementation in C, C++, Haskell, Python, and 
Scheme/Lisp languages. 

All source code can be downloaded in appendix \ref{appendix}, please 
refer to appendix for detailed information about build and run.

% ================================================================
%                 Insertion
% ================================================================
\section{Insertion}
\label{btree-insertion}
Insertion is the basic operation to B-tree, a B-tree can be created by inserting
keys repeatly. The essential idea of insertion is similar to the binary
search tree. If the keys to be inserted is x, we examine the keys in a 
node to find a position where all the keys on the left are less than x,
while all the keys on the right hand are greater than x. after that
we can recursively insert x to the child node at this position.

However, this basic idea need to be fine tuned. The first thing is what
the recursion termination criteria is. This problem can be easily solved
by define the rule that, in case the node to be inserted is a leaf node.
We needn't do inserting recursively. This is because leaf node don't have
children at all. We can just put the x between all left hand keys and 
right hand keys, which cause the keys number of a leaf node increased by one.

The second thing is how to keep the balance properties of a B-tree when
inserting. if a leaf has already $2t-1$ keys, it will break the rule of '
each node can has at most $2t-1$ keys' after we insert x to it. Below
sections will show 2 major methods to solve this problem. 

%=========================================================================
%       Split before insertion
%=========================================================================
\subsection{Split before insert method}
\label{split before insertion}

Regarding to the problem of insert a key to a node, which has already
$2t-1$ keys, one solution is to split the node before insertion.

In this case, we can devide the node into 3 parts as shown in 
Figure \ref{fig:node-split}. the left part contains first $t-1$ keys
and $t$ children, while the right part contains the last $t-1$ keys
and $t$ children. Both left part and right part are valid B-tree
nodes. the middle part is just the $t$-th key. It is pushed up
to its parent node (if it already root node, then the $t$-th key,
with 2 children turn be the new root).

\begin{figure}[htbp]
       \begin{center}
       	  \includegraphics[scale=0.5]{img/split-node-before.ps}

          a. Before split,

          \includegraphics[scale=0.5]{img/split-node-after.ps}

          b. After split, 
        \caption{Split node} \label{fig:node-split}
       \end{center}
\end{figure}

Note that the split solution will push a key up to its parent node,
so it is possible that the parent node be full again (greater than
$2t-1$ keys) if it has already $2t-1$ keys.

So the CLRS book provides a solution to check every node from root
along the path until leaf, in case there is a node in this path is 
. the split is applied.

% ================================================================
%               Insert and fix method 
% ================================================================
\subsection{Insert then fix method}

% ================================================================
%               Deletion
% ================================================================
\section{Deletion} 

% ================================================================
%               Merge before delete method
% ================================================================
\subsection{Merge before delete method} 

\subsubsection{Merge before delete algorithm implemented imperatively}


% ================================================================
%               Delete and fix method
% ================================================================

\subsection{Delete and fix method}

\subsection{Delete and fix algorithm implemented functionaly}

% ================================================================
%               Searching
% ================================================================
\section{Searching} 

\subsection{Imperative search algorithm}

\subsection{Functional search algorithm}

% ================================================================
%                 Short summary
% ================================================================
\section{Notes and short summary}


% ================================================================
%                 Appendix
% ================================================================
\section{Appendix} \label{appendix}
%\appendix
All programs provided along with this article are free for
downloading.

\subsection{Prerequisite software}
GNU Make is used for easy build some of the program. For C++ and ANSI C programs,
GNU GCC and G++ 3.4.4 are used. 
For Haskell programs GHC 6.10.4 is used
for building. For Python programs, Python 2.5 is used for testing, for
Scheme/Lisp program, MIT Scheme 14.9 is used.

all source files are put in one folder. Invoke 'make' or 'make all'
will build C++ and Haskell program. 

Run 'make Haskell' will separate build Haskell program. the executable
file is ``happ'' (with .exe
in Window like OS). It is also possible to run the program in GHCi.

\subsection{Tools}

Besides them, I use graphviz to draw most of the figures in this post. In order to
translate the Trie, Patrica and Suffix Tree output to dot language scripts. I wrote a python program.
it can be used like this.

\begin{verbatim}
st2dot -o filename.dot -t type "string"
\end{verbatim}

Where filename.dot is the output file for the dot script, type can be
either trie or tree, the default value is tree. it can generate suffix
Trie/tree from the string input and turns the tree/Trie into dot script.

This helper scripts can also be downloaded with this article.

download position: http://sites.google.com/site/algoxy/stree/stree.zip

\begin{thebibliography}{99}

\bibitem{CLRS}
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. ``Introduction to Algorithms, Second Edition''. The MIT Press, 2001. ISBN: 0262032937.

\bibitem{wiki-b-tree}
B-tree, Wikipedia. http://en.wikipedia.org/wiki/B-tree

\bibitem{lxy-bst}
Liu Xinyu. ``Comparison of imperative and functional implementation of
binary search tree''. http://sites.google.com/site/algoxy/bstree

\bibitem{okasaki-rbtree}
Chris Okasaki. ``FUNCTIONAL PEARLS Red-Black Trees in a Functional Setting''. J. Functional Programming. 1998

\end{thebibliography}

\ifx\wholebook\relax \else
\end{document}
\fi
