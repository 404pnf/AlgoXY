\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
%\input{../../../common.tex}
\input{../../../common-en.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Suffix Tree with Functional and imperative implementation}

\author{Liu~Xinyu
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
%  Tel:   +86-1305-196-8666 \newline}
  }

\markboth{Suffix Tree}{Imperative and Functional}

\maketitle

\ifx\wholebook\relax
\chapter{Suffix Tree with Functional and imperative implementation}

\section{abstract}
\else
\begin{abstract}
\fi
Suffix Tree is an important data structure. It is quite powerful in 
string and DNA informaiton manipulations. Suffix Tree is introduced in 1973.
The latest online construction algorithm was found in 1995. This post 
collects some existing result of suffix tree, including the construction
algorithms as well as some typical applications. Some imperative and functional
implementation are given. There are multiple programming languages used, 
including C++, Haskell, Python and Scheme/Lisp.

There may be mistakes in the post, please feel free to point out.

This post is generated by \LaTeXe, and provided with GNU FDL(GNU Free Documentation License).
Please refer to http://www.gnu.org/copyleft/fdl.html for detail.

\ifx\wholebook\relax \else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} Suffix Tree

%{\bfseries Corresponding Author:} Liu Xinyu

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

Suffix Tree is a special Patricia. There is no such a chapter
in CLSR book. To introduce suffix tree together with Trie and Patricia
will be a bit easy to understand. 

As a data structure, Suffix tree allows for paticulary fast implementation
of many important string operations\cite{wiki-suffix-tree}. And it is 
also widely used in bio-information area such as DNA pattern 
matching\cite{ukkonen-presentation}.

The suffix tree for a string $S$ is a Patricia tree, with each edges are labeled
with some sub-string of $S$. Each suffix of $S$ corresponds to exactly one path
from root to a leaf. Figure \ref{fig:stree-banana} shows the suffix tree for
an English word `banana'.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/stree-banana.ps}
        \caption{The suffix tree for `banana'} \label{fig:stree-banana}
       \end{center}
\end{figure}

Note that all suffixes, 'banana', 'anana', 'nana', 'ana', 'na', 'a', '' can 
be looked up in the above tree. Among them the first 3 suffixes are explicitly
shown; others are implicitly represented. The reason for why 'ana, 'na', 'a', 
and '' are not shown explicitly is because they are prefixes of some edges.
In order to make all suffixes shown explicitly, we can append a special pad 
terminal symbal, which is not seen to the string. Such terminator is typically
denoted as '\$'. With this method, no suffix will be a prefix of the others.
In this post, we won't use terminal symbol for most cases.

It's very interesting that compare to the simple suffix tree for 'banana', the
suffix tree for 'bananas' is quite different as shown in figure \ref{fig:stree-bananas}.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/stree-bananas.ps}
        \caption{The suffix tree for `bananas'} \label{fig:stree-bananas}
       \end{center}
\end{figure}

In this post, I'll first introduce about suffix Trie, and give the trivial method
about how to construct suffix Trie and tree. Trivial methods utilize the insertion
algorithm for normal Trie and patricia. They need much of computation and spaces.
Then, I'll explain about the online construction for suffix Trie by using suffix link
concept. After that, I'll show Ukkonen's method, which is a linear time online 
construction algorithm. For both suffix Trie and suffix tree, functional approach
is provided as well as the imperative one. In the last section, I'll list some
typical string manipulation problems and show how to solve them with suffix tree.

This article provides example implementation in C, C++, Haskell, Python, and 
Scheme/Lisp languages. 

All source code can be downloaded in appendix \ref{appendix}, please 
refer to appendix for detailed information about build and run.

% ================================================================
%                 Suffix Trie
% ================================================================
\section{Suffix Trie}
\label{suffix-trie}

Just likes the relationship between Trie and Patricia, Suffix Trie has much simpler
structure than suffix tree. Figure \ref{fig:strie-banana} shows the suffix Trie of
'banana'.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/strie-banana.ps}
        \caption{Suffix Trie of 'banana'} \label{fig:strie-banana}
       \end{center}
\end{figure}

Compare with figure \ref{fig:stree-banana}, the difference is that, instead of representing
a word for each edge, one edge in suffix Trie only represents one character. Thus
suffix Trie need more spaces. If we pack all nodes which has only one child, the suffix
Trie can be turned into a suffix tree.

Suffix Trie can be a good start point for explaining the suffix tree construction algorithm.

%=========================================================================
%       Trivial construction of Suffix Trie and Suffix Tree
%=========================================================================
\section{Trivial construction methods of Suffix Tree}
\label{trivial-cons}

By repeatly applying the insertion algorithms\cite{lxy-trie} for Trie and Patricia
on each suffixes of a word, Suffix Trie and tree can be built in a trivial way.

Below algorithm illustrates this approach for suffix tree.

\begin{algorithmic}
\STATE $TRIVIAL-SUFFIX-TREE(S)$
  \STATE $T \leftarrow NIL$
  \FOR{$i$ from $1$ to $LENGTH(S)$}
    \STATE $T \leftarrow PATRICIA-INSERT(T, RIGHT(S, i))$
  \ENDFOR
  \RETURN $T$
\end{algorithmic}

Where function $RIGHT(S, i)$ will extract substring of S from left to right most.
Similar functional algorithm can also be provided in this way.

\begin{algorithmic}
\STATE $TRIVIAL-SUFFIX-TREE'(S)$
  \RETURN $FOLD-LEFT(PATRICIA-INSERT, NIL, TAILS(S))$
\end{algorithmic}

Function TAILS() returns a list of all suffixes for string S. In Haskell, Module 
Data.List provides this function already. In Scheme/Lisp, it can be implemented as below.

\lstset{language=lisp}
\begin{lstlisting}
(define (tails s)
  (if (string-null? s)
      '("")
      (cons s (tails (string-tail s 1)))))
\end{lstlisting}

The trivial suffix Trie/tree construction method takes $O(n^2)$ time, where $n$ is the 
length of the word. Altough the string manipulation can be very fast by using suffix
tree, slow construction will be the bottleneck of the whole process.

% ================================================================
%               Online construction of Suffix Trie
% ================================================================
\section{Online construction of suffix trie}

Analysis of construction for suffix Trie can be a good start point in finding
the linear time suffix tree construction algorithm. In Ukkonen's paper\cite{ukkonen95}, 
finite-state automation, transition function and suffix function are used to 
build the mathematical model for suffix Trie/tree. 

In order to make it easy for understanding, let's explain the above concept with
the elements of Trie data structure.

With a set of alphabetic, a string with length $n$ can be defined as $S=s_1s_2...s_n$.
And we define $S[i]=s_1s_2...s_i$, which contains the first $i$ characters.

In a suffix Trie, each node represents a suffix string. for example in figure 
\ref{fig:strie-cacao}, node X represents suffix 'a', by adding a character 'c',
node X transfers to node Y which represents suffix 'ac'. We say node X and edge labelled 'c'
transfers to node Y. This relationship can be denoted in psuedo code as below.

\begin{figure}[htbp]
   \begin{center}
     \includegraphics[scale=0.5]{img/strie-cacao.ps}
     \caption{node $X \leftarrow$ ``a'', node $Y \leftarrow$ ``ac'', $X$ transfers to $Y$ with character 'c'}
     \label{fig:strie-cacao}
   \end{center}
\end{figure}

$Y \leftarrow CHILDREN(X)[c]$

It's equal to the following C++ and Python code.

\lstset{language=python}
\begin{lstlisting}
y = x.children[c]
\end{lstlisting}

We also say that node x has a c-child y.

If a node $A$ in a suffix Trie represents for a suffix $s_is_{i+1}...s_n$, 
and node $B$ represents for suffix $s_{i+1}s_{i+2}...s_n$, we say node $B$
represents for the suffix of node $A$. We can create a link from $A$ to $B$.
This link is defined as the suffix link of node $A$. In this post, we show
suffix link in dotted style. In figure \ref{fig:strie-cacao}, suffix link of
node $A$ points to node $B$, and suffix link of node $B$ points to node $C$.
Suffix link is an important tool in Ukkonen's online construction algorithm,
it is also used in some other algorithms running on the suffix tree.

\subsection{on-line construction algorithm for suffix Trie}
For a string $S$, Suppose we have construct suffix Trie for its $i$-th prefix
$s_1s_2...s_i$. We denote the suffix Trie for this $i$-th prefix as $SuffixTrie(S_i)$.
Let's consider how can we obtain $SuffixTrie(S_{i+1})$ from $SuffixTrie(S_i)$.

If we list all suffixes corresponding to $SuffixTrie(S_i)$, we get a table as below.

\begin{table}
  \begin{tabular}{r}
    suffix string \\
    $s_1s_2...s_i$ \\
    $s_2s_3...s_i$ \\
    ... \\
    $s_{i-1}s_i$ \\
    $s_i$ \\
    ``'' \\
  \end{tabular}
  \caption{suffixes for $S_i$}
  \label{tab:suffixes_s_i}
\end{table}

The most straightforward way is to append $s_{i+1}$ to each of the suffix in above
table, and add a new empty suffix. This operation can be implemented as create
a new node, and append the new node as a child with edge bind to character $s_{i+1}$.

\begin{algorithmic}
\FOR{each $node$ in $SuffixTrie(S_i)$}
  \STATE $CHILDREN(node)[s_{i+1}]=CREATE-NEW-NODE()$
\ENDFOR
\end{algorithmic}


However, some node in $SuffixTrie(S_i)$ may have already $s_{i+1}$-child. 
For example, in figure \ref{fig:strie-cac}, Node $X$ and $Y$ are corresonding 
for suffix 'cac' and 'ac', they don't have 'a'-child.
While node $Z$, which represents for suffix 'c' has 'a'-child already.

\begin{figure}[htbp]
   \begin{center}
     \includegraphics[scale=0.5]{img/strie-cac.ps}
     \includegraphics[scale=0.5]{img/strie-caca.ps}
     \caption{Suffix Trie of ``cac'' and ``caca''}
     \label{fig:strie-cac}
   \end{center}
\end{figure}

When we append $s_{i+1}$, in this case it is 'a', to $SuufixTrie(S_i)$. We need create
a new node and append the new node to $X$ and $Y$, however, we needn't create new
node to $Z$, because node $Z$ has already a child node with edge 'a'. So 
$SuffixTrie(S_{i+1})$, in this case it is for ``caca'', is shown in right part of
figure \ref{fig:strie-cac}.

If we check each node as the same order as in table \ref{tab:suffixes_s_i}, we can 
stop immediately once we find a node has a $s_{i+1}$-child. This is because all suffixes 
after that will also be 

According to this 

C++/Python version of this algorithm

Alternative functional algorithm

Haskell and Scheme/Lisp version.

% ================================================================
%               Online construction of suffix tree
% ================================================================
\subsection{Online construction of suffix tree} 

On-line construction algorithm here...

C++/Python verison of this algorithm

Alternative functional algorithm

Haskell and Scheme/Lisp version.

% ================================================================
%               Suffix tree applications
% ================================================================

\section{Suffix tree applications}

List how some interesting problems are solved with Suffix tree.

% ================================================================
%                 Short summary
% ================================================================
\section{Notes and short summary}

Suffix Tree was first introduced by Weiner in 1973 \cite{weiner}.

Short summary here.

% ================================================================
%                 Appendix
% ================================================================
\section{Appendix} \label{appendix}
%\appendix
All programs provided along with this article are free for
downloading.

\subsection{Prerequisite software}
GNU Make is used for easy build some of the program. For C++ and ANSI C programs,
GNU GCC and G++ 3.4.4 are used. I use boost triple to reduce the
amount of our code lines, boost library version I am using is
1.33.1. The path is in CXX variable in Makefile, please change it to
your path when compiling.
For Haskell programs GHC 6.10.4 is used
for building. For Python programs, Python 2.5 is used for testing, for
Scheme/Lisp program, MIT Scheme 14.9 is used.

all source files are put in one folder. Invoke 'make' or 'make all'
will build C++ and Haskell program. 

Run 'make Haskell' will separate build Haskell program. There will be
two executable file generated one is htest the other is happ (with .exe
in Window like OS). Run htest will test functions in ...

\subsection{Tools}

Besides them, I use graphviz to draw most of the figures in this post. In order to
translate the Trie, Patrica and Suffix Tree output to dot language scripts. I wrote a python program.
it can be used like this.

\begin{verbatim}
st2dot...
\end{verbatim}

This helper scripts can also be downloaded with this article.

download position: http://sites.google.com/site/algoxy/stree/stree.zip

\begin{thebibliography}{99}

\bibitem{ukkonen95}
Esko Ukkonen. ``On-line construction of suffix trees''. Algorithmica 14 (3): 249--260. doi:10.1007/BF01206331. http://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf

\bibitem{wiki-suffix-tree}
Suffix Tree, Wikipedia. http://en.wikipedia.org/wiki/Suffix\_tree

\bibitem{ukkonen-presentation}
Esko Ukkonen. ``Suffix tree and suffix array techniques for pattern ananlysis in strings''. http://www.cs.helsinki.fi/u/ukkonen/Erice2005.ppt

\bibitem{wiki-trie}
Trie, Wikipedia. http://en.wikipedia.org/wiki/Trie

\bibitem{lxy-trie}
Liu Xinyu. ``Trie and Patricia, with Functional and imperative implementation''. http://sites.google.com/site/algoxy/trie

\end{thebibliography}

\ifx\wholebook\relax \else
\end{document}
\fi
