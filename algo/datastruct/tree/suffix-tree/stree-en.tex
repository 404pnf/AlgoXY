\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
%\input{../../../common.tex}
\input{../../../common-en.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Suffix Tree with Functional and imperative implementation}

\author{Liu~Xinyu
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
%  Tel:   +86-1305-196-8666 \newline}
  }

\markboth{Suffix Tree}{Imperative and Functional}

\maketitle

\ifx\wholebook\relax
\chapter{Suffix Tree with Functional and imperative implementation}

\section{abstract}
\else
\begin{abstract}
\fi
Suffix Tree is an important data structure. It is quite powerful in 
string and DNA informaiton manipulations. Suffix Tree is introduced in 1973.
The latest online construction algorithm was found in 1995. This post 
collects some existing result of suffix tree, including the construction
algorithms as well as some typical applications. Some imperative and functional
implementation are given. There are multiple programming languages used, 
including C++, Haskell, Python and Scheme/Lisp.

There may be mistakes in the post, please feel free to point out.

This post is generated by \LaTeXe, and provided with GNU FDL(GNU Free Documentation License).
Please refer to http://www.gnu.org/copyleft/fdl.html for detail.

\ifx\wholebook\relax \else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} Suffix Tree

%{\bfseries Corresponding Author:} Liu Xinyu

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

Suffix Tree is a special Patricia. There is no such a chapter
in CLSR book. To introduce suffix tree together with Trie and Patricia
will be a bit easy to understand. 

As a data structure, Suffix tree allows for paticulary fast implementation
of many important string operations\cite{wiki-suffix-tree}. And it is 
also widely used in bio-information area such as DNA pattern 
matching\cite{ukkonen-presentation}.

The suffix tree for a string $S$ is a Patricia tree, with each edges are labeled
with some sub-string of $S$. Each suffix of $S$ corresponds to exactly one path
from root to a leaf. Figure \ref{fig:stree-banana} shows the suffix tree for
an English word `banana'.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/stree-banana.ps}
        \caption{The suffix tree for `banana'} \label{fig:stree-banana}
       \end{center}
\end{figure}

Note that all suffixes, 'banana', 'anana', 'nana', 'ana', 'na', 'a', '' can 
be looked up in the above tree. Among them the first 3 suffixes are explicitly
shown; others are implicitly represented. The reason for why 'ana, 'na', 'a', 
and '' are not shown explicitly is because they are prefixes of some edges.
In order to make all suffixes shown explicitly, we can append a special pad 
terminal symbal, which is not seen to the string. Such terminator is typically
denoted as '\$'. With this method, no suffix will be a prefix of the others.
In this post, we won't use terminal symbol for most cases.

It's very interesting that compare to the simple suffix tree for 'banana', the
suffix tree for 'bananas' is quite different as shown in figure \ref{fig:stree-bananas}.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/stree-bananas.ps}
        \caption{The suffix tree for `bananas'} \label{fig:stree-bananas}
       \end{center}
\end{figure}

In this post, I'll first introduce about suffix Trie, and give the trivial method
about how to construct suffix Trie and tree. Trivial methods utilize the insertion
algorithm for normal Trie and patricia. They need much of computation and spaces.
Then, I'll explain about the online construction for suffix Trie by using suffix link
concept. After that, I'll show Ukkonen's method, which is a linear time online 
construction algorithm. For both suffix Trie and suffix tree, functional approach
is provided as well as the imperative one. In the last section, I'll list some
typical string manipulation problems and show how to solve them with suffix tree.

This article provides example implementation in C, C++, Haskell, Python, and 
Scheme/Lisp languages. 

All source code can be downloaded in appendix \ref{appendix}, please 
refer to appendix for detailed information about build and run.

% ================================================================
%                 Suffix Trie
% ================================================================
\section{Suffix Trie}
\label{suffix-trie}

Just likes the relationship between Trie and Patricia, Suffix Trie has much simpler
structure than suffix tree. Figure \ref{fig:strie-banana} shows the suffix Trie of
'banana'.

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{img/strie-banana.ps}
        \caption{Suffix Trie of 'banana'} \label{fig:strie-banana}
       \end{center}
\end{figure}

Compare with figure \ref{fig:stree-banana}, the difference is that, instead of representing
a word for each edge, one edge in suffix Trie only represents one character. Thus
suffix Trie need more spaces. If we pack all nodes which has only one child, the suffix
Trie can be turned into a suffix tree.

Suffix Trie can be a good start point for explaining the suffix tree construction algorithm.

%=========================================================================
%       Trivial construction of Suffix Trie and Suffix Tree
%=========================================================================
\section{Trivial construction methods of Suffix Tree}
\label{trivial-cons}

By repeatly applying the insertion algorithms\cite{lxy-trie} for Trie and Patricia
on each suffixes of a word, Suffix Trie and tree can be built in a trivial way.

Below algorithm illustrates this approach for suffix tree.

\begin{algorithmic}
\STATE $TRIVIAL-SUFFIX-TREE(S)$
  \STATE $T \leftarrow NIL$
  \FOR{$i$ from $1$ to $LENGTH(S)$}
    \STATE $T \leftarrow PATRICIA-INSERT(T, RIGHT(S, i))$
  \ENDFOR
  \RETURN $T$
\end{algorithmic}

Where function $RIGHT(S, i)$ will extract substring of S from left to right most.
Similar functional algorithm can also be provided in this way.

\begin{algorithmic}
\STATE $TRIVIAL-SUFFIX-TREE'(S)$
  \RETURN $FOLD-LEFT(PATRICIA-INSERT, NIL, TAILS(S))$
\end{algorithmic}

Function TAILS() returns a list of all suffixes for string S. In Haskell, Module 
Data.List provides this function already. In Scheme/Lisp, it can be implemented as below.

\lstset{language=lisp}
\begin{lstlisting}
(define (tails s)
  (if (string-null? s)
      '("")
      (cons s (tails (string-tail s 1)))))
\end{lstlisting}

The trivial suffix Trie/tree construction method takes $O(n^2)$ time, where $n$ is the 
length of the word. Altough the string manipulation can be very fast by using suffix
tree, slow construction will be the bottleneck of the whole process.

% ================================================================
%               Online construction of Suffix Trie
% ================================================================
\section{Online construction of suffix trie}

Analysis of construction for suffix Trie can be a good start point in finding
the linear time suffix tree construction algorithm. In Ukkonen's paper\cite{ukkonen95}, 
finite-state automation, transition function and suffix function are used to 
build the mathematical model for suffix Trie/tree. 

In order to make it easy for understanding, let's explain the above concept with
the elements of Trie data structure.

With a set of alphabetic, a string with length $n$ can be defined as $S=s_1s_2...s_n$.
And we define $S[i]=s_1s_2...s_i$, which contains the first $i$ characters.

In a suffix Trie, each node represents a suffix string. for example in figure 
\ref{fig:strie-cacao}, node X represents suffix 'a', by adding a character 'c',
node X transfers to node Y which represents suffix 'ac'. We say node X and edge labelled 'c'
transfers to node Y. This relationship can be denoted in psuedo code as below.

\begin{figure}[htbp]
   \begin{center}
     \includegraphics[scale=0.4]{img/strie-cacao.ps}
     \caption{node $X \leftarrow$ ``a'', node $Y \leftarrow$ ``ac'', $X$ transfers to $Y$ with character 'c'}
     \label{fig:strie-cacao}
   \end{center}
\end{figure}

$Y \leftarrow CHILDREN(X)[c]$

It's equal to the following C++ and Python code.

\lstset{language=python}
\begin{lstlisting}
y = x.children[c]
\end{lstlisting}

We also say that node x has a c-child y.

If a node $A$ in a suffix Trie represents for a suffix $s_is_{i+1}...s_n$, 
and node $B$ represents for suffix $s_{i+1}s_{i+2}...s_n$, we say node $B$
represents for the suffix of node $A$. We can create a link from $A$ to $B$.
This link is defined as the suffix link of node $A$. In this post, we show
suffix link in dotted style. In figure \ref{fig:strie-cacao}, suffix link of
node $A$ points to node $B$, and suffix link of node $B$ points to node $C$.
Suffix link is an important tool in Ukkonen's online construction algorithm,
it is also used in some other algorithms running on the suffix tree.

\subsection{on-line construction algorithm for suffix Trie}
For a string $S$, Suppose we have construct suffix Trie for its $i$-th prefix
$s_1s_2...s_i$. We denote the suffix Trie for this $i$-th prefix as $SuffixTrie(S_i)$.
Let's consider how can we obtain $SuffixTrie(S_{i+1})$ from $SuffixTrie(S_i)$.

If we list all suffixes corresponding to $SuffixTrie(S_i)$, fromt the longest 
$S_i$ to the shortest empty string, we get table \ref{tab:suffixes_s_i}. There
are total $i+1$ suffixes.

\begin{table}
  \begin{tabular}{r}
    suffix string \\
    $s_1s_2...s_i$ \\
    $s_2s_3...s_i$ \\
    ... \\
    $s_{i-1}s_i$ \\
    $s_i$ \\
    ``'' \\
  \end{tabular}
  \caption{suffixes for $S_i$}
  \label{tab:suffixes_s_i}
\end{table}

The most straightforward way is to append $s_{i+1}$ to each of the suffix in above
table, and add a new empty suffix. This operation can be implemented as create
a new node, and append the new node as a child with edge bind to character $s_{i+1}$.

\begin{algorithm}
\begin{algorithmic}
\FOR{each $node$ in $SuffixTrie(S_i)$}
  \STATE $CHILDREN(node)[s_{i+1}] \leftarrow CREATE-NEW-NODE()$
\ENDFOR
\end{algorithmic}
\caption{Initial version of update $SuffixTrie(S_i)$ to $SuffixTrie(S_{i+1})$.}
\label{algo:strie1}
\end{algorithm}

However, some node in $SuffixTrie(S_i)$ may have already $s_{i+1}$-child. 
For example, in figure \ref{fig:strie-cac}, Node $X$ and $Y$ are corresonding 
for suffix 'cac' and 'ac', they don't have 'a'-child.
While node $Z$, which represents for suffix 'c' has 'a'-child already.

\begin{figure}[htbp]
   \begin{center}
     \includegraphics[scale=0.5]{img/strie-cac.ps}
     \includegraphics[scale=0.5]{img/strie-caca.ps}
     \caption{Suffix Trie of ``cac'' and ``caca''}
     \label{fig:strie-cac}
   \end{center}
\end{figure}

When we append $s_{i+1}$, in this case it is 'a', to $SuufixTrie(S_i)$. We need create
a new node and append the new node to $X$ and $Y$, however, we needn't create new
node to $Z$, because node $Z$ has already a child node with edge 'a'. So 
$SuffixTrie(S_{i+1})$, in this case it is for ``caca'', is shown in right part of
figure \ref{fig:strie-cac}.

If we check each node as the same order as in table \ref{tab:suffixes_s_i}, we can 
stop immediately once we find a node which has a $s_{i+1}$-child. This is because 
if a node $X$ in $SuffixTrie(S_i)$ has already a $s_{i+1}$-child, then according to the
definition of suffix link, all suffix nodes $X'$ of $X$ in $SuffixTrie(S_i)$ must 
also have $s_{i+1}$-child. In other words, let $c=s_{i+1}$, if $wc$ is a substring
of $S_i$, then every suffix of $wc$ is also a substring of $S_i$ \cite{ukkonen95}.
The only exception is root node, which represents for empty string ``''.

According to this fact, we can refine the algorithm \ref{algo:strie1} to 

\begin{algorithm}
  \begin{algorithmic}
  \FOR{each $node$ in $SuffixTrie(S_i)$ in descending order of suffix length}
    \IF{$CHILDREN(node)[s_{i+1}] = NIL$}
      \STATE $CHILDREN(node)[s_{i+1}] \leftarrow CREATE-NEW-NODE()$ 
    \ELSE
      \STATE break
    \ENDIF
  \ENDFOR
  \end{algorithmic}
  \caption{Revised version of update $SuffixTrie(S_i)$ to $SuffixTrie(S_{i+1})$.}
  \label{algo:strie2}
\end{algorithm}

The next unclear question is how to iterate all nodes in $SuffixTrie(S_i)$
in descending order of suffix string length? We can define the top of a suffix
Trie as the deepest leaf node, by using suffix link for each node, we can 
traverse suffix Trie untill the root. Note that the top of $SuffixTrie(NIL)$
is root, so we can get a final version of on-line construction algorithm for
suffix Trie.

\begin{algorithmic}
\STATE $INSERT(top, c)$
  \IF{$top = NIL$}
    \STATE $top \leftarrow CREATE-NEW-NODE()$
  \ENDIF
  \STATE $node \leftarrow top$
  \STATE $node' \leftarrow CREATE-NEW-NODE()$
  \WHILE{$node \ne NIL \and CHILDREN(node)[c] = NIL$}
    \STATE $CHILDREN(node)[c] \leftarrow CREATE-NEW-NODE()$
    \STATE $SUFFIX-LINK(node') \leftarrow CHILDREN(node)[c]$
    \STATE $node' \leftarrow CHILDREN(node)[c]$
    \STATE $node \leftarrow SUFFIX-LINK(node)$
  \ENDWHILE
  \IF{$node \ne NIL$}
    \STATE $SUFFIX-LINK(node') \leftarrow CHILDREN(node)[c]$
  \ENDIF
  \RETURN $CHILDREN(top)[c]$
\end{algorithmic}

The above function $INSERT()$, can update $SuffixTrie(S_i)$ to $SuffixTrie(S_{i+1})$.
It receives two parameters, one is the top node of $SuffixTrie(S_i)$, the other
is the character of $s_{i+1}$. If the top node is NIL, which means that there is
no root node yet, it create the root node then. Compare to the algorithm given
by Ukkonen \cite{ukkonen95}, I use a dummy node $node'$ to keep tracking the 
previous created new node. In the main loop, the algorithm check each node
to see if it has $s_{i+1}$-child, if not, it will create new node, and bind the 
edge to character $s_{i+1}$. Then it go up along the suffix link untill either
arrives at root node, or find a node which has $s_{i+1}$-child already. After
the loop, if the node point to some where in the Trie, the algorithm will 
make the last suffix link point to that place. The new top position is returned
as the final result.

and the main part of the algorithm is as below:
\begin{algorithmic}
\STATE $SUFFIX-TRIE(S)$
  \STATE $t \leftarrow NIL$
  \FOR{$i$ from 1 to $LENGTH(S)$}
    \STATE $t \leftarrow INSERT(t, s_i)$
  \ENDFOR
\end{algorithmic}

Figure \ref{fig:cons-strie-cacao} shows the phases of on-line construction
of suffix Trie for ``cacao''. Only the last layer of suffix links are shown.

\begin{figure}[htbp]
   \begin{center}
     \includegraphics[scale=0.5]{img/strie-empty.ps}empty
     \includegraphics[scale=0.5]{img/strie-c.ps}``c''
     \includegraphics[scale=0.5]{img/strie-ca.ps}``ca''
     \includegraphics[scale=0.5]{img/strie-cac.ps}``cac'' \newline
     \includegraphics[scale=0.5]{img/strie-caca.ps}``caca''
     \includegraphics[scale=0.5]{img/strie-cacao.ps}``cacao''
     \caption{Construction of suffix Trie for ``cacao'', the 6 phases are shown, only the last layer of suffix links are shown in dotted arrow.}
     \label{fig:cons-strie-cacao}
   \end{center}
\end{figure}


\subsection{Suffix Trie on-line construction program in Python and C++}
The above algorithm can be easily implemented with imperative languages such as C++ and Python.
In this section, I'll first give the defitions of the suffix Trie node. After that, I'll
show the algorithms. In order to test and verify the programs, I'll provide some helper
functions to print the Trie as human readable strings and give some lookup function as well.

\subsubsection{Definition of suffix Trie node in Python}
With Python programming language, we can define the node in suffix Trie with two fields, one
is a dictionary of children, the key is the character binding to an edge, and the value
is the child node. The other field is suffix link, it points to a node which represents for
the suffix string of this one.

\lstset{language=Python}
\begin{lstlisting}
class STrie:
    def __init__(self, suffix=None):
        self.children = {}
        self.suffix = suffix
\end{lstlisting}

By default, the suffix link for a node is initialized as empty, it will be set during the 
main construction algorithm.

\subsubsection{Definition of suffix Trie node in C++}

\subsubsection{Suffix Trie on-line construction algorithm in Python}
The main algorithm of updating $SuffixTrie(S_i)$ to $SuffixTrie(S_{i+1})$ is as below.
It takes the top position node and the character to be updated as parameters.

\lstset{language=Python}
\begin{lstlisting}
def insert(top, c):
    if top is None:
        top=STrie()
    node = top
    new_node = STrie() #dummy init value
    while (node is not None) and (c not in node.children):
        new_node.suffix = node.children[c] = STrie(node)
        new_node = node.children[c]
        node = node.suffix
    if node is not None:
        new_node.suffix = node.children[c]
    return top.children[c] #update top
\end{lstlisting}

The main entry point of the program iterates all characters of a given string, and 
call the insert() function repeatly.

\begin{lstlisting}
def suffix_trie(str):
    t = None
    for c in str:
        t = insert(t, c)
    return root(t)
\end{lstlisting}

Becuase insert() function returns the updated top position, the program calls
a function to return the root node as the final result. This function is implemented
as the following.

\begin{lstlisting}
def root(node):
    while node.suffix is not None:
        node = node.suffix
    return node
\end{lstlisting}

It will go along with the suffix links untill reach the root node.

In order to verify the program, we need convert the suffix Trie to human readable
string. This is realized in a recursive way for easy illustration purpose.

\begin{lstlisting}
def to_lines(t):
    if len(t.children)==0:
        return [""]
    res = []
    for c, tr in sorted(t.children.items()):
        lines = to_lines(tr)
        lines[0] = "|--"+c+"-->"+lines[0]
        if len(t.children)>1:
            lines[1:] = map(lambda l: "|      "+l, lines[1:])
        else:
            lines[1:] = map(lambda l: "       "+l, lines[1:])
        if res !=[]:
            res.append("|")
        res += lines
    return res

def to_str(t):
    return "\n".join(to_lines(t))
\end{lstlisting}

With the to\_str() helper function, we can test our program with
some simple cases.

\begin{lstlisting}
class SuffixTrieTest:
    def __init__(self):
        print "start suffix trie test"

    def run(self):
        self.test_build()

    def __test_build(self, str):
        print "Suffix Trie ("+str+"):\n", to_str(suffix_trie(str)),"\n"

    def test_build(self):
        str="cacao"
        for i in range(len(str)):
            self.__test_build(str[:i+1])
\end{lstlisting}

Run this test program will output the below result.

\begin{verbatim}
start suffix trie test
Suffix Trie (c):
|--c--> 

Suffix Trie (ca):
|--a-->
|
|--c-->|--a--> 

Suffix Trie (cac):
|--a-->|--c-->
|
|--c-->|--a-->|--c--> 

Suffix Trie (caca):
|--a-->|--c-->|--a-->
|
|--c-->|--a-->|--c-->|--a--> 

Suffix Trie (cacao):
|--a-->|--c-->|--a-->|--o-->
|      |
|      |--o-->
|
|--c-->|--a-->|--c-->|--a-->|--o-->
|             |
|             |--o-->
|
|--o--> 
\end{verbatim}

Compare with figure \ref{fig:cons-strie-cacao}, we can find that the results are identical.

\subsubsection{Suffix Trie on-line construction algorithm in C++}

Alternative functional algorithm

Haskell and Scheme/Lisp version.

Big-O analysis

% ================================================================
%               Online construction of suffix tree
% ================================================================
\subsection{Online construction of suffix tree} 

On-line construction algorithm here...

C++/Python verison of this algorithm

Alternative functional algorithm

Haskell and Scheme/Lisp version.

% ================================================================
%               Suffix tree applications
% ================================================================

\section{Suffix tree applications}

List how some interesting problems are solved with Suffix tree.

% ================================================================
%                 Short summary
% ================================================================
\section{Notes and short summary}

Suffix Tree was first introduced by Weiner in 1973 \cite{weiner}.

Short summary here.

% ================================================================
%                 Appendix
% ================================================================
\section{Appendix} \label{appendix}
%\appendix
All programs provided along with this article are free for
downloading.

\subsection{Prerequisite software}
GNU Make is used for easy build some of the program. For C++ and ANSI C programs,
GNU GCC and G++ 3.4.4 are used. I use boost triple to reduce the
amount of our code lines, boost library version I am using is
1.33.1. The path is in CXX variable in Makefile, please change it to
your path when compiling.
For Haskell programs GHC 6.10.4 is used
for building. For Python programs, Python 2.5 is used for testing, for
Scheme/Lisp program, MIT Scheme 14.9 is used.

all source files are put in one folder. Invoke 'make' or 'make all'
will build C++ and Haskell program. 

Run 'make Haskell' will separate build Haskell program. There will be
two executable file generated one is htest the other is happ (with .exe
in Window like OS). Run htest will test functions in ...

\subsection{Tools}

Besides them, I use graphviz to draw most of the figures in this post. In order to
translate the Trie, Patrica and Suffix Tree output to dot language scripts. I wrote a python program.
it can be used like this.

\begin{verbatim}
st2dot...
\end{verbatim}

This helper scripts can also be downloaded with this article.

download position: http://sites.google.com/site/algoxy/stree/stree.zip

\begin{thebibliography}{99}

\bibitem{ukkonen95}
Esko Ukkonen. ``On-line construction of suffix trees''. Algorithmica 14 (3): 249--260. doi:10.1007/BF01206331. http://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf

\bibitem{wiki-suffix-tree}
Suffix Tree, Wikipedia. http://en.wikipedia.org/wiki/Suffix\_tree

\bibitem{ukkonen-presentation}
Esko Ukkonen. ``Suffix tree and suffix array techniques for pattern ananlysis in strings''. http://www.cs.helsinki.fi/u/ukkonen/Erice2005.ppt

\bibitem{wiki-trie}
Trie, Wikipedia. http://en.wikipedia.org/wiki/Trie

\bibitem{lxy-trie}
Liu Xinyu. ``Trie and Patricia, with Functional and imperative implementation''. http://sites.google.com/site/algoxy/trie

\end{thebibliography}

\ifx\wholebook\relax \else
\end{document}
\fi
