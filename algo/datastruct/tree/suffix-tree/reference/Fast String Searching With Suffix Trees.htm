<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0045)http://marknelson.us/1996/08/01/suffix-trees/ -->
<HTML xmlns="http://www.w3.org/1999/xhtml"><HEAD profile="http://gmpg.org/xfn/11"><META http-equiv="Content-Type" content="text/html; charset=UTF-8">

<TITLE>Fast String Searching With Suffix Trees  </TITLE>
<LINK rel="stylesheet" href="./Fast String Searching With Suffix Trees_files/style.css" type="text/css" media="screen">
<LINK rel="alternate" type="application/rss+xml" title="RSS 2.0" href="http://marknelson.us/feed/">
<LINK rel="alternate" type="text/xml" title="RSS .92" href="http://marknelson.us/feed/rss/">
<LINK rel="alternate" type="application/atom+xml" title="Atom 0.3" href="http://marknelson.us/feed/atom/">
<LINK rel="pingback" href="http://marknelson.us/xmlrpc.php">
<LINK rel="icon" href="http://marknelson.us/favicon.ico" type="image/x-icon">
<LINK rel="EditURI" type="application/rsd+xml" title="RSD" href="http://scott-m.net/xmlrpc.php?rsd">
<META name="generator" content="WordPress 2.2.3">
	<LINK rel="archives" title="July 2008" href="http://marknelson.us/2008/07/">
	<LINK rel="archives" title="June 2008" href="http://marknelson.us/2008/06/">
	<LINK rel="archives" title="May 2008" href="http://marknelson.us/2008/05/">
	<LINK rel="archives" title="April 2008" href="http://marknelson.us/2008/04/">
	<LINK rel="archives" title="March 2008" href="http://marknelson.us/2008/03/">
	<LINK rel="archives" title="February 2008" href="http://marknelson.us/2008/02/">
	<LINK rel="archives" title="January 2008" href="http://marknelson.us/2008/01/">
	<LINK rel="archives" title="December 2007" href="http://marknelson.us/2007/12/">
	<LINK rel="archives" title="November 2007" href="http://marknelson.us/2007/11/">
	<LINK rel="archives" title="September 2007" href="http://marknelson.us/2007/09/">
	<LINK rel="archives" title="August 2007" href="http://marknelson.us/2007/08/">
	<LINK rel="archives" title="July 2007" href="http://marknelson.us/2007/07/">
	<LINK rel="archives" title="May 2007" href="http://marknelson.us/2007/05/">
	<LINK rel="archives" title="April 2007" href="http://marknelson.us/2007/04/">
	<LINK rel="archives" title="November 2006" href="http://marknelson.us/2006/11/">
	<LINK rel="archives" title="October 2006" href="http://marknelson.us/2006/10/">
	<LINK rel="archives" title="September 2006" href="http://marknelson.us/2006/09/">
	<LINK rel="archives" title="August 2006" href="http://marknelson.us/2006/08/">
	<LINK rel="archives" title="July 2006" href="http://marknelson.us/2006/07/">
	<LINK rel="archives" title="June 2006" href="http://marknelson.us/2006/06/">
	<LINK rel="archives" title="October 2005" href="http://marknelson.us/2005/10/">
	<LINK rel="archives" title="February 2004" href="http://marknelson.us/2004/02/">
	<LINK rel="archives" title="October 2002" href="http://marknelson.us/2002/10/">
	<LINK rel="archives" title="August 2002" href="http://marknelson.us/2002/08/">
	<LINK rel="archives" title="July 2002" href="http://marknelson.us/2002/07/">
	<LINK rel="archives" title="April 2002" href="http://marknelson.us/2002/04/">
	<LINK rel="archives" title="March 2002" href="http://marknelson.us/2002/03/">
	<LINK rel="archives" title="January 2002" href="http://marknelson.us/2002/01/">
	<LINK rel="archives" title="September 2001" href="http://marknelson.us/2001/09/">
	<LINK rel="archives" title="June 2000" href="http://marknelson.us/2000/06/">
	<LINK rel="archives" title="January 2000" href="http://marknelson.us/2000/01/">
	<LINK rel="archives" title="March 1998" href="http://marknelson.us/1998/03/">
	<LINK rel="archives" title="December 1997" href="http://marknelson.us/1997/12/">
	<LINK rel="archives" title="September 1997" href="http://marknelson.us/1997/09/">
	<LINK rel="archives" title="January 1997" href="http://marknelson.us/1997/01/">
	<LINK rel="archives" title="September 1996" href="http://marknelson.us/1996/09/">
	<LINK rel="archives" title="August 1996" href="http://marknelson.us/1996/08/">
	<LINK rel="archives" title="January 1996" href="http://marknelson.us/1996/01/">
	<LINK rel="archives" title="May 1992" href="http://marknelson.us/1992/05/">
	<LINK rel="archives" title="February 1990" href="http://marknelson.us/1990/02/">
	<LINK rel="archives" title="October 1989" href="http://marknelson.us/1989/10/">
	<LINK rel="EditURI" type="application/rsd+xml" title="RSD" href="http://marknelson.us/xmlrpc.php?rsd">
<LINK rel="stylesheet" href="./Fast String Searching With Suffix Trees_files/syntax_hilite_css.css" type="text/css" media="all">
	<SCRIPT language="javascript" type="text/javascript" src="./Fast String Searching With Suffix Trees_files/syntax_hilite_js.js"></SCRIPT>
	<SCRIPT language="javascript" type="text/javascript">
	var arrCode = new Array();
	</SCRIPT>

</HEAD><BODY>
<DIV id="wrap_talia">
  <DIV id="container_talia">
    <DIV id="header_talia">
	  <DIV class="header_site_desc">
      <H1><A href="http://marknelson.us/">Mark Nelson</A></H1>
      <P>Programming, mostly.</P>
	  </DIV>

	  <DIV class="header_nav_box">
	    <DIV id="searchform">
		<FORM method="get" action="http://marknelson.us/index.php">
		<P>
        <INPUT name="submit" type="image" src="./Fast String Searching With Suffix Trees_files/search_button.gif" alt="search">
        </P>
		<P><INPUT name="s" type="text" class="src_field" value=""></P>
		</FORM>
		</DIV>
<DIV class="navigators">
       <UL>
<LI><A href="http://marknelson.us/">Home</A></LI>
<LI class="page_item"><A href="http://marknelson.us/about/" title="About Mark Nelson">About Mark Nelson</A></LI>
<LI class="page_item"><A href="http://marknelson.us/archives/" title="Archives">Archives</A></LI>
<LI class="page_item"><A href="http://marknelson.us/code-use-policy/" title="Liberal Code Use Policy">Liberal Code Use Policy</A></LI>
		</UL>
		</DIV>

	  </DIV>

    </DIV><DIV id="content_talia">
<DIV class="right-content-talia">
<DIV id="left-post">
<DIV id="put-image-here"></DIV>

<DIV id="post-entry">



<DIV class="post-meta" id="post-80">
<H1><A href="./Fast String Searching With Suffix Trees_files/Fast String Searching With Suffix Trees.htm" title="Fast String Searching With Suffix Trees">Fast String Searching With Suffix Trees</A></H1>

	
	<HR>

	
	<DIV class="navigation">
		<DIV class="alignleft"><SPAN>«</SPAN> <A href="http://marknelson.us/1996/01/01/priority-queues/">Priority Queues and the STL</A></DIV>
		<DIV class="alignright"> <A href="http://marknelson.us/1996/09/01/bwt/">Data Compression with the Burrows-Wheeler Transform</A> <SPAN>»</SPAN></DIV>
	</DIV>

	
	<BR>
	<HR>

<DIV class="posted-aut-cat">Posted in August 1st, 1996 </DIV>

<DIV class="posted-aut-cat">by <A href="http://marknelson.us/author/mark/" title="Posts by Mark">Mark</A> in <A href="http://marknelson.us/category/computer-science/" title="View all posts in Computer Science" rel="category tag">Computer Science</A>,  <A href="http://marknelson.us/category/data-compression/" title="View all posts in Data Compression" rel="category tag">Data Compression</A>,  <A href="http://marknelson.us/category/magazine-articles/" title="View all posts in Magazine Articles" rel="category tag">Magazine Articles</A></DIV>

<DIV class="post-content">




<P></P><TABLE border="0">
<TBODY><TR>
<!--</p>
<td style="width: 33%"><img alt="DDJ Cover from August, 1996" id="image32" src="http://marknelson.us/attachments/1996/suffix-trees/cover.gif" /></td>
<p>-->
<TD style="width: 66%">Published in <A href="http://ddj.com/">Dr. Dobb's Journal</A> August, 1996<BR>
</TD></TR>
</TBODY></TABLE>
<P><EM>I think that I shall never see<BR>
A poem lovely as a tree.<BR>
Poems are made by fools like me,<BR>
But only God can make a tree.</EM><BR>
- <STRONG>Joyce Kilmer </STRONG></P>
<P><EM>A tree's a tree. How many more do you need to look at?</EM><BR>
-<STRONG>Ronald Reagan </STRONG></P>
<HR>
<H4>The problem</H4>
<P>Matching string sequences is a problem that computer programmers face on a regular basis. Some programming tasks, such as data compression or DNA sequencing, can benefit enormously from improvements in string matching algorithms. This article discusses a relatively unknown data structure, the <EM>suffix tree</EM>, and shows how its characteristics can be used to attack difficult string matching problems.</P>
<P>Imagine that you've just been hired as a programmer working on a DNA sequencing project. Researchers are busy slicing and dicing viral genetic material, producing fragmented sequences of nucleotides. They send these sequences to your server, which is then expected to locate the sequences in a database of genomes. The genome for a given virus can have hundreds of thousands of nucleotide bases, and you have hundreds of viruses in your database. You are expected to implement this as a client/server project that gives real-time feedback to the impatient Ph.D.s. What's the best way to go about it?</P>
<P>It is obvious at this point that a brute force string search is going to be terribly inefficient. This type of search would require you to perform a string comparison at every single nucleotide in every genome in your database. Testing a long fragment that has a high hit rate of partial matches would make your client/server system look like an antique batch processing machine. Your challenge is to come up with an efficient string matching solution. </P>
<H4>The intuitive solution</H4>
<P>Since the database that you are testing against is invariant, preprocessing it to simplify the search seems like a good idea. One preprocessing approach is to build a search trie. For searching through input text, a straightforward approach to a search trie yields a thing called a <EM>suffix trie</EM>. (The suffix trie is just one step away from my final destination, the <EM>suffix tree</EM>.) A trie is a type of tree that has N possible branches from each node, where N is the number of characters in the alphabet. The word 'suffix' is used in this case to refer to the fact that the trie contains all of the suffixes of a given block of text (perhaps a viral genome.)</P>
<P></P><CENTER><BR>
<IMG src="./Fast String Searching With Suffix Trees_files/FIGURE1.gif"><BR>
Figure 1<BR>
The Suffix Trie Representing "BANANAS"<BR>
</CENTER><P></P>
<P>Figure 1 shows a Suffix trie for the word BANANAS. There are two important facts to note about this trie. First, starting at the root node, each of the suffixes of BANANAS is found in the trie, starting with BANANAS, ANANAS, NANAS, and finishing up with a solitary S. Second, because of this organization, you can search for any substring of the word by starting at the root and following matches down the tree until exhausted.</P>
<P>The second point is what makes the suffix trie such a nice construct. If you have a input text of length <EM>N</EM>, and a search string of length <EM>M</EM>, a traiditonal brute force search will take as many as <EM>N*M</EM> character comparison to complete. Optimized searching techniques, such as the Boyer-Moore algorithm can guarantee searches that require no more than <EM>M+N</EM> comparisons, with even better average performance. But the suffix trie demolishes this performance by requiring just <EM>M</EM> character comparisons, regardless of the length of the text being searched!</P>
<P>Remarkable as this might seem, it means I could determine if the word BANANAS was in the collected works of William Shakespeare by performing just seven character comparisons. Of course, there is just one little catch: the time needed to construct the trie.</P>
<P>The reason you don't hear much about the use of suffix tries is the simple fact that constructing one requires <EM>O(N<SUP>2</SUP>)</EM> time and space. This quadratic performance rules out the use of suffix tries where they are needed most: to search through long blocks of data. </P>
<H4>Under the spreading suffix tree</H4>
<P>A reasonable way past this dilemma was proposed by Edward McCreight in 1976, when he published his paper on what came to be known as the <EM>suffix tree</EM>. The suffix tree for a given block of data retains the same topology as the suffix trie, but it eliminates nodes that have only a single descendant. This process, known as path compression, means that individual edges in the tree now may represent sequences of text instead of single characters. </P>
<P></P><CENTER><BR>
<IMG src="./Fast String Searching With Suffix Trees_files/FIGURE2.gif"><BR>
Figure 2<BR>
The Suffix Trie Representing "BANANAS"<BR>
</CENTER><P></P>
<P>Figure 2 shows what the suffix trie from Figure 1 looks like when converted to a suffix tree. You can see that the tree still has the same general shape, just far fewer nodes. By eliminating every node with just a single descendant, the count is reduced from 23 to 11.</P>
<P>In fact, the reduction in the number of nodes is such that the time and space requirements for constructing a suffix tree are reduced from O(N<SUP>2</SUP>) to O(N). In the worst case, a suffix tree can be built with a maximum of 2N nodes, where N is the length of the input text. So for a one-time investment proportional to the length of the input text, we can create a tree that turbocharges our string searches. </P>
<P>Even you can make a tree</P>
<P>McCreight's original algorithm for constructing a suffix tree had a few disadvantages. Principle among them was the requirement that the tree be built in reverse order, meaning characters were added from the end of the input. This ruled the algorithm out for on line processing, making it much more difficult to use for applications such as data compression.</P>
<P>Twenty years later, Esko Ukkonen from the University of Helsinki came to the rescue with a slightly modified version of the algorithm that works from left to right. Both my sample code and the descriptions that follow are based on Ukkonen's work, published in the September 1995 issue of Algorithmica.</P>
<P>For a given string of text, T, Ukkonen's algorithm starts with an empty tree, then progressively adds each of the N prefixes of T to the suffix tree. For example, when creating the suffix tree for BANANAS, B is inserted into the tree, then BA, then BAN, and so on. When BANANAS is finally inserted, the tree is complete. </P>
<P></P><CENTER><BR>
<IMG src="./Fast String Searching With Suffix Trees_files/FIGURE3.gif"><BR>
Figure 3<BR>
Progressively Building the Suffix Tree<BR>
</CENTER><P></P>
<H4>Suffix tree mechanics</H4>
<P>Adding a new prefix to the tree is done by walking through the tree and visiting each of the suffixes of the current tree. We start at the longest suffix (BAN in Figure 3), and work our way down to the shortest suffix, which is the empty string. Each suffix ends at a node that consists of one of these three types:</P>
<UL>
<LI>A leaf node. In Figure 4, the nodes labeled 1,2, 4, and 5 are leaf nodes.</LI>
<LI>An explicit node. The non-leaf nodes that are labeled 0 and 3 in Figure 4 are explicit nodes. They represent a point on the tree where two or more edges part ways.
</LI>
<LI>An implicit node. In Figure 4, prefixes such as BO, BOO, and OO all end in the middle of an edge. These positions are referred to as <EM>implicit </EM>nodes. They would represent nodes in the suffix trie, but path compression eliminated them. As the tree is built, implicit nodes are sometimes converted to explicit nodes.
</LI>
</UL>
<P></P><CENTER><BR>
<IMG src="./Fast String Searching With Suffix Trees_files/FIGURE4.gif"><BR>
Figure 4<BR>
BOOKKEEPER after adding BOOK<BR>
</CENTER><P></P>
<P>In Figure 4, there are five suffixes in the tree (including the empty string) after adding BOOK to the structure. Adding the next prefix, BOOKK to the tree means visiting each of the suffixes in the existing tree, and adding letter K to the end of the suffix.</P>
<P>The first four suffixes, BOOK, OOK, OK, and K, all end at leaf nodes. Because of the path compression applied to suffix trees, adding a new character to a leaf node will always just add to the string on that node. It will never create a new node, regardless of the letter being added.</P>
<P>After all of the leaf nodes have been updated, we still need to add character 'K' to the empty string, which is found at node 0. Since there is already an edge leaving node 0 that starts with letter K, we don't have to do anything. The newly added suffix K will be found at node 0, and will end at the implicit node found one character down along the edge leading to node 2.</P>
<P>The final shape of the resulting tree is shown in Figure 5. </P>
<P></P><CENTER><BR>
<IMG src="./Fast String Searching With Suffix Trees_files/FIGURE5.gif"><BR>
Figure 5<BR>
The same tree after adding BOOKK<BR>
</CENTER><P></P>
<H4>Things get knotty</H4>
<P>Updating the tree in Figure 4 was relatively easy. We performed two types of updates: the first was simply the extension of an edge, and the second was an implicit update, which involved no work at all. Adding BOOKKE to the tree shown in Figure 5 will demonstrate the two other types of updates. In the first type, a new node is created to split an existing edge at an implicit node, followed by the addition of a new edge. The second type of update consists of adding a new edge to an explicit node. </P>
<P></P><CENTER><BR>
<IMG src="./Fast String Searching With Suffix Trees_files/FIGURE6.gif"><BR>
Figure 6<BR>
The Split and Add Update<BR>
</CENTER><P></P>
<P>When adding BOOKKE to the tree in Figure 5, we once again start with the longest suffix, BOOKK, and work our way to the shortest, the empty string. Updating the longer suffixes is trivial as long as we are updating leaf nodes. In Figure 5, the suffixes that end in leaf nodes are BOOKK, OOKK, OKK, and KK. The first tree in Figure 6 shows what the tree looks like after these suffixes have been updated using the simple string extension.</P>
<P>The first suffix in Figure 5 that doesn't terminate at a leaf node is K. When updating a suffix tree, the first non-leaf node is defined as the active point of the tree. All of the suffixes that are longer than the suffix defined by the active point will end in leaf nodes. None of the suffixes after this point will terminate in leaf nodes.</P>
<P>The suffix K terminates in an implicit node part way down the edge defined by KKE. When testing non-leaf nodes, we need to see if they have any descendants that match the new character being appended. In this case, that would be E.</P>
<P>A quick look at the first K in KKE shows that it only has a single descendant: K. So this means we have to add a descendent to represent Letter E. This is a two step process. First, we split the edge holding the arc so that it has an explicit node at the end of the suffix being tested. The middle tree in Figure 6 shows what the tree looks like after the split.</P>
<P>Once the edge has been split, and the new node has been added, you have a tree that looks like that in the third position of Figure 6. Note that the K node, which has now grown to be KE, has become a leaf node. </P>
<H4>Updating an explicit node</H4>
<P>After updating suffix K, we still have to update the next shorter suffix, which is the empty string. The empty string ends at explicit node 0, so we just have to check to see if it has a descendant that starts with letter E. A quick look at the tree in Figure 6 shows that node 0 doesn't have a descendant, so another leaf node is added, which yields the tree shown in Figure 7. </P>
<P></P><CENTER><BR>
<IMG src="./Fast String Searching With Suffix Trees_files/FIGURE7.gif"><BR>
Figure 7<BR>
</CENTER><P></P>
<H4>Generalizing the algorithm</H4>
<P>By taking advantage of a few of the characteristics of the suffix tree, we can generate a fairly efficient algorithm. The first important trait is this: once a leaf node, always a leaf node. Any node that we create as a leaf will never be given a descendant, it will only be extended through character concatenation. More importantly, every time we add a new suffix to the tree, we are going to automatically extend the edges leading into every leaf node by a single character. That character will be the last character in the new suffix.</P>
<P>This makes management of the edges leading into leaf nodes easy. Any time we create a new leaf node, we automatically set its edge to represent all the characters from its starting point to the end of the input text. Even if we don't know what those characters are, we know they will be added to the tree eventually. Because of this, once a leaf node is created, we can just forget about it! If the edge is split, its starting point may change, but it will still extend all the way to the end of the input text.</P>
<P>This means that we only have to worry about updating explicit and implicit nodes at the active point, which was the first non-leaf node. Given this, we would have to progress from the active point to the empty string, testing each node for update eligibility.</P>
<P>However, we can save some time by stopping our update earlier. As we walk through the suffixes, we will add a new edge to each node that doesn't have a descendant edge starting with the correct character. When we finally do reach a node that has the correct character as a descendant, we can simply stop updating. Knowing how the construction algorithm works, you can see that if you find a certain character as a descendant of a particular suffix, you are bound to also find it as a descendant of every smaller suffix.</P>
<P>The point where you find the first matching descendant is called the end point. The end point has an additional feature that makes it particularly useful. Since we were adding leaves to every suffix between the active point and the end point, we now know that every suffix longer than the end point is a leaf node. This means the end point will turn into the active point on the next pass over the tree!</P>
<P>By confining our updates to the suffixes between the active point and the end point, we cut way back on the processing required to update the tree. And by keeping track of the end point, we automatically know what the active point will be on the next pass. A first pass at the update algorithm using this information might look something like this (in C-like pseudo code) : </P>
<DIV class="igBar"><SPAN id="lc-1"><A href="http://marknelson.us/1996/08/01/suffix-trees/#" onclick="javascript:showPlainTxt(&#39;c-1&#39;); return false;">PLAIN TEXT</A></SPAN></DIV>
<DIV class="syntax_hilite"><SPAN class="langName">C:</SPAN>
<DIV id="c-1">
<DIV class="c">
<OL>
<LI class="li1">
<DIV class="de1">Update<SPAN class="br0">(</SPAN> new_suffix <SPAN class="br0">)</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2"><SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; current_suffix = active_point</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; test_char = last_char in new_suffix</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; done = <SPAN class="kw2">false</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; <SPAN class="kw1">while</SPAN> <SPAN class="br0">(</SPAN> !done <SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; <SPAN class="kw1">if</SPAN> current_suffix ends at an explicit node <SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; <SPAN class="kw1">if</SPAN> the node has no descendant edge starting with test_char </DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; create new leaf edge starting at the explicit node</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; <SPAN class="kw1">else</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; done = <SPAN class="kw2">true</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; <SPAN class="br0">}</SPAN> <SPAN class="kw1">else</SPAN> <SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; <SPAN class="kw1">if</SPAN> the implicit node<SPAN class="st0">'s next char isn'</SPAN>t test_char <SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; split the edge at the implicit node</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; create new leaf edge starting at the split in the edge</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; <SPAN class="br0">}</SPAN> <SPAN class="kw1">else</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; done = <SPAN class="kw2">true</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; <SPAN class="br0">}</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; <SPAN class="kw1">if</SPAN> current_suffix is the empty <SPAN class="kw4">string</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; done = <SPAN class="kw2">true</SPAN>; </DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; <SPAN class="kw1">else</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp;current_suffix = next_smaller_suffix<SPAN class="br0">(</SPAN> current_suffix <SPAN class="br0">)</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; <SPAN class="br0">}</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; active_point = current_suffix</DIV>
</LI>
<LI class="li1">
<DIV class="de1"><SPAN class="br0">}</SPAN> </DIV>
</LI>
</OL>
</DIV>
</DIV>
</DIV>
<P></P>
<H4>The Suffix Pointer</H4>
<P>The pseudo-code algorithm shown above is more or less accurate, but it glosses over one difficulty. As we are navigating through the tree, we move to the next smaller suffix via a call to <SPAN class="inline_code">next_smaller_suffix()</SPAN>. This routine has to find the implicit or explicit node corresponding to a particular suffix.</P>
<P>If we do this by simply walking down the tree until we find the correct node, our algorithm isn't going to run in linear time. To get around this, we have to add one additional pointer to the tree: the <EM>suffix pointer</EM>. The suffix pointer is a pointer found at each internal node. Each internal node represents a sequence of characters that start at the root. The suffix pointer points to the node that is the first suffix of that string. So if a particular string contains characters 0 through N of the input text, the suffix pointer for that string will point to the node that is the termination point for the string starting at the root that represents characters 1 through N of the input text.</P>
<P>Figure 8 shows the suffix tree for the string ABABABC. The first suffix pointer is found at the node that represents ABAB. The first suffix of that string would be BAB, and that is where the suffix pointer at ABAB points. Likewise, BAB has its own suffix pointer, which points to the node for AB. </P>
<P></P><CENTER><BR>
<IMG src="./Fast String Searching With Suffix Trees_files/FIGURE8.gif"><BR>
Figure 7<BR>
The suffix tree for ABABABC with suffix pointers shown as dashed lines<BR>
</CENTER><P></P>
<P>The suffix pointers are built at the same time the update to the tree is taking place. As I move from the active point to the end point, I keep track of the parent node of each of the new leaves I create. Each time I create a new edge, I also create a suffix pointer from the parent node of the <EM>last </EM>leaf edge I created to the <EM>current </EM>parent edge. (Obviously, I can't do this for the first edge created in the update, but I do for all the remaining edges.)</P>
<P>With the suffix pointers in place, navigating from one suffix to the next is simply a matter of following a pointer. This critical addition to the algorithm is what reduces it to an O(N) algorithm. </P>
<H4>Tree houses</H4>
<P>To help illustrate this article, I wrote a short program, STREE.CPP, that reads in a string of text from standard input and builds a suffix tree using fully documented C++. A second version, STREED.CPP, has extensive debug output as well. Links to both are available at the bottom of this article.</P>
<P>Understanding STREE.CPP is really just a matter of understanding the workings of the data structures that it contains. The most important data structure is the <SPAN class="inline_code">Edge</SPAN> object. The class definition for <SPAN class="inline_code">Edge</SPAN> is: </P>
<DIV class="igBar"><SPAN id="lcpp-2"><A href="http://marknelson.us/1996/08/01/suffix-trees/#" onclick="javascript:showPlainTxt(&#39;cpp-2&#39;); return false;">PLAIN TEXT</A></SPAN></DIV>
<DIV class="syntax_hilite"><SPAN class="langName">C++:</SPAN>
<DIV id="cpp-2">
<DIV class="cpp">
<OL>
<LI class="li1">
<DIV class="de1">class Edge <SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; <SPAN class="kw2">public</SPAN> :</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">int</SPAN> first_char_index;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">int</SPAN> last_char_index;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">int</SPAN> end_node;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">int</SPAN> start_node;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">void</SPAN> Insert<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">void</SPAN> <SPAN class="kw3">Remove</SPAN><SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN>;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; Edge<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; Edge<SPAN class="br0">(</SPAN> <SPAN class="kw4">int</SPAN> init_first_char_index,</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">int</SPAN> init_last_char_index,</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">int</SPAN> parent_node <SPAN class="br0">)</SPAN>;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">int</SPAN> SplitEdge<SPAN class="br0">(</SPAN> Suffix &amp;s <SPAN class="br0">)</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">static</SPAN> Edge Find<SPAN class="br0">(</SPAN> <SPAN class="kw4">int</SPAN> node, <SPAN class="kw4">int</SPAN> c <SPAN class="br0">)</SPAN>;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">static</SPAN> <SPAN class="kw4">int</SPAN> Hash<SPAN class="br0">(</SPAN> <SPAN class="kw4">int</SPAN> node, <SPAN class="kw4">int</SPAN> c <SPAN class="br0">)</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2"><SPAN class="br0">}</SPAN>; </DIV>
</LI>
</OL>
</DIV>
</DIV>
</DIV>
<P></P>
<P>Each time a new edge in the suffix tree is created, a new Edge object is created to represent it. The four data members of the object are defined as follows:</P>
<DL>
<DT><SPAN class="inline_code">first_char_index</SPAN>, <SPAN class="inline_code">last_char_index</SPAN>:</DT>
<DD>Each of the edges in the tree has a sequence of characters from the input text associated with it. To ensure that the storage size of each edge is identical, we just store two indices into the input text to represent the sequence.</DD>
<DT><SPAN class="inline_code">start_node</SPAN>:</DT>
<DD>The number of the node that represents the starting node for this edge. Node 0 is the root of the tree.</DD>
<DT><SPAN class="inline_code">end_node</SPAN>:</DT>
<DD>The number of the node that represents the end node for this edge. Each time an edge is created, a new end node is created as well. The end node for every edge will not change over the life of the tree, so this can be used as an edge id as well.</DD>
</DL>
<P>One of the most frequent tasks performed when building the suffix tree is to search for the edge emanating from a particular node based on the first character in its sequence. On a byte oriented computer, there could be as many as 256 edges originating at a single node. To make the search reasonably quick and easy, I store the edges in a hash table, using a hash key based on their starting node number and the first character of their substring. The <SPAN class="inline_code">Insert()</SPAN> and <SPAN class="inline_code">Remove()</SPAN> member functions are used to manage the transfer of edges in and out of the hash table.</P>
<P>The second important data structure used when building the suffix tree is the <SPAN class="inline_code">Suffix </SPAN>object. Remember that updating the tree is done by working through all of the suffixes of the string currently stored in the tree, starting with the longest, and ending at the end point. A <SPAN class="inline_code">Suffix</SPAN> is simply a sequence of characters that starts at node 0 and ends at some point in the tree.</P>
<P>It makes sense that we can then safely represent any suffix by defining just the position in the tree of its last character, since we know the first character starts at node 0, the root. The <SPAN class="inline_code">Suffix </SPAN>object, whose definition is shown here, defines a given suffix using that system: </P>
<DIV class="igBar"><SPAN id="lcpp-3"><A href="http://marknelson.us/1996/08/01/suffix-trees/#" onclick="javascript:showPlainTxt(&#39;cpp-3&#39;); return false;">PLAIN TEXT</A></SPAN></DIV>
<DIV class="syntax_hilite"><SPAN class="langName">C++:</SPAN>
<DIV id="cpp-3">
<DIV class="cpp">
<OL>
<LI class="li1">
<DIV class="de1">class Suffix <SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; <SPAN class="kw2">public</SPAN> :</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">int</SPAN> origin_node;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">int</SPAN> first_char_index;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">int</SPAN> last_char_index;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; Suffix<SPAN class="br0">(</SPAN> <SPAN class="kw4">int</SPAN> node, <SPAN class="kw4">int</SPAN> start, <SPAN class="kw4">int</SPAN> stop <SPAN class="br0">)</SPAN>;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">int</SPAN> <SPAN class="kw2">Explicit</SPAN><SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">int</SPAN> Implicit<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN>;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw4">void</SPAN> Canonize<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2"><SPAN class="br0">}</SPAN>; </DIV>
</LI>
</OL>
</DIV>
</DIV>
</DIV>
<P></P>
<P>The <SPAN class="inline_code">Suffix </SPAN>object defines the last character in a string by starting at a specific node, then following the string of characters in the input sequence pointed to by the first_char_index and last_char_index members. For example, in Figure 8, the longest suffix "ABABABC" would have an origin_node of 0, a first_char_index of 0, and a last_char_index of 6.</P>
<P>Ukkonen's algorithm requires that we work with these <SPAN class="inline_code">Suffix</SPAN> definitions in <EM>canonical </EM>form. The <SPAN class="inline_code">Canonize()</SPAN> function is called to perform this transformation any time a <SPAN class="inline_code">Suffix</SPAN> object is modified. The canonical representation of the suffix simply requires that the origin_node in the <SPAN class="inline_code">Suffix</SPAN> object be the closest parent to the end point of the string. This means that the suffix string represented by the pair (0, "ABABABC"), would be canonized by moving first to (1, "ABABC"), then (4, "ABC"), and finally (8,"").</P>
<P>When a suffix string ends on an explicit node, the canonical representation will use an empty string to define the remaining characters in the string. An empty string is defined by setting first_char_index to be greater than last_char_index. When this is the case, we know that the suffix ends on an <EM>explicit </EM>node. If first_char_index is less than or equal to last_char_index, it means that the suffix string ends on an <EM>implicit </EM>node.</P>
<P>Given these data structure definitions, I think you will find the code in STREE.CPP to be a straightforward implementation of the Ukkonen algorithm. For additional clarity, use STREED.CPP to dump copious debug information out at runtime. </P>
<H4>Acknowledgments</H4>
<P>I was finally convinced to tackle suffix tree construction by reading Jesper Larsson's paper for the 1996 IEEE Data Compression Conference. Jesper was also kind enough to provide me with sample code and pointers to Ukkonen's paper. </P>
<H4>References</H4>
<P>E.M. McCreight. <A href="http://portal.acm.org/citation.cfm?id=321946&dl=">A space-economical suffix tree construction algorithm</A>. Journal of the ACM, 23:262-272, 1976.</P>
<P>E. Ukkonen. <A href="http://www.springerlink.com/content/kq55005qu6479276/">On-line construction of suffix trees</A>. Algorithmica, 14(3):249-260, September 1995. </P>
<H4>Source Code</H4>
<P>Good news - this source code has been updated. It was originally published in 1996, pre-standard, and needed just a few nips and tucks to work properly in today's world. These new versions of the code should be pretty portable - the build properly with g++ 3.x, 4.x and Visual C++ 2003.</P>
<DL>
<DT><A href="http://marknelson.us/attachments/1996/suffix-trees/stree2006.cpp">stree2006.cpp</A></DT>
<DD>A simple program that builds a suffix tree from an input string.</DD>
<DT><A href="http://marknelson.us/attachments/1996/suffix-trees/streed2006.cpp">streed2006.cpp</A></DT>
<DD>The same program with much debugging code added.</DD>
</DL>
<P>The original code is her for the curious, but should not be used:</P>
<DL>
<DT><A href="http://marknelson.us/attachments/1996/suffix-trees/stree.cpp">stree.cpp</A></DT>
<DD>A simple program that builds a suffix tree from an input string.</DD>
<DT><A href="http://marknelson.us/attachments/1996/suffix-trees/streed.cpp">streed.cpp</A></DT>
<DD>The same program with much debugging code added.</DD>
</DL>
</DIV>
<DIV class="post-pages">
</DIV>

</DIV>

<DIV class="post-fixed"></DIV>




<DIV id="comment-temps">
			 <H2>93 users commented in " Fast String Searching With Suffix Trees " </H2>
			<SPAN class="rssfeed">
            Follow-up <A href="http://marknelson.us/1996/08/01/suffix-trees/feed/">comment rss</A> or Leave a <A href="http://marknelson.us/1996/08/01/suffix-trees/trackback/">Trackback</A>
            </SPAN>
<DIV class="post-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">Martin said,</DIV>
			<DIV class="author_date">
            in December 5th, 2006 at 3:01 am             </DIV>
			<DIV class="author_com_text">
            <P>Nice paper but there is room for improvement.</P>
<P>1) Do use the same example throughout the text instead of using different more or less suited examples to illustrate different points - thus making it hard to follow what is going on. MISSISSIPPI would make a excellent example string.</P>
<P>2) Figure 4 already contains an explicit update which is not explained before carrying on - that is rather confusing.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in December 5th, 2006 at 6:19 am             </DIV>
			<DIV class="author_com_text">
            <P>Sigh, everyone's a critic. </P>
<P>I don't know that this article will ever see a revision, but if it does, I shall keep your comments in mind.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://www.ajvar.org/" rel="external nofollow">Calin Culianu</A> said,</DIV>
			<DIV class="author_date">
            in December 13th, 2006 at 5:45 pm             </DIV>
			<DIV class="author_com_text">
            <P>Your sample code fails to compile cleanly on newer compilers.  I guess that's because it was written back in 1996.  At any rate thanks for taking the time to explain this.  After reading your article I still don't really understand it -- and I am not sure if that's because I am too stupid your your article isn't clearly enough writte.  *Shrugs*</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in December 13th, 2006 at 8:16 pm             </DIV>
			<DIV class="author_com_text">
            <P>Hi Calin,</P>
<P>Let me know what compiler you are using, I might take a try at updating the source. </P>
<P>The big problem was that in 1996 there weren't any compilers that came anywhere near conforming to today's standard, which wasn't ratified until 1998. </P>
<P>As for understanding it, I agree that it's hard - I wrote the article because I had such a hard time with it myself. I encourage you to try to work through some of the problems by hand, then see if you can duplicate the results with the debug version of the program and see if you get the same results.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in December 26th, 2006 at 3:00 pm             </DIV>
			<DIV class="author_com_text">
            <P>Updated source code released, see the end of the article with the links!</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://www.samueljohn.de/" rel="external nofollow">Samuel</A> said,</DIV>
			<DIV class="author_date">
            in February 20th, 2007 at 2:21 pm             </DIV>
			<DIV class="author_com_text">
            <P>I'd like to say thank you.<BR>
This article and the source-code is definetly a big help in my diploma thesis where I need a suffix tree as a tool.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in February 20th, 2007 at 3:27 pm             </DIV>
			<DIV class="author_com_text">
            <P>Thanks, Samuel, nice to hear.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://www.digital-utopia.com/" rel="external nofollow">Graham Reeds</A> said,</DIV>
			<DIV class="author_date">
            in February 21st, 2007 at 3:32 am             </DIV>
			<DIV class="author_com_text">
            <P>I like your code - currently implementing the BWT algorithm with just RLE as a preprocessor for XML transfer.  </P>
<P>A couple of points:<BR>
* Make a link to this article from the BWT one - you mention suffix trees help speed up BWT compilation, but I had to go searching and found this site from Wikipedia.<BR>
* Lots of comments in the source - you tried Doxygen which would make the comments more searchable.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">tony said,</DIV>
			<DIV class="author_date">
            in February 23rd, 2007 at 4:55 pm             </DIV>
			<DIV class="author_com_text">
            <P>hey mark, how can i use your code to tell me the index of a substring in a text?</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in February 25th, 2007 at 12:22 pm             </DIV>
			<DIV class="author_com_text">
            <P>&gt;hey mark, how can i use your code to tell me the index of a substring in a text?</P>
<P>Tony, that's kind of the whole point of the article, right?</P>
<P>Use the code in walk_tree as an indication of how to navigate the tree. </P>
<P>Once you walk the tree, searching for a match to your text, you will end up at either a leaf or an interior node.</P>
<P>If you are at leaf, you have found the only occurrence of the string, and can determine where it is by looking at the members of Suffix.</P>
<P>If you are at an interior node, you have found the root of a tree that will provide all the locations of the string in the text.</P>
<P>Good exercise to write this search routine!</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in February 27th, 2007 at 6:36 am             </DIV>
			<DIV class="author_com_text">
            <P>Hi Graham,</P>
<P>Believe it or not, when I wrote this article, Doxygen didn't handle C   code very well - mostly because it didn't exist yet! </P>
<P>I don't spend too much time going back and fixing up old articles, mostly because of my belief in the inspiration words of Samuel Johnson:</P>
<P>"No man but a blockhead ever wrote, except for money."</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">Shivam said,</DIV>
			<DIV class="author_date">
            in March 2nd, 2007 at 12:28 pm             </DIV>
			<DIV class="author_com_text">
            <P>How can I find the position(s) of the search string ?? What if there are wildcharacters in the pattern, can you recommend some references ?? Thanks</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in March 2nd, 2007 at 1:23 pm             </DIV>
			<DIV class="author_com_text">
            <P>Shivam, do you realize that string searching occupies at least one chapter in virtually every algorithms book?</P>
<P>A search on Google for "string search algorithms" gets you 3.5 million hits.</P>
<P>If you can't find some decent references on this, you aren't trying very hard.</P>
<P>Sorry to be harsh, but seriously, I can help you with specific problems related to the data compression on my site, but general questions that can be easily answered, well, you need to manage yourself.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://www.cariaso.com/" rel="external nofollow">cariaso</A> said,</DIV>
			<DIV class="author_date">
            in March 15th, 2007 at 11:02 pm             </DIV>
			<DIV class="author_com_text">
            <P>Mark, while I agree with your sentiments for Shivam, I can't resist pointing out:</P>
<P>"string searching occupies at least one chapter in every single algorithms book is dedicated to string searching"</P>
<P>If a book is dedicated to string searching, it seems a bit redundant to say that string searching occupies at least one chapter. </P>
<P>This article was tremendously valuable a decade ago. Since then there have been advances, especially coming from bioinformatics. Anyone interested in the topic should investigate:</P>
<P>An updated C implementation<BR>
<A href="http://www.icir.org/christian/libstree/" rel="nofollow">http://www.icir.org/christian/libstree/</A></P>
<P>general notes<BR>
<A href="http://homepage.usask.ca/~ctl271/857/suffix_tree.shtml" rel="nofollow">http://homepage.usask.ca/~ctl271/857/suffix_tree.shtml</A></P>
<P>big strings in small memory<BR>
<A href="http://csdl2.computer.org/persagen/DLAbsToc.jsp?resourcePath=/dl/trans/tk/&toc=comp/trans/tk/2005/01/k1toc.xml&DOI=10.1109/TKDE.2005.3" rel="nofollow">http://csdl2.computer.org/persagen/DLAbsToc.jsp?resourcePath=/dl/trans/tk/&amp;toc=comp/trans/tk/2005/01/k1toc.xml&amp;DOI=10.1109/TKDE.2005.3</A></P>
<P>a pairwise bioinformatics related tool<BR>
<A href="http://mummer.sourceforge.net/" rel="nofollow">http://mummer.sourceforge.net/</A></P>
<P>a generalized bioinformatics tool<BR>
<A href="http://bibiserv.techfak.uni-bielefeld.de/mga/" rel="nofollow">http://bibiserv.techfak.uni-bielefeld.de/mga/</A></P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in March 17th, 2007 at 1:11 pm             </DIV>
			<DIV class="author_com_text">
            <P>Thanks for the excellent links and comments Michael! As for the proofreading, well, that's what comes of having no editor. i think I will violate the integrity of my blog comments by correcting it without leaving a trail.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">eNG-sIONG said,</DIV>
			<DIV class="author_date">
            in March 28th, 2007 at 1:40 am             </DIV>
			<DIV class="author_com_text">
            <P>Dear All,<BR>
  I found this, may be useful, its a Standard Template Library for Extra Large Data Sets<BR>
  implemented by Roman Dementiev that support a multiple type of container.<BR>
  Theres no suffix tree yet. :( </P>
<P>  <A href="http://stxxl.sourceforge.net/" rel="nofollow">http://stxxl.sourceforge.net/</A><BR>
Eng Siong</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">Diamante said,</DIV>
			<DIV class="author_date">
            in April 11th, 2007 at 5:31 pm             </DIV>
			<DIV class="author_com_text">
            <P>Cool</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">Ha Luong said,</DIV>
			<DIV class="author_date">
            in July 2nd, 2007 at 4:19 am             </DIV>
			<DIV class="author_com_text">
            <P>Hi Mark,<BR>
I have read your article and I couldn't understand the "active point". The active point is the first non-leaf ? (And I don't know the first non-leaf) . Could you please show me what the active point is in your figure 6 ?<BR>
Thanks so much ,<BR>
Ha Luong</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in July 2nd, 2007 at 6:55 am             </DIV>
			<DIV class="author_com_text">
            <P>Ha Luong,</P>
<P>I think my wording in that paragraph is not as good as it could be.</P>
<P>When I refer to the "first suffix that doesn't terminate in a leaf node", I am talking about the first suffix when considering the list of suffices:</P>
<P>BOOKK<BR>
OOKK<BR>
OKK<BR>
KK<BR>
K</P>
<P>Which is the list of suffixes you are now attempting to insert into the tree. Looking at Figure 5, you can see the suffix "K" terminates in the middle of the "KK" leaf node, which makes it the active point.</P>
<P>If you don't know what a non-leaf node is, you need to brush up on your data structures.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">David Hou said,</DIV>
			<DIV class="author_date">
            in July 12th, 2007 at 6:03 pm             </DIV>
			<DIV class="author_com_text">
            <P>Hi Mark, thank you for the excellent paper. It saves me from Esko Ukkonen's(that one is sooo hard, German folks are too smart .... ). </P>
<P>I still don't quite understand how the "end point" works, which is one crucial part of the whole thing. Could you kindly provide a sample to explain it more detail? thanks a lot.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in July 15th, 2007 at 7:31 am             </DIV>
			<DIV class="author_com_text">
            <P>When performing the insertion of a new string, the two most important points are the active point and the end point. </P>
<P>The active point is discussed in the response above. When inserting a string into the tree, we look at the list of suffixes we are inserting. Some of the suffixes will be added to the tree by simple addition of a new character on an existing leaf node. The first suffix that can't be added by this simple extension is used to mark the active point.</P>
<P>I'll go back to the process of adding BOOKKE to Figure 5.</P>
<P>First, BOOKKE is added through simple extension of leaf node 1.<BR>
OOKKE is added through simple extension of leaf node 5.<BR>
OKKE is added through simple extension of leaf node 4.<BR>
KKE is added through extension of leaf node 2.</P>
<P>At this point, the tree looks like the first part of figure 6. You can see that when we attempt to add "KE" to the tree, things are not so simple. There is no leaf node that terminates in "K", so we can't just extend that leaf.</P>
<P>The suffix "K" is part of the tree, but it is an implicit node that is in the middle of the "KKE" branch terminating at node 2. (Part 1 of figure 6). The active point of the tree is now that implicit "K" node on the node 2 branch. (And that is where we will perform the split operation.)</P>
<P>Once you enter into the split operation at the active node, you can walk through the pseudocode to see what the elusive endpoint is:</P>
<P>      if the implicit node's next char isn't test_char {<BR>
        split the edge at the implicit node<BR>
        create new leaf edge starting at the split in the edge<BR>
      } else<BR>
        done = true;</P>
<P>The end point is the first node where you don't have to perform a split as you add new suffixes.</P>
<P>Unfortunately I didn't include a good example showing this, so I need to add that to my to-do list.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">David Hou said,</DIV>
			<DIV class="author_date">
            in July 18th, 2007 at 11:18 am             </DIV>
			<DIV class="author_com_text">
            <P>Thank you Mark, i feel much clear now and I am trying to implement it in C#, oh... it's hard...</P>
<P>also, I found another tuition introduces Ukkonen's suffix tree and there's a demo is provide here: <A href="http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/Suffix/#demoForm" rel="nofollow">http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/Suffix/#demoForm</A> , the interesting thing is, when I run same string on your code and their code, I got different result... ... and idea about it ?</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in July 22nd, 2007 at 2:13 pm             </DIV>
			<DIV class="author_com_text">
            <P>Well, if you could show me a short demo string that comes up with different results for the two programs, I'd certainly be interested in seeing it!</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">arao said,</DIV>
			<DIV class="author_date">
            in July 23rd, 2007 at 7:30 pm             </DIV>
			<DIV class="author_com_text">
            <P>the book by Prof. Dan Gusfield is a very good one on this.</P>
<P>and Esko Ukkonen is a German?? I thought he was from Finland...</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">Abhey Shah said,</DIV>
			<DIV class="author_date">
            in July 30th, 2007 at 3:19 pm             </DIV>
			<DIV class="author_com_text">
            <P>On the Mac I found I needed to recast T[i] into chars before printing, or it would just give me numbers.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in July 30th, 2007 at 5:15 pm             </DIV>
			<DIV class="author_com_text">
            <P>That seems kind of strange - T is typed as char. Casting at as a char should have no effect. Perhaps your compiler is using unsigned chars as default?</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">Abhey Shah said,</DIV>
			<DIV class="author_date">
            in August 1st, 2007 at 9:45 am             </DIV>
			<DIV class="author_com_text">
            <P>I tried  gcc3.3 on linux as well as gcc4.0 on the mac, same thing, that was just doing g   -lstdc   streed2006.cpp.<BR>
Anyway, if anybody else runs into the same thing sed 's/streed2007.cpp</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">Abhey Shah said,</DIV>
			<DIV class="author_date">
            in August 1st, 2007 at 9:48 am             </DIV>
			<DIV class="author_com_text">
            <P>and of course the command lines get f***ed: got to love web 2.0.  anyway I'm sure if anybody runs into the same thing they'll be able to piece together the edit commands.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">Amit P said,</DIV>
			<DIV class="author_date">
            in August 27th, 2007 at 5:07 am             </DIV>
			<DIV class="author_com_text">
            <P>i have been looking at the updated code and need to adapt it to take many different input strings and not just the one, i tried creating a loop for active and having each loop hold a different string however this has still not worked any ideas would be appreciated.</P>
<P>thanks</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">Amit P said,</DIV>
			<DIV class="author_date">
            in August 28th, 2007 at 11:18 am             </DIV>
			<DIV class="author_com_text">
            <P>i added another line of input for T after addprefix loop, after the add input had the program recalculate N and added the for loop underneath, i will now try to write code that will input multiple strings from a loop. this did allow me to enter multiple strings into the same suffix tree.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">Adam said,</DIV>
			<DIV class="author_date">
            in September 4th, 2007 at 7:13 am             </DIV>
			<DIV class="author_com_text">
            <P>I see that IBM's Many-eyes data visualization community just put up a new visualization type called a Word tree (visual suffix tree).</P>
<P><A href="http://services.alphaworks.ibm.com/manyeyes/page/Word_Tree.html" rel="nofollow">http://services.alphaworks.ibm.com/manyeyes/page/Word_Tree.html</A></P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in September 4th, 2007 at 7:49 am             </DIV>
			<DIV class="author_com_text">
            <P>That looks like a very nice visualization tool, it gives a nice understanding of how a suffix tree actually works.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://isdr.net/" rel="external nofollow">Scott</A> said,</DIV>
			<DIV class="author_date">
            in September 17th, 2007 at 4:01 pm             </DIV>
			<DIV class="author_com_text">
            <P>&gt;&gt; On the Mac I found I needed to recast<BR>
&gt;&gt; T[i] into chars before printing, or it<BR>
&gt;&gt; would just give me numbers.<BR>
&gt;<BR>
&gt; That seems kind of strange - T is typed<BR>
&gt; as char. Casting at as a char should<BR>
&gt; have no effect. Perhaps your compiler is<BR>
&gt; using unsigned chars as default?</P>
<P>I noticed the same issue with Visual C++ 2005. I believe the 'problem' was that overload resolution was finding the operator int() cast method in the Aux class, and was using that to cast to int and thus calling operator</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://isdr.net/" rel="external nofollow">Scott</A> said,</DIV>
			<DIV class="author_date">
            in September 17th, 2007 at 4:03 pm             </DIV>
			<DIV class="author_com_text">
            <P>Yuck, my post got mangled due to embedded less-than characters. Anyway, the overloaded int cast in the Aux class was preventing the Aux output method from being called.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">till said,</DIV>
			<DIV class="author_date">
            in October 12th, 2007 at 2:33 am             </DIV>
			<DIV class="author_com_text">
            <P>Enter string: aa<BR>
 Start  End  Suf  First Last  String<BR>
    0     1  -1     0      1  aa<BR>
Would you like to validate the tree?y<BR>
Suffix : aa<BR>
comparing: aa to aa<BR>
Suffix 0 count wrong!<BR>
Leaf count : 1 Error!<BR>
Branch count : 1 OK</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in October 12th, 2007 at 9:19 am             </DIV>
			<DIV class="author_com_text">
            <P>@till:</P>
<P>I suspect this is a corner case for n=2. You agree?</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">Rock Linker said,</DIV>
			<DIV class="author_date">
            in November 7th, 2007 at 2:19 am             </DIV>
			<DIV class="author_com_text">
            <P>hi mark</P>
<P>appreciate for your sharing! Thank you so much!</P>
<P>btw: in your article, there is an conception "end point", in your former response you also explained that, however, I still have some questions about that. According to your explaination, "end point" is the first node that need not to be splited, but you know, end point is shorter than the active point, and active point must be splited, how can an "end point" node exist in the suffix tree? I am a little confused. Thank you! wait for your kindly response. Thanks a lot!</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in November 7th, 2007 at 12:21 pm             </DIV>
			<DIV class="author_com_text">
            <P>If we order the suffixes of a string in decreasing length:</P>
<P>Rock<BR>
ock<BR>
ck<BR>
k</P>
<P>The active point will be the first of these suffixes which does not terminate on a leaf node.</P>
<P>And like I said in the article, every suffix longer than the suffix at the active point terminates in a leaf. Every suffix short than the suffix at the active point does not.</P>
<P>As you are updating the suffix tree, you know you have reached the end point when an element in the suffix tree has the same descendant as the string you need to add at that point.</P>
<P>I don't know that there is a relationship between the end point and the active point. You seem to think there is some relationship between the end point and the active point, and I don't think that is true.</P>
<P>I suggest that in order to understand this, you just run through a few examples of moderate length to watch the active point, the end point, and the tree change in response to the addition of new suffixes.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">Bryan said,</DIV>
			<DIV class="author_date">
            in November 15th, 2007 at 1:53 am             </DIV>
			<DIV class="author_com_text">
            <P>I still don´t understand the linear time thing.<BR>
Every time we add a new character we need to go through all the suffix pointers. That means that the time spent in every step depemds on how many suffix pointers are. And the number of suffix pointers is variable.<BR>
If I am wrong, please explain me, because I don´t undertand.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in November 15th, 2007 at 7:07 am             </DIV>
			<DIV class="author_com_text">
            

<P>@Bryan:</P>
<P>Hi Bryan,</P>
<P>The place where you are off base is here:</P>
<P>&gt;Every time we add a new character we need to<BR>
&gt;go through all the suffix pointers.</P>
<P>If you look at either the pseudocode or the actual code, you'll see that we don't go through all the pointers, and that is what makes the algorithm efficient.</P>
<P>When it comes time to insert a new character, we start work at the active point:</P>
<DIV class="igBar"><SPAN id="lcpp-4"><A href="http://marknelson.us/1996/08/01/suffix-trees/#" onclick="javascript:showPlainTxt(&#39;cpp-4&#39;); return false;">PLAIN TEXT</A></SPAN></DIV>
<DIV class="syntax_hilite"><SPAN class="langName">C++:</SPAN>
<DIV id="cpp-4">
<DIV class="cpp">
<OL>
<LI class="li1">
<DIV class="de1">Update<SPAN class="br0">(</SPAN> new_suffix <SPAN class="br0">)</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2"><SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; current_suffix = active_point</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; test_char = last_char in new_suffix</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; done = <SPAN class="kw2">false</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; <SPAN class="kw1">while</SPAN> <SPAN class="br0">(</SPAN> !done <SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; <SPAN class="kw1">if</SPAN> current_suffix ends at an <SPAN class="kw2">explicit</SPAN> node <SPAN class="br0">{</SPAN> </DIV>
</LI>
</OL>
</DIV>
</DIV>
</DIV>
<P>
Because we keep track of the active point, we know in advance where the next search is going to start, so we most definitely do not search through all the suffix pointers in order to insert a new suffix.</P>
<P>Try working through some insertions by hand and you'll see how it works more clearly.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">Bryan said,</DIV>
			<DIV class="author_date">
            in November 21st, 2007 at 2:03 am             </DIV>
			<DIV class="author_com_text">
            <P>Hi Mark:</P>
<P>   Thank you for your soon reply. I´m going to try the insertions by hand.  My doubt was more focused on how many times the while will be executed in the worst case. I´m going to check the article again and I hope I´ll get a better understanding of the algorithm.</P>
<P>Thank you for taking the time to read and reply.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">Bryan said,</DIV>
			<DIV class="author_date">
            in November 26th, 2007 at 6:47 pm             </DIV>
			<DIV class="author_com_text">
            <P>Hi Mark:</P>
<P>   I´ve seen the light. At the end, the while has been executed as many times as branches are in the tree. And since the amount of branches is equal to the amount of leafs, the time remains linear.</P>
<P>Thank you for your time.</P>
<P>Bytes</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">Tim Rowe said,</DIV>
			<DIV class="author_date">
            in November 29th, 2007 at 11:03 am             </DIV>
			<DIV class="author_com_text">
            <P>Many thanks for the clearest explanation of the algorithm that I've managed to find so far! I'm still struggling a little to understand it, but I think that's because it's genuinely tricky (or I'm genuinely thick) rather than any problems with the explanation. Off to try some examples on paper.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">Tim Rowe said,</DIV>
			<DIV class="author_date">
            in November 30th, 2007 at 8:43 am             </DIV>
			<DIV class="author_com_text">
            <P>What is the licensing situation on that code? Are we free to use it with acknowledgement in the code? Acknowledgement visible to the user? Apply to you for a licence?</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in December 1st, 2007 at 10:33 am             </DIV>
			<DIV class="author_com_text">
            <P>@Tim:</P>
<P>See the link at the top of the page: <A href="http://marknelson.us/code-use-policy/" rel="nofollow">Liberal Code Use Policy</A>.</P>
<P>But remember, this is demonstration code - you may be able to find something substantially more optimized elsewhere.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">hlbnet said,</DIV>
			<DIV class="author_date">
            in December 14th, 2007 at 11:43 am             </DIV>
			<DIV class="author_com_text">
            <P>I do not see how a suffix tree can be build in linear time (so you understand I'm not an expert).<BR>
I KNOW it is true (read everywhere), but I definitively don't understand how it is possible.<BR>
If I follow your explanations, to construct our suffix tree, we have to browse all the characters of the text (here is the O(n) I think) and for each, we have to append the new character to all suffixes that are already in our tree. Here, I see a loop on the already registered suffixes nested in the main loop on the characters. And the inner loop becomes bigger each time a new suffix is added.<BR>
Is there something magic somewhere that makes the whole algorithm finally linear ?</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark</A> said,</DIV>
			<DIV class="author_date">
            in December 14th, 2007 at 11:54 am             </DIV>
			<DIV class="author_com_text">
            <P>@hlbnet:</P>
<P>The reason the algorithm runs in linear time is that appending a new suffix to the tree can be done in constant time. The reason the suffix can be appended in constant time is because we keep track of the active point.</P>
<P>If you look at the final version of the simplifed algorithm, you'll see that there is an outer loop that iterates over all the characters in the input sequence. But there's no inner loop. So the number of operations needed to create the whole tree is N*something, where something has an upper bound that is not dependent on N.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">hlbnet said,</DIV>
			<DIV class="author_date">
            in December 17th, 2007 at 10:11 am             </DIV>
			<DIV class="author_com_text">
            <P>I'm not fully convinced just reading the algo, since I see a
</P><DIV class="igBar"><SPAN id="lc-5"><A href="http://marknelson.us/1996/08/01/suffix-trees/#" onclick="javascript:showPlainTxt(&#39;c-5&#39;); return false;">PLAIN TEXT</A></SPAN></DIV>
<DIV class="syntax_hilite"><SPAN class="langName">C:</SPAN>
<DIV id="c-5">
<DIV class="c">
<OL>
<LI class="li1">
<DIV class="de1"><SPAN class="kw1">while</SPAN> <SPAN class="br0">(</SPAN> !done <SPAN class="br0">)</SPAN> </DIV>
</LI>
</OL>
</DIV>
</DIV>
</DIV>
<P> in the
</P><DIV class="igBar"><SPAN id="lc-6"><A href="http://marknelson.us/1996/08/01/suffix-trees/#" onclick="javascript:showPlainTxt(&#39;c-6&#39;); return false;">PLAIN TEXT</A></SPAN></DIV>
<DIV class="syntax_hilite"><SPAN class="langName">C:</SPAN>
<DIV id="c-6">
<DIV class="c">
<OL>
<LI class="li1">
<DIV class="de1">Udpdate<SPAN class="br0">(</SPAN> newSuffix <SPAN class="br0">)</SPAN> </DIV>
</LI>
</OL>
</DIV>
</DIV>
</DIV>
<P>  function (here is the inner loop).<BR>
I see that there are several stop conditions in the loop, making it stop rather "quickly". But it is still very hard for me to figure out the average number of loops that will be performed in a real example.<BR>
I definitively need to think of it more in depth.<BR>
Thank you for your article and answers, it is very usefull for beginners like me !</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">Iena said,</DIV>
			<DIV class="author_date">
            in February 14th, 2008 at 3:07 am             </DIV>
			<DIV class="author_com_text">
            <P>Hi Mark..<BR>
Thanks on your article..a very big help for my thesis..;)</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">Fan said,</DIV>
			<DIV class="author_date">
            in March 3rd, 2008 at 4:15 pm             </DIV>
			<DIV class="author_com_text">
            <P>Hi Mark,</P>
<P>Thank you for the good article.</P>
<P>I have one question about how to update suffix tree, would you please give me some suggestions? Thank you very much.</P>
<P>I have modified your source code in order to insert a new string to the suffix tree, update the suffix tree if new string doesn't exist in the suffix tree. Unfortunately, I was stuck on updating the suffix tree. </P>
<P>Here is an example, first inserts "hello" to the suffix tree which looks like:<BR>
Start  End  Suf  First Last  String<BR>
    0     2  -1     1      4  ello<BR>
    0     1  -1     0      4  hello<BR>
    0     4   0     2      2  l<BR>
    0     6  -1     4      4  o<BR>
    4     3  -1     3      4  lo<BR>
    4     5  -1     4      4  o</P>
<P>then inserts "bok" to the suffix tree, first character 'b' is added without any problem,<BR>
Start  End  Suf  First Last  String<BR>
    0     2  -1     1      4  ello<BR>
    0     1  -1     0      4  hello<BR>
    0     4   0     2      2  l<BR>
    0     6  -1     4      4  o<BR>
    4     3  -1     3      4  lo<BR>
    4     5  -1     4      4  o<BR>
    0     7  -1     5      7  bok</P>
<P>then 'o' is being added to the suffix tree, it was found in the suffix tree, which indicates by start node 0, end node 6. continuing on next character 'k', it first should append 'k' to leaf node 'o' and update its first and last character in the string from (4, 4) to (6, 7), then creates a new edge to represent 'k' and insert into the suffix tree. How should I modify the code on those steps?</P>
<P>The correct suffix tree should look like the following structure:</P>
<P>Start   End  Suf  First  Last    String<BR>
    0     2   -1     1      4     ello<BR>
    0     1   -1     0      4     hello<BR>
    0     4    0     2      2     l<BR>
    0     6   -1     4(6)   4(7)  ok<BR>
    4     3   -1     3      4     lo<BR>
    4     5   -1     4      4     o<BR>
    0     7   -1     5      7     bok<BR>
    0     8   -1     7      7     k</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">Mark Nelson said,</DIV>
			<DIV class="author_date">
            in March 4th, 2008 at 11:01 pm             </DIV>
			<DIV class="author_com_text">
            <P>@Fan:</P>
<P>Well, I'm not sure what you are doing makes any sense. If you already have "hello" in the tree, you can't have "bok" by itself, it has to be a suffix of some existing string in the tree. So when adding the "b", you should have "hellob" in the tree. </P>
<P>Your modified algorithm doesn't.</P>
<P>So whatever you are trying to make is not really a suffix tree.<BR>
=Mark</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">PT said,</DIV>
			<DIV class="author_date">
            in April 21st, 2008 at 6:54 pm             </DIV>
			<DIV class="author_com_text">
            <P>Does any know of a good Trie / suffix tree implementation in c#?</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark Nelson</A> said,</DIV>
			<DIV class="author_date">
            in April 21st, 2008 at 8:39 pm             </DIV>
			<DIV class="author_com_text">
            <P>@PT:</P>
<P>I'd take a look at codeproject.com, and perhaps search krugle.com.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">sarba said,</DIV>
			<DIV class="author_date">
            in April 23rd, 2008 at 1:29 am             </DIV>
			<DIV class="author_com_text">
            <P>@sarba<BR>
Hi Mark,<BR>
         I want to modify your code to find all exact repeat positions of an input string .For example String S=ATAGGATAGC .I want to find repeat (here ATA)  and there positions (here 0,5).Can you give me any suggestion about  how to modify the code?</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark Nelson</A> said,</DIV>
			<DIV class="author_date">
            in April 23rd, 2008 at 7:46 am             </DIV>
			<DIV class="author_com_text">
            <P>@sabra: I'm not sure I understand the question.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">sarba said,</DIV>
			<DIV class="author_date">
            in April 24th, 2008 at 12:29 pm             </DIV>
			<DIV class="author_com_text">
            <P>hi mark,<BR>
         Thanks for your attention.ok forget the above question for time being . More simply can you explain me how can I find longest common substring of  input string. Suppose I have two string<BR>
a. ATATGCATCAG<BR>
b. GCATGCACCGA<BR>
I want to find longest common substring of the two sequences. What I did is as follow,<BR>
    I concatenate two string  like this S=ATATGCATCAG#GCATGCACCGA then made suffix tree .Theoretically  the edge from root node to the depth est internal node contains the longest common substring.So how can I find the depthest intenal node and its "edge level" from root.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">prodvit said,</DIV>
			<DIV class="author_date">
            in May 21st, 2008 at 4:24 am             </DIV>
			<DIV class="author_com_text">
            <P>Hi mark. I read your article and I found it very useful. I'm interesting in suffix trees for building a web search results clustering algorithm, like STC (Zamir et Etzioni, 1998).</P>
<P>I'm interested in understanding the difference between suffix trees and suffix arrays, in particular I would understand advantage in using one rather than other in clustering problems.</P>
<P>Can you help me?</P>
<P>Thanks<BR>
Massimiliano</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark Nelson</A> said,</DIV>
			<DIV class="author_date">
            in May 21st, 2008 at 5:57 am             </DIV>
			<DIV class="author_com_text">
            <P>@prodvit:</P>
<P>I wish I could give you a good answer here, but I don't know a lot about suffix arrays - I need to get up to speed there myself. All I know for sure is that suffix trees are advertised as having good construction costs, and once constructed, should be just as useful as suffix trees.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">void said,</DIV>
			<DIV class="author_date">
            in May 28th, 2008 at 3:24 am             </DIV>
			<DIV class="author_com_text">
            <P>Just wanted to let you know that I thought your article was good. Clear and more understandable than alot of other articles on suffix trees I've looked at. </P>
<P>Good work, thanks for sharing.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark Nelson</A> said,</DIV>
			<DIV class="author_date">
            in May 28th, 2008 at 7:23 am             </DIV>
			<DIV class="author_com_text">
            <P>@void:</P>
<P>Thanks for the kind words. For some reason this is a tough algorithm to explain, to understand, and to illustrate. Some day in the far off future I'm going to take another crack at it and see if I can do better!</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">giorgos said,</DIV>
			<DIV class="author_date">
            in June 5th, 2008 at 4:34 am             </DIV>
			<DIV class="author_com_text">
            <P>Hi mark,<BR>
thanks for your article!<BR>
Is it possible to decribe what happens with the string MISSISSIPPI ?<BR>
Actually, i dont understand the step adding the MISSIS suffix.<BR>
i read the following link and its really confusing<BR>
<A href="http://www.allisons.org/ll/AlgDS/Tree/Suffix/" rel="nofollow">http://www.allisons.org/ll/AlgDS/Tree/Suffix/</A></P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark Nelson</A> said,</DIV>
			<DIV class="author_date">
            in June 5th, 2008 at 5:15 am             </DIV>
			<DIV class="author_com_text">
            <P>@girgos,</P>
<P>If you're having trouble with the description on the web site shown in your comment, why not ask the owner of that site for clarification?</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">giorgos said,</DIV>
			<DIV class="author_date">
            in June 5th, 2008 at 11:06 am             </DIV>
			<DIV class="author_com_text">
            <P>Thanks for your quick response, Mark!</P>
<P>I read your example with Bookeeper, but when i tried to create the tree for MISSISSIPPI, i had some problems.<BR>
It would be great and you would help me a lot if you gave us a succinct example with the string MISSISSIPPI too.</P>
<P>Thanks,<BR>
Giorgos</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">xyzzy said,</DIV>
			<DIV class="author_date">
            in June 16th, 2008 at 6:48 am             </DIV>
			<DIV class="author_com_text">
            <P>Hi, thanks for the nice article. It would be better if you add a few examples though, like how strees can be used for finding the longest common substring etc.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">xyzzy said,</DIV>
			<DIV class="author_date">
            in June 16th, 2008 at 7:52 am             </DIV>
			<DIV class="author_com_text">
            <P>Ok. Here's one solution I found. When you find a character that's already an implicit node, mark a $ under it so that the next character encountered will be added to this $  also.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">Tamer said,</DIV>
			<DIV class="author_date">
            in July 1st, 2008 at 3:38 pm             </DIV>
			<DIV class="author_com_text">
            <P>Hi,</P>
<P>Nice work.  I am working on a research project that requires building a large suffix tree (around 20k string, each with 4 to 8 letters). I worked on your code, and i guess the main problem is in the hash array. I mean if i can enlarge the hash array, i can store the large number of edges in the tree.<BR>
Could you please provide me with some way to change the hashing function so that to be able to generate a number between 0 and 20k or 30k.</P>
<P>Thanks,<BR>
Tamer</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://blog.antonindanek.cz/" rel="external nofollow">Tonda</A> said,</DIV>
			<DIV class="author_date">
            in December 5th, 2008 at 9:27 am             </DIV>
			<DIV class="author_com_text">
            <P>Hello,<BR>
this si the best explanation of creating suffix tree I found so far (however I still fully don't understand it, maybe because I am not native English speaker).</P>
<P>I have one question. I have 1MB file with characters representing part of DNA. I need to find longest repeated substring (LRS) but these substrings can be over each other.</P>
<P>Example: BANANAS<BR>
1) LRS without overlapping: AN or NA<BR>
2) LRS with overlapping: ANA</P>
<P>I need to find the second one. But if I understand at least a little to suffix trees, they allow me to find only the first mentioned LRS. Aren't they? Could you give me some direction, how to find the second one?</P>
<P>Thank you.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark Nelson</A> said,</DIV>
			<DIV class="author_date">
            in December 6th, 2008 at 1:54 pm             </DIV>
			<DIV class="author_com_text">
            <P>@Tonda:</P>
<P>To be honest, I don't have a good answer for you. It looks like a tough problem.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">pschloss said,</DIV>
			<DIV class="author_date">
            in December 8th, 2008 at 7:03 am             </DIV>
			<DIV class="author_com_text">
            <P>Thanks for your article and code.  I was wondering whether you have developed a function to add strings to a pre-existing suffix tree to build a generalized suffix tree.  I know you can just concatenate the strings together with unique separators, but this seems to run into problems when you have more than 256 strings and you would seem to generate and process some very long edges that aren't "real".  Any suggestions?  This seems to get minimal mention in Gusfield and other sources.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://greencrab.wordpress.com/2009/01/30/links-for-2009-01-30/" rel="external nofollow">links for 2009-01-30 « My Weblog</A> said,</DIV>
			<DIV class="author_date">
            in January 30th, 2009 at 10:02 pm             </DIV>
			<DIV class="author_com_text">
            <P>[...] Fast String Searching With Suffix Trees (tags: cs) [...]</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">bbi5291 said,</DIV>
			<DIV class="author_date">
            in March 17th, 2009 at 1:52 pm             </DIV>
			<DIV class="author_com_text">
            <P>@Mark Nelson: When you say that each new suffix can be appended in constant time, don't you mean that adding a character to the end of a current suffix takes constant time?<BR>
It's certainly not true that it is guaranteed to take constant time only to add a character to the tree as a whole. But it still takes linear time overall, right? Because whenever we do A LOT of work for one character, it was due to not having done much during previous iterations. Or you could say that the active point moves a linear number of times during the whole algorithm, and that each time it moves a constant amount of work is done, so the algorithm is linear overall.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark Nelson</A> said,</DIV>
			<DIV class="author_date">
            in March 18th, 2009 at 6:38 am             </DIV>
			<DIV class="author_com_text">
            <P>@bbi5291:</P>
<P>Yes, you are correct, when I say "each new suffix can be added in constant time" I am misusing the term suffix - what I actually mean is "each new character can be added in constant time".</P>
<P>But you are incorrect in thinking that adding a character to the tree is not constant time - only linear overall. Adding a single character is definitely constant time only. The various operations that can occur each time a character is added do not change regardless of the length of the previously seen input. They don't involve scanning back through the the tree. They are, in fact, constant, which is why the algorithm is guaranteed to run in linear time regardless of the input.</P>
<P>We don't do "a lot" of work for just one character. (Mostly because we maintain a suffix pointer at each node - this lets us navigate to the next smallest node with a single dereference.)</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">bbi5291 said,</DIV>
			<DIV class="author_date">
            in March 19th, 2009 at 12:06 pm             </DIV>
			<DIV class="author_com_text">
            <P>@Mark Nelson:<BR>
Seems that we do agree on runtime complexities, then, we just misunderstood each other - yes, I understand that the operation of extending a single suffix by a single character is constant time.<BR>
When I said "adding a character" what I meant was the process undertaken to transform the suffix tree of the first N characters to the one for the first N+1 characters. Here "a lot of work" can be done at once, but it's still amortized constant, right?</P>
<P>Now, one thing that bothers me is the canonicalization. This can require walking through a linear number of edges at once; how do we know that this is amortized constant as well?</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">rodger87 said,</DIV>
			<DIV class="author_date">
            in April 11th, 2009 at 5:09 pm             </DIV>
			<DIV class="author_com_text">
            <P>hi </P>
<P>I am working on common pattern searching algorithms. I was using suffix tree,but i wasn't able to implement it for the search of common pattern without giving any input string.<BR>
Like, I have 15 sequences and i wanted to make suffix tree of each sequence and search for the common pattern in all the 15 sequences</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark Nelson</A> said,</DIV>
			<DIV class="author_date">
            in April 11th, 2009 at 6:26 pm             </DIV>
			<DIV class="author_com_text">
            <P>@rodger87:</P>
<P>Sorry don't really understand the question.</P>
<P>From the problem you describe, you need to create and search 15 suffix trees.</P>
<P>- Mark</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">rodger87 said,</DIV>
			<DIV class="author_date">
            in April 16th, 2009 at 10:09 pm             </DIV>
			<DIV class="author_com_text">
            <P>This is my algorithm:</P>
<P>1 set number of characters to be processed ws = 8000<BR>
(note: we assume 8000 characters are processed at one time)<BR>
2 compute length of longest common pattern (overlap size).<BR>
3 for each sequence, Si, in database do<BR>
4 set overlap string Os to empty<BR>
5 while not end of sequence Si do<BR>
6 set Stmp = |Os| + ws characters of Si<BR>
7 construct a suffix tree, ST, for the subsequence Stmp<BR>
8 use multiple patterns search against the suffix tree ST<BR>
9 record the search result<BR>
10 determine the content of overlap string Os<BR>
11 update position for next ws characters from Si<BR>
12 end while<BR>
13 end for</P>
<P>I am not able to code it....in perl...</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://illya-keeplearning.blogspot.com/" rel="external nofollow">Illya Havsiyevych</A> said,</DIV>
			<DIV class="author_date">
            in April 18th, 2009 at 1:20 am             </DIV>
			<DIV class="author_com_text">
            <P>Hello,</P>
<P>I've ported your source code to Java<BR>
<A href="http://illya-keeplearning.blogspot.com/2009/04/suffix-trees-java-ukkonens-algorithm.html" rel="nofollow">http://illya-keeplearning.blogspot.com/2009/04/suffix-trees-java-ukkonens-algorithm.html</A></P>
<P>Thanks for reference implementation,<BR>
illya</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark Nelson</A> said,</DIV>
			<DIV class="author_date">
            in April 18th, 2009 at 6:53 am             </DIV>
			<DIV class="author_com_text">
            <P>@Illya:</P>
<P>Thanks, that will be very helpful! </P>
<P>- Mark</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://tagz.in/posts/1co/comments/" rel="external nofollow">Tagz | "Fast String Searching With Suffix Trees at Mark Nelson" | Comments</A> said,</DIV>
			<DIV class="author_date">
            in May 16th, 2009 at 11:10 am             </DIV>
			<DIV class="author_com_text">
            <P>[...]               [upmod] [downmod]     Fast String Searching With Suffix Trees at Mark Nelson  (marknelson.us)    0 points posted 10 months, 1 week ago by jeethu  tags search suffix algorithm [...]</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://www.nexginrc.org/~zubair.rafique/" rel="external nofollow">Zubair</A> said,</DIV>
			<DIV class="author_date">
            in May 16th, 2009 at 2:51 pm             </DIV>
			<DIV class="author_com_text">
            <P>Hi Mark,</P>
<P>Thnx for writing such a beautiful article. I m working on building a "weighted suffix tree" for particular application. Therefore I have to modify the whole algorithm of developing the suffix tree and its search algorithm. Wht i believe is some minor changes in the current code and INTELLIGENT guidance will lead me to a better solution. I have already implemented the prototype for my work but the efficiency of the implementation in term of processing is quite low.  I would like for your coordination or help in ma work . I need to update the suffix tree for a certain period of time by giving new strings to tree. If a particular suffix exists all it need to do .......(lets assume nothing to do). If new suffix arrives it have to update the tree on run time ....... Thats only the part of problem . Hope u can guide me regarding this As I m still a student :). Further more if ask for a personal contact with you regarding ma work :) ......</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark Nelson</A> said,</DIV>
			<DIV class="author_date">
            in May 19th, 2009 at 5:51 am             </DIV>
			<DIV class="author_com_text">
            <P>@zubair:</P>
<P>sorry i won't be able to give you personal guidance on this, perhaps you could contact others who have posted here.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://illya-keeplearning.blogspot.com/" rel="external nofollow">Illya Havsiyevych</A> said,</DIV>
			<DIV class="author_date">
            in May 24th, 2009 at 2:53 pm             </DIV>
			<DIV class="author_com_text">
            <P>Mark,</P>
<P>FYI refactored Java code with some pictures and test runs.<BR>
<A href="http://illya-keeplearning.blogspot.com/2009/05/suffix-trees-refactored-java-code.html" rel="nofollow">http://illya-keeplearning.blogspot.com/2009/05/suffix-trees-refactored-java-code.html</A></P>
<P>Main ideas:<BR>
- reuse java hash map;<BR>
- better OOP.</P>
<P>Thanks,<BR>
illya</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://illya-keeplearning.blogspot.com/" rel="external nofollow">Illya Havsiyevych</A> said,</DIV>
			<DIV class="author_date">
            in June 8th, 2009 at 1:16 am             </DIV>
			<DIV class="author_com_text">
            <P>FYI,<BR>
Suffix Trees Java Applet - build and visualize your tree.<BR>
<A href="http://illya-keeplearning.blogspot.com/2009/06/suffix-trees-java-applet.html" rel="nofollow">http://illya-keeplearning.blogspot.com/2009/06/suffix-trees-java-applet.html</A></P>
<P>Thanks,<BR>
illya</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">Maria said,</DIV>
			<DIV class="author_date">
            in June 13th, 2009 at 11:59 am             </DIV>
			<DIV class="author_com_text">
            <P>Hi Mark,</P>
<P>I am trying to understanding how the construction of a suffix tree works. I have tried to continue the construction of the tree for BANANAS starting with the steps on Figure.3, but I have a problem:</P>
<P>as a next step in Fig.3 I want to build a tree for BANA, and I think I just need to add an 'A' to the three edges of the tree for BAN (I don't add another edge). So, my tree for BANA will have again three edges (no further branching) starting from the root and having as strings BANA, ANA, and NA. My problem is that I am not sure what happens with the suffix 'A'. It does not appear (in what I have done) explicitly on a separate edge. If we had a suffix TRIE we would have an edge for 'A'. Now in the suffix TREE we have an implicite node, which implicitely separates 'N' and 'A' of the edge 'NA'. My question is: if I query for 'A', will the system "take into account" this implicit node between 'N' and 'A', and thus see the 'A'? Should I think about this in this way? I may be have trouble with what "implicit" mean.</P>
<P>The same problem is with the tree for BOOKK on Figure 5. I don't understand why we don't have an edge for the suffix 'K' (the smallest suffix of BOOKK, apart from the empty one). If what I have written above for the identification (matching) of the suffix 'A' is correct, then 'K' will be "identified" on one of the edges having 'KK' as a string or substring. Will it be the edge 'KK' (the one between nodes 0 and 2)? Or may be on the edge 'BOOKK' (the one between nodes 0 and 1)?</P>
<P>Thanks a lot in advance.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://marknelson.us/" rel="external nofollow">Mark Nelson</A> said,</DIV>
			<DIV class="author_date">
            in June 13th, 2009 at 4:24 pm             </DIV>
			<DIV class="author_com_text">
            <P>@Maria:</P>
<P>Check out Ilya's java app and you can see the results of construction in real time. That might be helpful.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">xutao said,</DIV>
			<DIV class="author_date">
            in June 15th, 2009 at 12:35 pm             </DIV>
			<DIV class="author_com_text">
            <P>Hi Mark,<BR>
Good article and useful code. However when I walk_tree for "banana$", it took 2816 iterations! It is certainly nowhere near linear. Please help</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">xutao said,</DIV>
			<DIV class="author_date">
            in June 15th, 2009 at 3:00 pm             </DIV>
			<DIV class="author_com_text">
            <P>The following code is to help query the tree with a string. If the query is a substring of a suffix, it will return the position substring. </P>
<P>example code following tree construction<BR>
[c]<BR>
int start, end;<BR>
search_tree(q, start, end);<BR>
cout= strlen(query)) {<BR>
				cout</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">xutao said,</DIV>
			<DIV class="author_date">
            in June 15th, 2009 at 3:01 pm             </DIV>
			<DIV class="author_com_text">
            <DIV class="igBar"><SPAN id="lc-7"><A href="http://marknelson.us/1996/08/01/suffix-trees/#" onclick="javascript:showPlainTxt(&#39;c-7&#39;); return false;">PLAIN TEXT</A></SPAN></DIV>
<DIV class="syntax_hilite"><SPAN class="langName">C:</SPAN>
<DIV id="c-7">
<DIV class="c">
<OL>
<LI class="li1">
<DIV class="de1"><SPAN class="coMULTI">/*</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2"><SPAN class="coMULTI">input a string to search query []</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1"><SPAN class="coMULTI">output start_index and end_index on the string (tree) search against</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2"><SPAN class="coMULTI">*/</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1"><SPAN class="kw4">void</SPAN> search_tree<SPAN class="br0">(</SPAN><SPAN class="kw4">char</SPAN> query <SPAN class="br0">[</SPAN><SPAN class="br0">]</SPAN>, <SPAN class="kw4">int</SPAN>&nbsp; &amp; start_index,</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; <SPAN class="kw4">int</SPAN>&nbsp; &amp; end_index<SPAN class="br0">)</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp;</DIV>
</LI>
<LI class="li2">
<DIV class="de2"><SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; <SPAN class="kw4">int</SPAN> start_node = <SPAN class="nu0">0</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; <SPAN class="kw4">int</SPAN> qp=<SPAN class="nu0">0</SPAN>; <SPAN class="co1">//query position</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; start_index = -<SPAN class="nu0">1</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; end_index=-<SPAN class="nu0">1</SPAN>;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; bool stop =<SPAN class="kw2">false</SPAN>;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; <SPAN class="kw1">while</SPAN><SPAN class="br0">(</SPAN>!stop<SPAN class="br0">)</SPAN><SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; Edge edge = Edge::<SPAN class="me2">Find</SPAN><SPAN class="br0">(</SPAN>start_node, query<SPAN class="br0">[</SPAN>qp<SPAN class="br0">]</SPAN><SPAN class="br0">)</SPAN>;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw1">if</SPAN> <SPAN class="br0">(</SPAN> edge.<SPAN class="me1">start_node</SPAN> == -<SPAN class="nu0">1</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stop=<SPAN class="kw2">true</SPAN>;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw2">break</SPAN>;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="br0">}</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw1">if</SPAN> <SPAN class="br0">(</SPAN>start_node ==<SPAN class="nu0">0</SPAN><SPAN class="br0">)</SPAN> start_index = edge.<SPAN class="me1">first_char_index</SPAN>;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; print_edge<SPAN class="br0">(</SPAN>edge<SPAN class="br0">)</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw1">for</SPAN> <SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> i = edge.<SPAN class="me1">first_char_index</SPAN>; i &lt;=edge.<SPAN class="me1">last_char_index</SPAN>; i++<SPAN class="br0">)</SPAN><SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>qp&gt;= strlen<SPAN class="br0">(</SPAN>query<SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="co1">//cout&lt;&lt;"whole query matched"&lt;&lt;endl;</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stop=<SPAN class="kw2">true</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw2">break</SPAN>;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="br0">}</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw1">else</SPAN> <SPAN class="kw1">if</SPAN> <SPAN class="br0">(</SPAN>query<SPAN class="br0">[</SPAN>qp<SPAN class="br0">]</SPAN> == T<SPAN class="br0">[</SPAN>i<SPAN class="br0">]</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="co1">//cout&lt;&lt;query[qp]&lt;&lt;" ";</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qp++;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_index = i;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="br0">}</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw1">else</SPAN><SPAN class="br0">{</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="co1">//cout&lt;&lt;"partially matched"&lt;&lt;endl;</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stop=<SPAN class="kw2">true</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw2">break</SPAN>;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="br0">}</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="br0">}</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw1">if</SPAN> <SPAN class="br0">(</SPAN>!stop<SPAN class="br0">)</SPAN><SPAN class="br0">{</SPAN> <SPAN class="co1">//proceed with next node</SPAN></DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_node = edge.<SPAN class="me1">end_node</SPAN>;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>start_node==-<SPAN class="nu0">1</SPAN><SPAN class="br0">)</SPAN> stop=<SPAN class="kw2">true</SPAN>;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;<SPAN class="st0">"next node&nbsp; &nbsp; "</SPAN>&lt;&lt;start_node;</DIV>
</LI>
<LI class="li1">
<DIV class="de1">&nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="br0">}</SPAN>&nbsp; &nbsp;</DIV>
</LI>
<LI class="li2">
<DIV class="de2">&nbsp; &nbsp; <SPAN class="br0">}</SPAN></DIV>
</LI>
<LI class="li1">
<DIV class="de1"><SPAN class="br0">}</SPAN> </DIV>
</LI>
</OL>
</DIV>
</DIV>
</DIV>
<P></P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://illya-keeplearning.blogspot.com/" rel="external nofollow">Illya Havsiyevych</A> said,</DIV>
			<DIV class="author_date">
            in July 3rd, 2009 at 3:47 pm             </DIV>
			<DIV class="author_com_text">
            <P>Hello,</P>
<P>FYI,<BR>
Some other Suffix Trees based Java Applets:<BR>
* Generalized Suffix Tree - <A href="http://illya-keeplearning.blogspot.com/2009/06/generalized-suffix-trees-java-applet.html" rel="nofollow">http://illya-keeplearning.blogspot.com/2009/06/generalized-suffix-trees-java-applet.html</A><BR>
* Diff - <A href="http://illya-keeplearning.blogspot.com/2009/07/suffix-trees-based-diff-java-applet.html" rel="nofollow">http://illya-keeplearning.blogspot.com/2009/07/suffix-trees-based-diff-java-applet.html</A></P>
<P>Thanks,<BR>
illya</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com">Legistrate said,</DIV>
			<DIV class="author_date">
            in November 25th, 2009 at 1:39 pm             </DIV>
			<DIV class="author_com_text">
            <P>I found your implementation the most useful of the various implementations out there, but the divergence from Gusfield was very confusing at first.  Then there are also some things that Gusfield doesn't seem to address directly.</P>
<P>For example, If you just wanted to implement suffix links, how would you know what the characters are when you walk up one edge to arrive at the parent (y in the text).  You need to know more than just the one character leading from that parent to the edge so you can walk back down after you traverse the suffix link with possibly multiple nodes.</P>
<P>I ask because in your code I finally realized that you don't actually walk down the edge to either a newly created inner node or to new children.  In this way you have the Suffix start track the position of the char that indicated the edge to the correct node.  While I'm still fuzzy on why exactly that works, in general I would say it does.</P>
<P>The start being larger than stop signals an external node, and the converse an internal node.  So in a phase, that means extensions are applied Rule 1, Rule 2(splits), Rule 2(new kids), Rule 3.  But when I use the string "mississippi$" I have an unexpected split in the last phase.  In Phase 10 adding (the last)'i' Suffix start is 9. The active point splits ppi$ into p: pi$ and i$, and the active point moves to the root.  Thus start is incremented by one(10) and the next extension should be explicit(start==stop) which it is since 'i' is already an internal node off the root.  Rule 3 breaks the loop and we move to the next phase('$').  But here, the stop has increased too, and now the algorithm thinks that the active point should be an implicit node.  This is not true, so a split is performed on the explicit node, and there is now an extra empty child in the final tree.</P>
<P>Could you maybe mention a little of how you devised a way to have a start counter for tracking the relevant index in the string as you move from extension to extension rather than the for loop covering each extension?</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com">Legistrate said,</DIV>
			<DIV class="author_date">
            in November 25th, 2009 at 4:06 pm             </DIV>
			<DIV class="author_com_text">
            <P>Hmm, well it looks like I made an implementation mistake.  The algorithm does correctly handle my Phase 11('$').  I am still unsure of how you discovered the proper way to track the position of the active extension, but as the code works, I guess I could read through it a few more times.  I do however thing that the suffix pointers added are not always necessary(ie extras), but that could be a mistake too :P.</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box">
			<DIV class="author_com"><A href="http://www.itsentirelytrue.com/wordpress/?p=18" rel="external nofollow">Its Entirely True » C# Suffix Tree</A> said,</DIV>
			<DIV class="author_date">
            in December 9th, 2009 at 8:31 pm             </DIV>
			<DIV class="author_com_text">
            <P>[...] I was unable to find a C# implementation of the suffix tree so I ported one I found at Mark Nelson’s Blog. The project of the C# port is located here [...]</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>



<DIV class="com-box_alt">
			<DIV class="author_com"><A href="http://functor.sk/" rel="external nofollow">ziman</A> said,</DIV>
			<DIV class="author_date">
            in February 10th, 2010 at 5:12 am             </DIV>
			<DIV class="author_com_text">
            <P>Thanks much for this overview, it definitely helped me much to get an A at today's exam! :)</P>
            </DIV>
			</DIV>

			<DIV class="com-fixed"></DIV>







<DIV class="com-fixed"></DIV>
<H4>Leave A Reply</H4>
You can insert source code in your comment without fear of too much mangling by tagging it to use the <A href="http://blog.igeek.info/still-fresh/category/wp-plugins/igsyntax-hiliter/" class="newpage" target="_blank">iG:Syntax Hiliter</A> plugin. A typical usage of this plugin will look like this:<P>
<CODE>
[c]<BR>
int main()<BR>
{<BR>
    printf( "Hello, world!\n" );<BR>
    return 1;<BR>
}<BR>
[/c]<BR>
</CODE></P><P>
Note that tags are enclosed in square brackets, not angle brackets. Tags currently supported by this plugin are:
as (ActionScript), asp, c, cpp, csharp, css, delphi, html, java, js, mysql, perl, python, ruby, smarty, sql, vb, vbnet, xml, code (Generic).
</P><P>
If you post your comment and you aren't happy with the way it looks, I will do everything I can to edit it to your satisfaction.
</P><P>
</P><FORM action="http://marknelson.us/wp-comments-post.php" method="post">
<DIV id="comment-box">
<P><INPUT name="author" type="text" value="">&nbsp;Username (*required)</P>
<P><INPUT name="email" type="text" value="">&nbsp;Email Address (*private)</P>
<P><INPUT name="url" type="text" value="">&nbsp;Website (*optional)</P>
</DIV>


<DIV id="comment-area">
<P><TEXTAREA name="comment" cols="50%" rows="8"></TEXTAREA></P>
<P><INPUT name="submit" type="submit" value="Post My Comment">
<INPUT type="hidden" name="comment_post_ID" value="80"></P>
</DIV>
</FORM>
</DIV>


<DIV class="post-fixed"></DIV>


</DIV>

</DIV>

<DIV id="right-sidebars">
		<DIV class="sidebar-box">

         								<DIV class="textwidget"><FONT size="2">
<BR>
<TABLE border="1"><TBODY><TR><TD>

Looking to get your <A href="http://www.earnmydegree.com/online-education/technology/programming.html">programming degree</A>?  This <A href="http://www.earnmydegree.com/">online college</A> and <A href="http://www.eric.ed.gov/ERICWebPortal/recordDetail?accno=EJ645761">learning</A> center has the <A href="http://www.earnmydegree.com/online-education/bachelor/">bachelor degree</A> in the <A href="http://www.capella.edu/online_bachelors_degree_programs.aspx">field</A> you're looking for!


</TD></TR></TBODY></TABLE></FONT></DIV><FONT size="2">
					<H3>Links From Google</H3>			<DIV class="textwidget"> <BR>
<CENTER>
<SCRIPT type="text/javascript"><!--
google_ad_client = "pub-0622359880551876";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_ui_features = "rc:10";
//-->
</SCRIPT>
<SCRIPT type="text/javascript" src="./Fast String Searching With Suffix Trees_files/show_ads.js">
</SCRIPT><SCRIPT src="./Fast String Searching With Suffix Trees_files/expansion_embed.js"></SCRIPT><SCRIPT src="./Fast String Searching With Suffix Trees_files/test_domain.js"></SCRIPT><SCRIPT>google_protectAndRun("ads_core.google_render_ad", google_handleError, google_render_ad);</SCRIPT><INS style="display:inline-table;border:none;height:600px;margin:0;padding:0;position:relative;visibility:visible;width:160px"><INS style="display:block;border:none;height:600px;margin:0;padding:0;position:relative;visibility:visible;width:160px"><IFRAME allowtransparency="true" frameborder="0" height="600" hspace="0" id="google_ads_frame1" marginheight="0" marginwidth="0" name="google_ads_frame" scrolling="no" src="./Fast String Searching With Suffix Trees_files/ads.htm" style="left:0;position:absolute;top:0" vspace="0" width="160"></IFRAME></INS></INS>
</CENTER></DIV>
					<H3>Amazon Books</H3>			<DIV class="textwidget"><CENTER>
&nbsp;<BR>
<SCRIPT type="text/javascript"><!--
  amazon_ad_tag = "theinternetdatac";  amazon_ad_width = "160";  amazon_ad_height = "600";  amazon_ad_link_target = "new";  amazon_ad_include = "algorithms;programming;data+compression";  amazon_ad_categories = "adefg";//--></SCRIPT>
<SCRIPT type="text/javascript" src="./Fast String Searching With Suffix Trees_files/ads.js"></SCRIPT><SCRIPT src="./Fast String Searching With Suffix Trees_files/ads-common.js" type="text/javascript"></SCRIPT><IFRAME src="./Fast String Searching With Suffix Trees_files/cm.htm" marginwidth="0" marginheight="0" width="160" height="600" border="0" frameborder="0" style="border:none;" scrolling="no"></IFRAME>
</CENTER></DIV>
		

		  </FONT></DIV><FONT size="2">
		</FONT></DIV><FONT size="2">
	  </FONT></DIV><FONT size="2">

	  <DIV class="left-content-talia">
	    <DIV id="left-sidebars">

		  <DIV class="sidebar-box">

           

         								<DIV class="textwidget"><A href="http://www.blogged.com/blogs/mark-nelson.html">
<IMG src="./Fast String Searching With Suffix Trees_files/rt_5311.gif" border="0" alt="Mark Nelson at Blogged" title="Mark Nelson at Blogged"></A></DIV>
							<H3>Bookmarks/Feeds</H3>			<DIV class="textwidget"><P>
<FONT size="2">
Use the first button below to bookmark this article on sites like del.icio.us, Digg, Reddit, Slashdot, etc.

The second button adds a feed for the site to your reader.

Both buttons will open a selection screen in a new window.
</FONT>
</P><P></P></DIV>
		<DIV style="text-align:center"><A href="http://www.addthis.com/bookmark.php?pub=snorkelman&url=http%3A%2F%2Fmarknelson.us%2F1996%2F08%2F01%2Fsuffix-trees%2F&title=Fast+String+Searching+With+Suffix+Trees" target="_blank" title="Bookmark using any bookmark manager!"><IMG src="./Fast String Searching With Suffix Trees_files/button2-bm.png" width="160" height="24" alt="AddThis Social Bookmark Button"></A></DIV><DIV style="text-align:center"><A href="http://www.addthis.com/feed.php?pub=snorkelman&h1=http%3A%2F%2Fmarknelson.us%2Ffeed%2F" target="_blank" title="Subscribe using any feed reader!"><IMG src="./Fast String Searching With Suffix Trees_files/button2-fd.png" width="160" height="24" alt="AddThis Feed Button"></A></DIV><H3>Categories</H3><P class="catcloud" style="text-align:left;">
<A href="http://marknelson.us/category/standards/" title="1 posts filed under Standards" style="font-size:13px">Standards</A> 
<A href="http://marknelson.us/category/scams/" title="1 posts filed under Scams" style="font-size:13px">Scams</A> 
<A href="http://marknelson.us/category/humor/" title="1 posts filed under Humor" style="font-size:13px">Humor</A> 
<A href="http://marknelson.us/category/voip/" title="2 posts filed under VoIP" style="font-size:13px">VoIP</A> 
<A href="http://marknelson.us/category/work/" title="2 posts filed under Work" style="font-size:13px">Work</A> 
<A href="http://marknelson.us/category/culture/" title="2 posts filed under Culture" style="font-size:13px">Culture</A> 
<A href="http://marknelson.us/category/hackery/" title="2 posts filed under Hackery" style="font-size:13px">Hackery</A> 
<A href="http://marknelson.us/category/writing/" title="3 posts filed under Writing" style="font-size:13px">Writing</A> 
<A href="http://marknelson.us/category/snarkiness/" title="4 posts filed under Snarkiness" style="font-size:14px">Snarkiness</A> 
<A href="http://marknelson.us/category/video/" title="5 posts filed under Video" style="font-size:14px">Video</A> 
<A href="http://marknelson.us/category/graphics/" title="5 posts filed under Graphics" style="font-size:14px">Graphics</A> 
<A href="http://marknelson.us/category/people/" title="6 posts filed under People" style="font-size:14px">People</A> 
<A href="http://marknelson.us/category/audio/" title="6 posts filed under Audio" style="font-size:14px">Audio</A> 
<A href="http://marknelson.us/category/web-articles/" title="9 posts filed under Web Articles" style="font-size:15px">Web Articles</A> 
<A href="http://marknelson.us/category/business/" title="9 posts filed under Business" style="font-size:15px">Business</A> 
<A href="http://marknelson.us/category/computer-science/" title="10 posts filed under Computer Science" style="font-size:16px">Computer Science</A> 
<A href="http://marknelson.us/category/programming/" title="10 posts filed under Programming" style="font-size:16px">Programming</A> 
<A href="http://marknelson.us/category/complaining/" title="13 posts filed under Complaining" style="font-size:17px">Complaining</A> 
<A href="http://marknelson.us/category/magazine-articles/" title="22 posts filed under Magazine Articles" style="font-size:20px">Magazine Articles</A> 
<A href="http://marknelson.us/category/data-compression/" title="26 posts filed under Data Compression" style="font-size:21px">Data Compression</A> </P>
<H3>Recent Entries</H3>
<UL>
	<LI><A href="http://marknelson.us/2008/07/20/innumeracy-part-n/" title="Innumeracy Part N">Innumeracy Part N</A></LI>
	<LI><A href="http://marknelson.us/2008/06/02/slate-rips-me-off/" title="Slate Rips Me Off">Slate Rips Me Off</A></LI>
	<LI><A href="http://marknelson.us/2008/05/21/corley/" title="Another One Bites the Dust">Another One Bites the Dust</A></LI>
	<LI><A href="http://marknelson.us/2008/04/28/efl/" title="English as a Foreign Language - A Cautionary Tale">English as a Foreign Language - A Cautionary Tale</A></LI>
	<LI><A href="http://marknelson.us/2008/03/31/how-evil-is-apple/" title="How Evil Is Apple?">How Evil Is Apple?</A></LI>
	<LI><A href="http://marknelson.us/2008/02/11/cashing-in-on-e-books/" title="Cashing in On Electronic Books">Cashing in On Electronic Books</A></LI>
	<LI><A href="http://marknelson.us/2008/01/28/kerviel/" title="Jerome Kerviel, My Hero">Jerome Kerviel, My Hero</A></LI>
	<LI><A href="http://marknelson.us/2007/12/11/amex-survey/" title="I Trust American Express With My Money?">I Trust American Express With My Money?</A></LI>
	<LI><A href="http://marknelson.us/2007/12/04/algorithms-crossword/" title="Algorithms Crossword">Algorithms Crossword</A></LI>
	<LI><A href="http://marknelson.us/2007/11/24/help-needed/" title="Help Needed">Help Needed</A></LI>
</UL>

<H3>Blogroll</H3>
		<UL>
		<LI><A href="http://jnjnjn.com/" title="Joey Nelson">Joey Nelson</A> - Joey Nelson</LI>
<LI><A href="http://obviosaurus.com/" title="It&#39;s obvious">Obviosaurus.com</A> - It's obvious</LI>
		</UL>
			<H3>My Books</H3>			<DIV class="textwidget"><UL>
<LI><A href="http://marknelson.us/about/tdcb/">The Data Compression Book</A>
</LI><LI><A href="http://marknelson.us/about/serial1/">Serial Communications: A C++ Developer's Guide, 1st. ed.</A>
</LI><LI><A href="http://marknelson.us/about/serial2/">Serial Communications: A C++ Developer's Guide, 2nd ed.</A>
</LI><LI><A href="http://marknelson.us/about/stl/">C++ Programmer's Guide to the Standard Template Library</A>
</LI><LI><A href="http://marknelson.us/about/services/">Developing Cisco IP Phone Services: A Cisco AVVID Solution</A>
</LI></UL></DIV>
		<H3>Archives</H3>		<SELECT name="archive-dropdown" onchange="document.location.href=this.options[this.selectedIndex].value;"> <OPTION value="">Select Month</OPTION> 	<OPTION value="http://marknelson.us/2008/07/"> July 2008 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2008/06/"> June 2008 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2008/05/"> May 2008 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2008/04/"> April 2008 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2008/03/"> March 2008 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2008/02/"> February 2008 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2008/01/"> January 2008 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2007/12/"> December 2007 &nbsp;(2)</OPTION>
	<OPTION value="http://marknelson.us/2007/11/"> November 2007 &nbsp;(5)</OPTION>
	<OPTION value="http://marknelson.us/2007/09/"> September 2007 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2007/08/"> August 2007 &nbsp;(3)</OPTION>
	<OPTION value="http://marknelson.us/2007/07/"> July 2007 &nbsp;(4)</OPTION>
	<OPTION value="http://marknelson.us/2007/05/"> May 2007 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2007/04/"> April 2007 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2006/11/"> November 2006 &nbsp;(2)</OPTION>
	<OPTION value="http://marknelson.us/2006/10/"> October 2006 &nbsp;(2)</OPTION>
	<OPTION value="http://marknelson.us/2006/09/"> September 2006 &nbsp;(5)</OPTION>
	<OPTION value="http://marknelson.us/2006/08/"> August 2006 &nbsp;(6)</OPTION>
	<OPTION value="http://marknelson.us/2006/07/"> July 2006 &nbsp;(6)</OPTION>
	<OPTION value="http://marknelson.us/2006/06/"> June 2006 &nbsp;(9)</OPTION>
	<OPTION value="http://marknelson.us/2005/10/"> October 2005 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2004/02/"> February 2004 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2002/10/"> October 2002 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2002/08/"> August 2002 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2002/07/"> July 2002 &nbsp;(3)</OPTION>
	<OPTION value="http://marknelson.us/2002/04/"> April 2002 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2002/03/"> March 2002 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2002/01/"> January 2002 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2001/09/"> September 2001 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2000/06/"> June 2000 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/2000/01/"> January 2000 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/1998/03/"> March 1998 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/1997/12/"> December 1997 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/1997/09/"> September 1997 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/1997/01/"> January 1997 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/1996/09/"> September 1996 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/1996/08/"> August 1996 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/1996/01/"> January 1996 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/1992/05/"> May 1992 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/1990/02/"> February 1990 &nbsp;(1)</OPTION>
	<OPTION value="http://marknelson.us/1989/10/"> October 1989 &nbsp;(1)</OPTION>
 </SELECT>
<H3>Recent Comments </H3>
		<UL>
		<LI><A href="http://marknelson.us/1996/08/01/suffix-trees/#comment-322664" title="Fast String Searching With Suffix T&hellip;"><STRONG>ziman</STRONG> in Fast String Searching With Suffix T…</A></LI>
<LI><A href="http://marknelson.us/1990/02/01/managing-the-heap/#comment-322437" title="Managing the Heap"><STRONG>Mark Nelson</STRONG> in Managing the Heap</A></LI>
<LI><A href="http://marknelson.us/1990/02/01/managing-the-heap/#comment-322434" title="Managing the Heap"><STRONG>anoop</STRONG> in Managing the Heap</A></LI>
<LI><A href="http://marknelson.us/2002/07/01/intels-jpeg-library/#comment-322347" title="Intel&#39;s JPEG Library"><STRONG>obfuscated</STRONG> in Intel's JPEG Library</A></LI>
<LI><A href="http://marknelson.us/2002/07/01/cubeshow/#comment-322258" title="CubeShow"><STRONG>Ronald</STRONG> in CubeShow</A></LI>
<LI><A href="http://marknelson.us/2007/04/01/puzzling/#comment-321977" title="Puzzling"><STRONG>Coolkid</STRONG> in Puzzling</A></LI>
<LI><A href="http://marknelson.us/1992/05/01/file-verification-using-crc-2/#comment-321880" title="File Verification Using CRC"><STRONG>Twitter Trackba…</STRONG> in File Verification Using CRC</A></LI>
<LI><A href="http://marknelson.us/1989/10/01/lzw-data-compression/#comment-321790" title="LZW Data Compression"><STRONG>nikos</STRONG> in LZW Data Compression</A></LI>
<LI><A href="http://marknelson.us/2006/06/20/million-digit-challenge/#comment-321706" title="The Million Random Digit Challenge &hellip;"><STRONG>Ernst</STRONG> in The Million Random Digit Challenge …</A></LI>
<LI><A href="http://marknelson.us/2007/08/23/platt/#comment-321699" title="The Father of VoIP Moves On"><STRONG>Bill</STRONG> in The Father of VoIP Moves On</A></LI>
		</UL>
</DIV>

</DIV>
</DIV>
</FONT></DIV><FONT size="2">

</FONT></DIV><FONT size="2">

</FONT></DIV><FONT size="2">



<DIV id="footer_talia">

©1996&nbsp;<A href="http://marknelson.us/">Mark Nelson</A><BR>

Powered by <A href="http://www.wordpress.org/" title="Wordpress CMS">WordPress</A> | Talian designed by VA4Business, <A href="http://www.va4business.com/">Virtual Assistance for Business</A> who's blog can be found at <A href="http://www.va4business.com/business">Steve Arun's Virtual Marketing Blog</A>

</DIV>

<SCRIPT type="text/javascript" charset="utf-8">
/*
 * Some javascript created by Joey to mung all class newpage links and ensure 
 * that they have a target="_blank" destination. - added by MRN
 */
	var links = document.getElementsByTagName('a');
	for (var l=0, pos=0; l < links.length; l++) {
		if(links[l].className.indexOf("newpage") != -1){
			links[l].target = "_blank";
		}	
	}	
</SCRIPT>
<SCRIPT src="./Fast String Searching With Suffix Trees_files/urchin.js" type="text/javascript">
/*
 * My google analytics tracking code - added by MRN
 */
</SCRIPT>
<SCRIPT type="text/javascript">
_uacct = "UA-747044-1";
urchinTracker();
</SCRIPT>



</FONT></BODY></HTML>