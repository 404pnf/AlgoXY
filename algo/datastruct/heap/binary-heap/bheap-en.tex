\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
%\input{../../../common.tex}
\input{../../../common-en.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Binary Heaps with Functional and imperative implementation}

\author{Liu~Xinyu
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
%  Tel:   +86-1305-196-8666 \newline}
  }

\markboth{Binary Heaps}{Imperative and Functional}

\maketitle

\ifx\wholebook\relax
\chapter{Binary Heaps with Functional and imperative implementation}

\section{abstract}
\else
\begin{abstract}
\fi
Heap is one of the elementary data structure. It is widely used
to solve some practical problems, such as sorting, prioritized
scheduling, and graph algorithms\cite{wiki-heap}. 

Most popular implementations of heap are using a kind of implicit
binary heap by array, which is described in ``Introduction to 
Algorithm'' textbook\cite{CLRS}. Examples include C++/STL
heap and Python heapq.

However, heaps can be generalized and implemented with varies
of other data structure besides array. In this post, explicit
binary tree is used to realize heaps. It leads to Leftist heaps
and Splay heaps, which is suitable for pure functional implementation as shown
by Okasaki\cite{okasaki-book}.

There are multiple programming languages used, including
C++, Haskell, Python and Scheme/Lisp.

There may be mistakes in the post, please feel free to point out.

This post is generated by \LaTeXe, and provided with GNU FDL(GNU Free Documentation License).
Please refer to http://www.gnu.org/copyleft/fdl.html for detail.

\ifx\wholebook\relax \else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} Binary Heaps, Leftist Heaps, Splay Heaps

%{\bfseries Corresponding Author:} Liu Xinyu

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

Heap is an important elementary data structure. Most of the algorithm
textbooks introduce heap, especially about binary heap and heap sort.

Some popular implementation, such as C++/STL heap and Python heapq
are based on binary heaps (implicit binary heap by array
more precisely). And the fastest heap sort algorithm is also
written with binary heap as poposed by R. W. Floyd
\cite{wiki-heapsort} \cite{rosetta-heapsort}.

In this post, we use a general definition of heap, so that
varies of under-ground data structures can be used for implementation.
And binary heap is also extended to a wide concept under this definition.

A heap is a data structure that satisifies the following {\em heap property}.
\begin{itemize}
\item Top operation always returns the minimum (maximum) element;
\item Pop operation removes the top element from the heap while the heap
property should be kept, so that the new top element is still the 
minimum (maximum) one;
\item Insert a new element to heap should keep the heap property. That
the new top is still the minimum (maximum) element;
\item Other operations including merge etc should all keep the heap property.
\end{itemize}

This is a kind of recursive definition, while it doesn't limit the under
ground data structure.

We call the heap with top returns the minimum element {\em min-heap},
while if top returns the maximum element, we call it {\em max-heap}.

In this post, I'll first give the definition of binary heap. Then
I'll review the traditional imperative way of implicit heap by array.
After that, by considering explicit heap by binary trees, I'll
explain the Leftist heap, Splay heap, and provide pure functional implementation
for them based on Okasaki's result\cite{okasaki-book}.

As the last part, the computation complexity will be mentioned, and
I'll show in what situation, Leftist heap performs bad.

I'll introduce some other heaps, including Binomial heaps, Fibonacci
heaps, and Paring heaps in a seperate post.

This article provides example implementation in C++, Haskell, Python, and 
Scheme/Lisp languages. 

All source code can be downloaded in appendix \ref{appendix}, please 
refer to appendix for detailed information about build and run.


% ================================================================
%                 Implicit binary heap by array
% ================================================================
\section{Implicit binary heap by array}
\label{ibheap}

Considering the heap definition in previous section, one option to 
implement heap is by using trees. A straightforward solution is
to store the minimum (maximum) element in the root node of the 
tree, so for `top' operation, we simply return the root as the
result. And for `pop' operation, we can remove the root and 
rebuild the tree from the children.

If the tree which is used to implement heap is a binary tree, we
can call it {\em binary heap}. There are three types of binary
heap implementation explained in this post. All of them are
based on binary tree.

% ================================================================
%                 Definition
% ================================================================
\subsection{Definition}

The first one is implicit binary tree indeed. Consider the problem
how to represent a complete binary tree with array. (For example, try to 
represent a complete binary tree in a programming language doesn't support structure
or record data type, so that only array can be used). One solution
is to pack all element from top level (root) down to bottom level (leaves).

Figure \ref{fig:tree-array-map} shows a complete binary tree and
its corresponding array representation.

\begin{figure}[htbp]
       \begin{center}
       	  \includegraphics[scale=0.5]{img/tree-array-map-tree.ps}
          \includegraphics[scale=0.5]{img/tree-array-map-array.ps}
        \caption{Mapping between a complete binary tree and array} \label{fig:tree-array-map}
       \end{center}
\end{figure}

This mapping relationship between tree and array can be denote as 
the following equations (Note that the array index starts from 1).

\begin{algorithmic}[1]
\Function{PARENT}{$i$}
  \State \Return $\lfloor \frac{i}{2} \rfloor$
\EndFunction
\Statex
\Function{LEFT}{$i$}
  \State \Return $2i$
\EndFunction
\Statex
\Function{LEFT}{$i$}
  \State \Return $2i+1$
\EndFunction
\end{algorithmic}

For a given tree node which is represented as the $i$-th element in an
array, since the tree is complete, we can easily find its parent node
as the $\lfloor i/2 \rfloor$-th element in the array; Its left child
with index of $2i$ and right child with index of $2i+1$. If the index
of the child exceeds the length of the array, it simply means this 
node don't have such child.

This mapping calculation can be performed fast if bit-wise operation
is used.

\subsection*{Definition of implicit binary heap by array in C++}
In C++ language, array index starts from zero, but not one. The mapping
from array to binary tree should be adjusted accordingly.

\lstset{language=C++}
\begin{lstlisting}
template<class T>
T parent(T i){ return ((i+1)>>1)-1; }

template<class T>
T left(T i){ return (i<<1)+1; }

template<class T>
T right(T i){ return (i+1)<<1; }
\end{lstlisting}

The tepe T must support bit-wise operation.

\subsection*{Definition of implicit binary heap by array in Python}
Similar as C/C++, the array index in Python starts from 0, so we provide
the mapping functions as below.

\lstset{language=Python}
\begin{lstlisting}
def parent(i):
    return (i+1)//2-1

def left(i):
    return  2*i+1

def right(i):
    return 2*(i+1)
\end{lstlisting}

% ================================================================
%                 Heapify
% ================================================================
\subsection{Heapify}

The most important thing for heap algorithm is to maintain the heap
property, that the top element should be the minimum (maximum) one.

For the implicit binary heap by array, it means for a given node,
which is represented as the $i$-th index, we must develop a algorithm
to check if all its two children conform to this property and incase
there is violation, we need swap the parent and child to fix the 
problem. 

In ``Introduction to Algorithms'' book\cite{CLRS}, this algorithm
is given in a recursive way, here we show a pure imperative solution.
Let's take min-heap for example.

\begin{algorithmic}[1]
\Function{HEAPIFY}{$A, i$}
  \State $n \gets LENGTH(A)$
  \Loop
    \State $l \gets LEFT(i)$
    \State $r \gets RIGHT(i)$
    \State $smallest \gets i$
    \If{$l < n$ and $A[l] < A[i]$}
      \State $smallest \gets l$
    \EndIf
    \If{$r < n$ and $A[r] < A[smallest]$}
      \State $smallest \gets r$
    \EndIf
    \If{$smallest \neq i$}
      \State $exchange A[i] \leftrightarrow A[smallest]$
      \State $i \gets smallest$
    \Else
      \State \Return
    \EndIf
  \EndLoop
\EndFunction
\end{algorithmic}

This algorithm assume that for a given node, the children all conform 
to the heap property, however, we are not sure if the value of this node 
is the smallest compare to its tow children.

For array $A$ and a given index $i$, we need check none its left child or right child
is bigger than $A[i]$, in case we find violation, we pick the smallest one, and set
it as the new value for $A[i]$, the previous value of $A[i]$ is then set as the
new value of the child, and we need go along the child tree to repeat this check and fixing
process until we either reach a leaf node or there is no heap property violation.

Note that the $HEAPIFY$ algorithm takes $O(lg N)$ time.

\subsection*{Heapify in C++}

For C++ program, we need it cover both traditional C compatible array, and
the modern container abstraction. There are several options to realize this
requirement.

One method is to pass iterators as argument to heap algorithm. C++/STL
implementation (at the time the author wrote this post) uses this approach.

The advantage of using iterator is that some random access iterator is
just implemented as C pointers, so it compatible with C array well.

However, this method need us change the algorithm from a array index style
to pointer operation style. It's hard to reflect the above pseudo code
quite clear in such style. Because of this problem, we won't use this approach
here. Reader can refer to STL source code for detailed information.

Another option is to pass the array or container as well as the 
number of elements as arguments. However, we need abstract the 
comparison anyway so that the algorithm works for both max-heap
and min-heap.

\lstset{language=C++}
\begin{lstlisting}
template<class T> struct MinHeap: public std::less<T>{};
template<class T> struct MaxHeap: public std::greater<T>{};
\end{lstlisting}

Here we define MinHeap and MaxHeap as a kind of alias of less-than
and greater-than logic comparison functor template.

The heapify algorithm can be implemented as the following.

\begin{lstlisting}
template<class Array, class LessOp>
void heapify(Array& a, unsigned int i, unsigned int n, LessOp lt){
  while(true){
    unsigned int l=left(i);
    unsigned int r=right(i);
    unsigned int smallest=i;
    if(l < n && lt(a[l], a[i]))
      smallest = l;
    if(r < n && lt(a[r], a[smallest]))
      smallest = r;
    if(smallest != i){
      std::swap(a[i], a[smallest]);
      i = smallest;
    }
    else
      break;
  }
}
\end{lstlisting}

The program accepts the reference of the array (both reference
of the container, and reference to pointer are OK), the index
from where we want to adjust so that all children of it confirms
to the heap property; the number of elements in the array, and
a comparison functor. It checks from the node which is indexed
as $i$ down to the leaf until it find a node that both children are
``less than'' the value of the node based on the comparison functor. 
Otherwise, it will locate the ``smallest'' one and swap it with
the node value.

It is also possible to create a concept of range and realize the 
algorithm with it. Some C++ library, such as boost has already
support range. Here we can develop a light weight range only for
random access container.

\begin{lstlisting}
template<class RIter> // random access iterator
struct Range{
  typedef typename std::iterator_traits<RIter>::value_type value_type;
  typedef typename std::iterator_traits<RIter>::difference_type size_t;
  typedef typename std::iterator_traits<RIter>::reference  reference;
  typedef RIter iterator;

  Range(RIter left, RIter right):first(left), last(right){}

  reference  operator[](size_t i){ return *(first+i); }
  size_t size() const { return last-first; }
  
  RIter first;
  RIter last;
};
\end{lstlisting}

For a given left index $l$, and right index $r$, a range represents
$[l, r)$, So it is easy to construct a range with iterators as well
as the pointer of the array and its length.

Two overloaded auxiliary function templates are provided to create
range easily.

\begin{lstlisting}
template<class Iter>
Range<Iter> range(Iter left, Iter right){ return Range<Iter>(left, right); }

template<class Iter>
Range<Iter> range(Iter left, typename Range<Iter>::size_t n){
  return Range<Iter>(left, left+n);
}
\end{lstlisting}

The above algorithm can be implemented with range like below.

\begin{lstlisting}
template<class R, class LessOp>
void heapify(R a, typename R::size_t i, LessOp lt){
  typename R::size_t l, r, smallest;
  while(true){
    l = left(i);
    r = right(i);
    smallest = i;
    if( l < a.size() && lt(a[l], a[i]))
      smallest = l;
    if( r < a.size() && lt(a[r], a[smallest]))
      smallest = r;
    if( smallest != i){
      std::swap(a[i], a[smallest]);
      i = smallest;
    }
    else
      break;
  }
}
\end{lstlisting}

Almost everything is as same as the former one except that the number
of elements can be given by the size of the range.

In order to verify the program, a same test case as in CLRS figure 6.2
is fed to our function.

\begin{lstlisting}
// test c-array
const int a[] = {16, 4, 10, 14, 7, 9, 3, 2, 8, 1};
const unsigned int n = sizeof(a)/sizeof(a[0]);
int x[n];
std::copy(a, a+n, x);
heapify(x, 1, n, MaxHeap<int>());
print_range(x, x+n);

// test random access container
std::vector<short> y(a, a+n);
heapify(y, 1, n, MaxHeap<short>());
print_range(y.begin(), y.end());
\end{lstlisting}

The same test case can also be applied to the ``range'' version of
program.

\begin{lstlisting}
heapify(range(x, n), 1, MaxHeap<int>());

//...

heapify(range(y.begin(), y.end()), 1, MaxHeap<short>());
\end{lstlisting}

Where ``print\_range'' is a helper function to output all elements
in a container, a C array or a range.

\begin{lstlisting}
template<class Iter>
void print_range(Iter first, Iter last){
  for(; first!=last; ++first)
    std::cout<<*first<<", ";
  std::cout<<"\n";
}

template<class R>
void print_range(R a){
  print_range(a.first, a.last);
}
\end{lstlisting}

The above test code can output a result as below:

\begin{verbatim}
16, 14, 10, 8, 7, 9, 3, 2, 4, 1, 
16, 14, 10, 8, 7, 9, 3, 2, 4, 1,
\end{verbatim}

Figure \ref{fig:heapify} shows how this algorithm works.

\begin{figure}[htbp]
  \begin{center}
    \includegraphics[scale=0.3]{img/heapify-1.ps}

    a. Step 1, 14 is the biggest element among 4, 14, and 7. Swap 4 with the left child;

    \includegraphics[scale=0.3]{img/heapify-2.ps}

    b. Step 2, 8 is the biggest element among 2, 4, and 8. Swap 4 with the right child;

    \includegraphics[scale=0.3]{img/heapify-3.ps}

    c. 4 is the leaf node. It hasn't any children. Process terminates.
    \caption{Heapify example, a max-heap case.} \label{fig:heapify}
  \end{center}
\end{figure}

\subsection*{Heapify in Python}

In order to cover both min-heap and max-heap, we abstract the comparation
as the following lambda expressions.

\lstset{language = Python}
\begin{lstlisting}
MIN_HEAP = lambda a, b: a < b
MAX_HEAP = lambda a, b: a > b 
\end{lstlisting}

By passing the above defined comparation operation as a parameter, the ``Heapify''
algorithm is given as below.

\begin{lstlisting}
def heapify(x, i, less_p = MIN_HEAP):
    n = len(x)
    while True:
        l = left(i)
        r = right(i)
        smallest = i
        if l < n and less_p(x[l], x[i]):
            smallest = l
        if r < n and less_p(x[r], x[smallest]):
            smallest = r
        if smallest != i:
            (x[i], x[smallest])=(x[smallest], x[i])
            i  = smallest
        else:
            break
\end{lstlisting}

We can use the same test case as presents in Figure 6.2 of \cite{CLRS}.

\begin{lstlisting}
l = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1]
heapify(l, 1, MAX_HEAP)
print l 
\end{lstlisting}

The result is something like this.

\begin{verbatim}
[16, 14, 10, 8, 7, 9, 3, 2, 4, 1] 
\end{verbatim}

This result is as same as the one presented in \ref{fig:heapify}.

% ================================================================
%                 Build a heap
% ================================================================
\subsection{Build a heap}

With heapify algorithm, it is easy to build a heap from an arbitary 
array. Observe that the number of nodes in a complete binary tree
for each level is a list like:

$1, 2, 4, 8, ..., 2^i, ...$.

The only exception is the last level. Since the tree may not full
(note that complete binary tree doesn't mean full binary tree), the
last level contains at most $2^{p-1}$ nodes, where $2^p \leq n$ and $n$
is the length of the array.

Heapify algorithm doesn't take any effect on leave node, which means
we can skip applying heapify for all nodes. In other words,  
all leaf nodes have already satisfied heap property. We only need 
start checking and maintaining heap property from the last branch node.
the Index of the last branch node is no greater than $\lfloor n/2 rfloor$.

Based on this fact, we can build a heap with the following algorihm.
(Assume the heap is min-heap).

\begin{algorithmic}[1]
\Function{BUILD-HEAP}{$A$}
  \State $n \gets LENGTH(A)$
  \For{$i \gets \lfloor n/2 \rfloor$ downto $1$}
    \State $HEAPIFY(A, i)$
  \EndFor
\EndFunction
\end{algorithmic}

Altough the complexity of $HEAPIFY$ is $O(lg N)$, the running time
of $BUILD\_HEAP$ doesn't bound to $O(N lg N)$ but to $O(N)$, so this
is a linear time algorithm. Please refer to \cite{CLRS} for the 
detailed proof.

\subsection*{Build a heap in C++}

The only adjustment in C++ program from the above algorithm is
about the starting index from 1 to 0. 

\lstset{language=C++}
\begin{lstlisting}
template<class Array, class LessOp>
void build_heap(Array& a, unsigned int n, LessOp lt){
  unsigned int i = (n-1)>>1;
  while(true){
    heapify(a, i, n, lt);
    if(i==0) break; // this is a trick: unsigned int always >=0
    --i;
  }
}
\end{lstlisting}

Note that since the unsigned type is used to represent index,
It can't lower than zero. We can't just use a for loop as below.

\begin{lstlisting}
for(unsigned int i = (n-1)>>1; i>=0; --i) //wrong, i always >=0
\end{lstlisting}

This program can be easily adjusted with range concept.

\begin{lstlisting}
template<class RangeType, class LessOp>
void build_heap(RangeType a, LessOp lt){
  typename RangeType::size_t i = (a.size()-1)>>1;
  while(true){
    heapify(a, i, lt);
    if(i==0) break;
    --i;
  }
}
\end{lstlisting}

We can test our program with the same data as in Figure 6.3 in \cite{CLRS}.

\begin{lstlisting}
// test c-array
const int a[] = {4, 1, 3, 2, 16, 9, 10, 14, 8, 7};
const unsigned int n = sizeof(a)/sizeof(a[0]);
int x[n];
std::copy(a, a+n, x);
build_heap(range(x, n), MaxHeap<int>());
print_range(x, x+n);

// test random access container
std::vector<int> y(a, a+n);
build_heap(range(y.begin(), y.end()), MaxHeap<short>());
print_range(y.begin(), y.end());
\end{lstlisting}

Running results are printed in console like the following.

\begin{verbatim}
16, 14, 10, 8, 7, 9, 3, 2, 4, 1, 
16, 14, 10, 8, 7, 9, 3, 2, 4, 1,
\end{verbatim}

Figure \ref{fig:build-heap-1} and \ref{fig:build-heap-2} 
show the steps when build a heap from
an arbitary array. The node in black color is the one we will apply
$HEAPIFY$ algorithm, the nodes in gray color are swapped during
$HEAPIFY$.

\begin{figure}[htbp]
  \begin{center}
    \includegraphics[scale=0.3]{img/build-heap-array.ps}

    a. An array in arbitary order before build-heap process;

    \includegraphics[scale=0.3]{img/build-heap-1.ps}

    b. Step 1, The array is mapped to binary tree. The first branch node, which is
16 is to be examined;

    \includegraphics[scale=0.3]{img/build-heap-2.ps}

    c. Step 2, 16 is the largest element in current sub tree, next is to check node
with value 2;
    
    \caption{Build a heap from an arbitary array. Gray nodes are changed in each step,
black node is the one to be processed next step.} \label{fig:build-heap-1}
  \end{center}
\end{figure}

\begin{figure}[htbp]
  \begin{center}
    \includegraphics[scale=0.3]{img/build-heap-3.ps}

    d. Step 3, 14 is the largest value in the subtree, swap 14 and 2; next is to check
node with value 3;

    \includegraphics[scale=0.3]{img/build-heap-4.ps}

    e. Step 4, 10 is the largest value in the subtree, swap 10 and 3; next is to check
node with value 1;

    \includegraphics[scale=0.3]{img/build-heap-5.ps}

    f. Step 5, 16 is the largest value in current node, swap 16 and 1 first; then
similarly, swap 1 and 7; next is to check the root node with value 4;

    \includegraphics[scale=0.3]{img/build-heap-6.ps}

    g. Step 6, Swap 4 and 16, then swap 4 and 14, and then swap 4 and 8; 
And the whole build process finish.

    \caption{Build a heap from an arbitary array. Gray nodes are changed in each step,
black node is the one to be processed next step.} \label{fig:build-heap-2}
  \end{center}
\end{figure}


\subsection*{Build a heap in Python}

Like the C++ heap building program, we check from the last non-leaf
node and apply $HEAPIFY$ algorithm, and repeat the process back to
the root node. However, we use explicit calculation (divided by 2)
instead of using bit-wise shifting.

\lstset{language=Python}
\begin{lstlisting}
def build_heap(x, less_p = MIN_HEAP):
    n = len(x)
    for i in reversed(range(n//2)):
        heapify(x, i, less_p)
\end{lstlisting}

We can feed the similar test case to this program as below:

\begin{lstlisting}
l = [4, 1, 3, 2, 16, 9, 10, 14, 8, 7]
build_heap(l, MAX_HEAP)
print l
\end{lstlisting}

It will output the same result as the C++ program.

\begin{verbatim}
[16, 14, 10, 8, 7, 9, 3, 2, 4, 1]
\end{verbatim}

% ================================================================
%                 Basic heap operations
% ================================================================
\subsection{Basic heap operations}

From the generic definition of heap (not neccessarily binary heap),
It's essential to provides basic operations so that user can access
the data and modify it.

The most important operations included accessing the top element 
(find the minimum or maximum element), pop one element (the minimum
one or the maximum one depends on the type of the heap)
from the heap, find the top N elements, decrease a key (note this 
is for min-heap, and it will be increase a key for max-heap), and
insertion.

For binary tree, most of this operation is bound to $O(lg N)$ worst-case,
some of them, such as top is $O(1)$ time.

\subsubsection{Access the top element (minimum)}
According to the definition of heap, there must be an operation to
return the top element. for implicit binary tree by array, it is the
root node which stores the minimum (maximum) value.

\begin{algorithmic}[1]
\Function{TOP}{$A$}
  \State \Return $A[0]$
\EndFunction
\end{algorithmic}

This operation is trivial. It takes $O(1)$ time.

\subsubsection*{Access the top element in C++}

By translate the above algorithm directly in C++, we get the 
following program.

\lstset{language=C++}
\begin{lstlisting}
template<class T>
typename ValueType<T>::Result heap_top(T a){ return a[0]; }
\end{lstlisting}

There is a small trick to get the type of the element store in 
array no matter if the array is STL container or plain C like
array.

\begin{lstlisting}
template<class T> struct ValueType{
  typedef typename T::value_type Result;
};

template<class T> struct ValueType<T*>{
  typedef T Result; // c-pointer type
};

template<class T, unsigned int n> struct ValueType<T[n]>{
  typedef T Result; // c-array type
};
\end{lstlisting}

Not that the C++ template meta programming support to
specialize for a certain type.

Here we skip the error handling of empty heap case. If the 
heap is empty, one option is just to raise exception.

\subsubsection*{Access the top element in Python}

The python version of this progam is also simple, we omit
the error handling for empty heap as well.

\lstset{language=C++}
\begin{lstlisting}
def heap_top(x):
    return x[0] #ignore empty case
\end{lstlisting}

\subsubsection{Heap Pop (delete minimum)}

Different from the top operation, pop operation is a bit
complex, because the heap property has to be maintained
after the top element is removed.

The solution is to apply $HEAPIFY$ algorithm immediately to the
next node to the root node which has been removed.

A quick but slow algorithm based on this idea may look like
the following.

\begin{algorithmic}[1]
\Function{POP-SLOW}{$A$}
  \State $x \gets TOP(A)$
  \State $REMOVE(A, 1)$
  \If{$A$ is not empty}
    \State $HEAPIFY(A, 1)$
  \EndIf
  \State \Return $x$
\EndFunction
\end{algorithmic}

This algorihm first remember the top element in $x$, then
it removes the first element from the array, the size of
this array reduced by one. After that if the array isn't 
empty, $HEAPIFY$ will applied to the modified array on
the first element (previous the second element).

Removing an element from array takes $O(N)$ time,
where $N$ is the length of the array. Removing the first
element need shift all the rest values one by one.
Because of this bottle neck, it slows the whole algorihtm
to $O(N)$.

In order to solve this program, one alternative way is 
to just swap the first element and the last one in the
array, then shrink the array size by one.

\begin{algorithmic}[1]
\Function{POP}{$A$}
  \State $x \gets TOP(A)$
  \State $SWAP(A[1], A[HEAP-SIZE(A)])$
  \State $REMOVE(A, HEAP-SIZE(A))$
  \If{$A$ is not empty}
    \State $HEAPIFY(A, 1)$
  \EndIf
  \State \Return $x$
\EndFunction
\end{algorithmic}

Note that remove the last element from the array takes 
only $O(1)$ time, and $HEAPIFY$ is bound to $O(lg N)$.
The whole algorithm is bound to $O(lg N)$ time.

\subsubsection*{Pop in C++}

In C++ program, we abstract the min-heap and max-heap as heap type
template parameter, and pass it explicitly.

First is the ``reference + size'' approach.

\lstset{language=C++}
\begin{lstlisting}
template<class T, class LessOp>
typename ValueType<T>::Result heap_pop(T& a, unsigned int& n, LessOp lt){
  typename ValueType<T>::Result top = heap_top(a);
  a[0] = a[n-1];
  heapify(a, 0, --n, lt);
  return top;
}
\end{lstlisting}

And it can be adapted to ``range'' abstraction as well.

\begin{lstlisting}
template<class R, class LessOp>
typename R::value_type heap_pop(R& a, LessOp lt){
  typename R::value_type top = heap_top(a);
  std::swap(a[0], a[a.size()-1]);
  --a.last;
  heapify_(a, 0, lt);
  return top;
}
\end{lstlisting}

\subsubsection*{Pop in Python}

Python provides pop() function to get rid of the last element,
so the program can be developed as below.

\begin{lstlisting}
def heap_pop(x, less_p = MIN_HEAP):
    top = heap_top(x)
    x[0] = x[-1] # this is faster than top = x.pop(0)
    x.pop()
    if x!=[]:
        heapify(x, 0, less_p)
    return top
\end{lstlisting}

\subsubsection{Find the first $K$ biggest (smallest) element}

With pop operation, it is easy to implement algorithm to
find the top $K$ elements. In order to find the biggest $K$
values form an array, we can build a max-heap, then perform
pop operation $K$ times.

\begin{algorithmic}[1]
\Function{TOP-K}{$A, k$}
  \State $BUILD-HEAP(A)$
  \For{$i \gets 1, MIN(k, LENGTH(A))$}
    \State $APPEND(Result, POP(A))$
  \EndFor
  \State \Return $Result$
\EndFunction
\end{algorithmic}

Note that if $K$ is bigger than the length of the array, it means
we need return the whole array as the result. That's why it need
use the $MIN$ function in the algorithm.

\subsubsection*{Find the first $K$ biggest (smallest) element in C++}

In C++ program, we can pass the iterator for output, so the 
``reference - size'' version looks like below.

\lstset{language=C++}
\begin{lstlisting}
template<class Iter, class Array, class LessOp>
void heap_top_k(Iter res, unsigned int k, 
                Array& a, unsigned int& n, LessOp lt){
  build_heap(a, n, lt);
  unsigned int count = std::min(k, n);
  for(unsigned int i=0; i<count; ++i)
    *res++=heap_pop(a, n, lt);
}
\end{lstlisting}

When we adapt to `range' concept, it is possible to manipulate
the data in place, so that we can put the top $K$ element
in first $K$ positions in the array.

\begin{lstlisting}
template<class R, class LessOp>
void heap_top_k(R a, typename R::size_t k, LessOp lt){
  typename R::size_t count = std::min(k, a.size());
  build_heap(a, lt);
  while(count--){
    ++a.first;
    heapify(a, 0, lt);
  }
}
\end{lstlisting}

The algorithm doesn't utilize `pop' function, instead, after
the heap is built, the first elemetn is the top one, it 
adjusts the range one position next, then apply heapify
to the new range. This process is repeated for $K$ times
so the first $K$ elements are the result.

A simple test cases can be fed to the program for verification.

\begin{lstlisting}
const int a[] = {4, 1, 3, 2, 16, 9, 10, 14, 8, 7};
unsigned int n = sizeof(a)/sizeof(a[0]);
std::vector<int> x(a, a+n);
heap_top_k(range(x.begin(), x.end()), 3, MaxHeap<int>());
print_range(range(x.begin(), 3));
\end{lstlisting}

The result is printed in console like below.

\begin{verbatim}
16, 14, 10,
\end{verbatim}

\subsubsection*{Find the first $K$ biggest (smallest) element in Python}

In Python we can put `pop' function to list comprehension to
get the top $K$ elements like the following.

\lstset{language=Python}
\begin{lstlisting}
def top_k(x, k, less_p = MIN_HEAP):
    build_heap(x, less_p)
    return [heap_pop(x, less_p) for i in range(min(k, len(x)))]
\end{lstlisting}

The testing and result are shown as the following.

\begin{lstlisting}
l = [4, 1, 3, 2, 16, 9, 10, 14, 8, 7] 
res = top_k(l, 3, MAX_HEAP)
print res
\end{lstlisting}

Evaluate the code led to below line.

\begin{lstlisting}
[16, 14, 10]
\end{lstlisting}

\subsubsection{Modification: Decrease key}

Heap can be used to implement priority queue, because of this, it
is important to modify the key stored in heap. One typical operation
is to increase the priority of a tasks so that it can be performed
earlier.

Here we present the decrease key operation for a min-heap. The
corresponding operation is increase key for max-heap.

\subsubsection*{Decrease key in C++}

\subsubsection*{Decrease key in Python}

\subsubsection{Insertion}

TODO: direct insertion and insert by decresing key

\subsubsection*{Insertion by decreasing key method in C++}

\subsubsection*{Insertion directly in Python}

% ================================================================
%                 Heap sort
% ================================================================
\subsection{Heap sort}

TODO: general way and Floyd algorithm

\subsection*{Floyd's heap sort algorithm in C++}

\subsection*{General heap sort algorithm in Python}

% ================================================================
%                 Explicit binary heap
% ================================================================
\section{Leftist heap, one of explicit binary heaps}
\label{ebheap}

TODO: general overivew...

Problem with explicit binary tree, balance problem

% ================================================================
%                 Definition
% ================================================================
\subsection{Definition}

TODO: ....

\subsubsection{Rank}

TODO: ...

\subsubsection{Leftist property}

TOOD: ...

\subsubsection{Review the balance problem}

TODO: ...

\subsection*{Definition of Leftist heap in Haskell}

TODO: ...

\lstset{language=Haskell}
\begin{lstlisting}
--...
\end{lstlisting}

TODO: rank auxiliary function

\subsection*{Definition of Leftist heap in Scheme/Lisp}

TODO: ...

\lstset{language=lisp}
\begin{lstlisting}
--...
\end{lstlisting}

% ================================================================
%                 Merge
% ================================================================
\subsection{Merge}

TODO:...

\subsection*{Merge in Haskell}

\subsection*{Merge in Scheme/Lisp}

\subsubsection{Merge operation in implicit binary heap by array}

\subsubsection*{Merge operation in implicit binary heap in C++}

\subsubsection*{Merge operation in implicit binary heap in Python}

% ================================================================
%                 Basic heap operations
% ================================================================
\subsection{Basic heap operations}

\subsubsection{Find minimum (top) and delete minimum (pop)}

\subsubsection*{Find minimum (top) and delete minimum in Haskell}

\subsubsection*{Find minimum (top) and delete minimum in Scheme/Lisp}

\subsubsection{Insertion}

\subsubsection*{Insertion in Haskell}

\subsubsection*{Insertion in Scheme/Lisp}

% ================================================================
%                 Heap sort
% ================================================================
\subsection{Heap sort}

\subsection*{Heap sort in Haskell}

\subsection*{Heap sort in Scheme/Lisp}


% ================================================================
%                 Splay Heap
% ================================================================

\section{Splay heap, another explicit binary heap}
\label{splayheap}

TODO: general overivew...

Another solution to solve the balance problem for BST

% ================================================================
%                 Definition
% ================================================================
\subsection{Definition}

TODO: ....

\subsubsection{Splay}

TODO: ...

\subsection*{Definition of Splay heap in Haskell}

TODO: ...

Okasaki's method and pattern matching method

\lstset{language=Haskell}
\begin{lstlisting}
--...
\end{lstlisting}

\subsection*{Definition of Splay heap in Scheme/Lisp}

TODO: ...

\lstset{language=lisp}
\begin{lstlisting}
--...
\end{lstlisting}

% ================================================================
%                 Basic heap operations
% ================================================================
\subsection{Basic heap operations}

\subsubsection{Insertion}

\subsubsection*{Insertion in Haskell}

\subsubsection*{Insertion in Scheme/Lisp}

\subsubsection{Find minimum (top) and delete minimum (pop)}

\subsubsection*{Find minimum (top) and delete minimum in Haskell}

\subsubsection*{Find minimum (top) and delete minimum in Scheme/Lisp}

% ================================================================
%                 Heap sort
% ================================================================
\subsection{Heap sort}

TODO: code reuse

% ================================================================
%                 Short summary
% ================================================================
\section{Notes and short summary}

TODO: ...

Review to big-O, and balance problem.
Intro of N-way heaps.


% ================================================================
%                 Appendix
% ================================================================
\section{Appendix} \label{appendix}
%\appendix
All programs provided along with this article are free for
downloading.

\subsection{Prerequisite software}
GNU Make is used for easy build some of the program. For C++ and ANSI C programs,
GNU GCC and G++ 3.4.4 are used. 
For Haskell programs GHC 6.10.4 is used
for building. For Python programs, Python 2.5 is used for testing, for
Scheme/Lisp program, MIT Scheme 14.9 is used.

all source files are put in one folder. Invoke 'make' or 'make all'
will build C++ and Haskell program. 

Run 'make Haskell' will separate build Haskell program. the executable
file is ``htest'' (with .exe
in Window like OS). It is also possible to run the program in GHCi.

\subsection{Tools}

Besides them, I use graphviz to draw most of the figures in this post. In order to
translate the B-tree output to dot script. A Haskell tool is provided.
It can be used like this.

\begin{verbatim}
bt2dot filename.dot "string"
\end{verbatim}

Where filename.dot is the output file for the dot script. It can
parse the string which describes B-tree content and translate it 
into dot script.

This source code of this tool is BTr2dot.hs, it can also be downloaded 
with this article.

download position: http://sites.google.com/site/algoxy/btree/btree.zip

\begin{thebibliography}{99}

\bibitem{CLRS}
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. ``Introduction to Algorithms, Second Edition''. The MIT Press, 2001. ISBN: 0262032937.

\bibitem{wiki-heap}
Heap (data structure), Wikipedia. http://en.wikipedia.org/wiki/Heap\_(data\_structure)

\bibitem{wiki-heapsort}
Heapsort, Wikipedia. http://en.wikipedia.org/wiki/Heapsort

\bibitem{okasaki-book}
Chris Okasaki. ``Purely Functional Data Structures''. Cambridge university press, (July 1, 1999), ISBN-13: 978-0521663502

\bibitem{rosetta-heapsort}
Sorting algorithms/Heapsort. Rosetta Code. http://rosettacode.org/wiki/Sorting\_algorithms/Heapsort

\end{thebibliography}

\ifx\wholebook\relax \else
\end{document}
\fi
