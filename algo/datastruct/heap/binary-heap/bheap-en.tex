\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
%\input{../../../common.tex}
\input{../../../common-en.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Binary Heaps with Functional and imperative implementation}

\author{Liu~Xinyu
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
%  Tel:   +86-1305-196-8666 \newline}
  }

\markboth{Binary Heaps}{Imperative and Functional}

\maketitle

\ifx\wholebook\relax
\chapter{Binary Heaps with Functional and imperative implementation}

\section{abstract}
\else
\begin{abstract}
\fi
Heap is one of the elementary data structure. It is widely used
to solve some practical problems, such as sorting, prioritized
scheduling, and graph algorithms\cite{wiki-heap}. 

Most popular implementations of heap are using a kind of implicit
binary heap by array, which is described in ``Introduction to 
Algorithm'' textbook\cite{CLRS}. Examples include C++/STL
heap and Python heapq.

However, heaps can be generalized and implemented with varies
of other data structure besides array. In this post, explicit
binary tree is used to realize heaps. It leads to Leftist heaps
and Splay heaps, which is suitable for pure functional implementation as shown
by Okasaki\cite{okasaki-book}.

There are multiple programming languages used, including
C++, Haskell, Python and Scheme/Lisp.

There may be mistakes in the post, please feel free to point out.

This post is generated by \LaTeXe, and provided with GNU FDL(GNU Free Documentation License).
Please refer to http://www.gnu.org/copyleft/fdl.html for detail.

\ifx\wholebook\relax \else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} Binary Heaps, Leftist Heaps

%{\bfseries Corresponding Author:} Liu Xinyu

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

Heap is an important elementary data structure. Most of the algorithm
textbooks introduce heap, especially about binary heap and heap sort.

Some popular implementation, such as C++/STL heap and Python heapq
are based on binary heaps (implicit binary heap by array
more precisely). And the fastest heap sort algorithm is also
written with binary heap as poposed by R. W. Floyd
\cite{wiki-heapsort} \cite{rosetta-heapsort}.

In this post, we use a general definition of heap, so that
varies of under-ground data structures can be used for implementation.
And binary heap is also extended to a wide concept under this definition.

A heap is a data structure that satisifies the {\em heap property}.
\begin{itemize}
\item Top operation always returns the minimum (maximum) element;
\item Pop operation removes the top element from the heap while the heap
property should be kept, so that the new top element is still the 
minimum (maximum) one;
\item Insert a new element to heap should keep the heap property. That
the top is still the minimum (maximum) element;
\item Other operations including merge etc should all keep the heap property.
\end{itemize}

We call the heap with top returns the minimum element {\em min-heap},
while if top returns the maximum element, we call it {\em max-heap}.

In this post, I'll first give the definition of binary heap. Then
I'll review the traditional imperative way of implicit heap by array.
After that, by considering explicit heap by binary trees, I'll
explain the Leftist heap, Splay heap, and provide pure functional implementation
for them based on Okasaki's result\cite{okasaki-book}.

As the last part, the computation complexity will be mentioned, and
I'll show in what situation, Leftist heap performs bad.

I'll introduce some other heaps, including Binomial heaps, Fibonacci
heaps, and Paring heaps in a seperate post.

This article provides example implementation in C++, Haskell, Python, and 
Scheme/Lisp languages. 

All source code can be downloaded in appendix \ref{appendix}, please 
refer to appendix for detailed information about build and run.


% ================================================================
%                 Implicit binary heap by array
% ================================================================
\section{Implicit binary heap by array}
\label{ibheap}

TODO: General overview...

% ================================================================
%                 Definition
% ================================================================
\subsection{Definition}

TODO: ...

mapping rules

\subsection*{Definition of implicit binary heap by array in C++}
TODO: ...

\lstset{language=C++}
\begin{lstlisting}
//...
\end{lstlisting}

\subsection*{Definition of implicit binary heap by array in Python}
TODO: ...

\lstset{language=Python}
\begin{lstlisting}
#...
\end{lstlisting}

% ================================================================
%                 Heapify
% ================================================================
\subsection{Heapify}

TODO:

\subsection*{Heapify in C++}

TODO: with range

\subsection*{Heapify in Python}

TODO: without range

% ================================================================
%                 Build a heap
% ================================================================
\subsection{Build a heap}

TODO:

\subsection*{Build a heap in C++}

\subsection*{Build a heap in Python}

% ================================================================
%                 Basic heap operations
% ================================================================
\subsection{Basic heap operations}

TODO: top, pop, first-N, decrese kay, and insert

\subsubsection{Access the top element (minimum)}

\subsubsection*{Access the top element in C++}

\subsubsection*{Access the top element in Python}

\subsubsection{Heap Pop (delete minimum)}

\subsubsection*{Pop in C++}

\subsubsection*{Pop in Python}

\subsubsection{Find the first K biggest (smallest) element}

\subsubsection*{Find the first K biggest (smallest) element in C++}

\subsubsection*{Find the first K biggest (smallest) element in Python}

\subsubsection{Modification: Decrease key}

\subsubsection*{Decrease key in C++}

\subsubsection*{Decrease key in Python}

\subsubsection{Insertion}

TODO: direct insertion and insert by decresing key

\subsubsection*{Insertion by decreasing key method in C++}

\subsubsection*{Insertion directly in Python}

% ================================================================
%                 Heap sort
% ================================================================
\subsection{Heap sort}

TODO: general way and Floyd algorithm

\subsection*{Floyd's heap sort algorithm in C++}

\subsection*{General heap sort algorithm in Python}

% ================================================================
%                 Explicit binary heap
% ================================================================
\section{Leftist heap, one of explicit binary heaps}
\label{ebheap}

TODO: general overivew...

Problem with explicit binary tree, balance problem

% ================================================================
%                 Definition
% ================================================================
\subsection{Definition}

TODO: ....

\subsubsection{Rank}

TODO: ...

\subsubsection{Leftist property}

TOOD: ...

\subsubsection{Review the balance problem}

TODO: ...

\subsection*{Definition of Leftist heap in Haskell}

TODO: ...

\lstset{language=Haskell}
\begin{lstlisting}
--...
\end{lstlisting}

TODO: rank auxiliary function

\subsection*{Definition of Leftist heap in Scheme/Lisp}

TODO: ...

\lstset{language=lisp}
\begin{lstlisting}
--...
\end{lstlisting}

% ================================================================
%                 Merge
% ================================================================
\subsection{Merge}

TODO:...

\subsection*{Merge in Haskell}

\subsection*{Merge in Scheme/Lisp}

\subsubsection{Merge operation in implicit binary heap by array}

\subsubsection*{Merge operation in implicit binary heap in C++}

\subsubsection*{Merge operation in implicit binary heap in Python}

% ================================================================
%                 Basic heap operations
% ================================================================
\subsection{Basic heap operations}

\subsubsection{Find minimum (top) and delete minimum (pop)}

\subsubsection*{Find minimum (top) and delete minimum in Haskell}

\subsubsection*{Find minimum (top) and delete minimum in Scheme/Lisp}

\subsubsection{Insertion}

\subsubsection*{Insertion in Haskell}

\subsubsection*{Insertion in Scheme/Lisp}

% ================================================================
%                 Heap sort
% ================================================================
\subsection{Heap sort}

\subsection*{Heap sort in Haskell}

\subsection*{Heap sort in Scheme/Lisp}


% ================================================================
%                 Short summary
% ================================================================
\section{Notes and short summary}

TODO: ...

Review to big-O, and balance problem.
Intro of N-way heaps.


% ================================================================
%                 Appendix
% ================================================================
\section{Appendix} \label{appendix}
%\appendix
All programs provided along with this article are free for
downloading.

\subsection{Prerequisite software}
GNU Make is used for easy build some of the program. For C++ and ANSI C programs,
GNU GCC and G++ 3.4.4 are used. 
For Haskell programs GHC 6.10.4 is used
for building. For Python programs, Python 2.5 is used for testing, for
Scheme/Lisp program, MIT Scheme 14.9 is used.

all source files are put in one folder. Invoke 'make' or 'make all'
will build C++ and Haskell program. 

Run 'make Haskell' will separate build Haskell program. the executable
file is ``htest'' (with .exe
in Window like OS). It is also possible to run the program in GHCi.

\subsection{Tools}

Besides them, I use graphviz to draw most of the figures in this post. In order to
translate the B-tree output to dot script. A Haskell tool is provided.
It can be used like this.

\begin{verbatim}
bt2dot filename.dot "string"
\end{verbatim}

Where filename.dot is the output file for the dot script. It can
parse the string which describes B-tree content and translate it 
into dot script.

This source code of this tool is BTr2dot.hs, it can also be downloaded 
with this article.

download position: http://sites.google.com/site/algoxy/btree/btree.zip

\begin{thebibliography}{99}

\bibitem{CLRS}
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. ``Introduction to Algorithms, Second Edition''. The MIT Press, 2001. ISBN: 0262032937.

\bibitem{wiki-heap}
Heap (data structure), Wikipedia. http://en.wikipedia.org/wiki/Heap\_(data\_structure)

\bibitem{wiki-heapsort}
Heapsort, Wikipedia. http://en.wikipedia.org/wiki/Heapsort

\bibitem{okasaki-book}
Chris Okasaki. ``Purely Functional Data Structures''. Cambridge university press, (July 1, 1999), ISBN-13: 978-0521663502

\bibitem{rosetta-heapsort}
Sorting algorithms/Heapsort. Rosetta Code. http://rosettacode.org/wiki/Sorting\_algorithms/Heapsort

\end{thebibliography}

\ifx\wholebook\relax \else
\end{document}
\fi
