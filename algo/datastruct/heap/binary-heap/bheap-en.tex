\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
%\input{../../../common.tex}
\input{../../../common-en.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Binary Heaps with Functional and imperative implementation}

\author{Liu~Xinyu
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
%  Tel:   +86-1305-196-8666 \newline}
  }

\markboth{Binary Heaps}{Imperative and Functional}

\maketitle

\ifx\wholebook\relax
\chapter{Binary Heaps with Functional and imperative implementation}

\section{abstract}
\else
\begin{abstract}
\fi
Heap is one of the elementary data structure. It is widely used
to solve some practical problems, such as sorting, prioritized
scheduling, and graph algorithms\cite{wiki-heap}. 

Most popular implementations of heap are using a kind of implicit
binary heap by array, which is described in ``Introduction to 
Algorithm'' textbook\cite{CLRS}. Examples include C++/STL
heap and Python heapq.

However, heaps can be generalized and implemented with varies
of other data structure besides array. In this post, explicit
binary tree is used to realize heaps. It leads to Leftist heaps
and Splay heaps, which is suitable for pure functional implementation as shown
by Okasaki\cite{okasaki-book}.

There are multiple programming languages used, including
C++, Haskell, Python and Scheme/Lisp.

There may be mistakes in the post, please feel free to point out.

This post is generated by \LaTeXe, and provided with GNU FDL(GNU Free Documentation License).
Please refer to http://www.gnu.org/copyleft/fdl.html for detail.

\ifx\wholebook\relax \else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} Binary Heaps, Leftist Heaps, Splay Heaps

%{\bfseries Corresponding Author:} Liu Xinyu

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

Heap is an important elementary data structure. Most of the algorithm
textbooks introduce heap, especially about binary heap and heap sort.

Some popular implementation, such as C++/STL heap and Python heapq
are based on binary heaps (implicit binary heap by array
more precisely). And the fastest heap sort algorithm is also
written with binary heap as poposed by R. W. Floyd
\cite{wiki-heapsort} \cite{rosetta-heapsort}.

In this post, we use a general definition of heap, so that
varies of under-ground data structures can be used for implementation.
And binary heap is also extended to a wide concept under this definition.

A heap is a data structure that satisifies the following {\em heap property}.
\begin{itemize}
\item Top operation always returns the minimum (maximum) element;
\item Pop operation removes the top element from the heap while the heap
property should be kept, so that the new top element is still the 
minimum (maximum) one;
\item Insert a new element to heap should keep the heap property. That
the new top is still the minimum (maximum) element;
\item Other operations including merge etc should all keep the heap property.
\end{itemize}

This is a kind of recursive definition, while it doesn't limit the under
ground data structure.

We call the heap with top returns the minimum element {\em min-heap},
while if top returns the maximum element, we call it {\em max-heap}.

In this post, I'll first give the definition of binary heap. Then
I'll review the traditional imperative way of implicit heap by array.
After that, by considering explicit heap by binary trees, I'll
explain the Leftist heap, Splay heap, and provide pure functional implementation
for them based on Okasaki's result\cite{okasaki-book}.

As the last part, the computation complexity will be mentioned, and
I'll show in what situation, Leftist heap performs bad.

I'll introduce some other heaps, including Binomial heaps, Fibonacci
heaps, and Paring heaps in a seperate post.

This article provides example implementation in C++, Haskell, Python, and 
Scheme/Lisp languages. 

All source code can be downloaded in appendix \ref{appendix}, please 
refer to appendix for detailed information about build and run.


% ================================================================
%                 Implicit binary heap by array
% ================================================================
\section{Implicit binary heap by array}
\label{ibheap}

Considering the heap definition in previous section, one option to 
implement heap is by using trees. A straightforward solution is
to store the minimum (maximum) element in the root node of the 
tree, so for `top' operation, we simply return the root as the
result. And for `pop' operation, we can remove the root and 
rebuild the tree from the children.

If the tree which is used to implement heap is a binary tree, we
can call it {\em binary heap}. There are three types of binary
heap implementation explained in this post. All of them are
based on binary tree.

% ================================================================
%                 Definition
% ================================================================
\subsection{Definition}

The first one is implicit binary tree indeed. Consider the problem
how to represent a complete binary tree with array. (For example, try to 
represent a complete binary tree in a programming language doesn't support structure
or record data type, so that only array can be used). One solution
is to pack all element from top level (root) down to bottom level (leaves).

Figure \ref{fig:tree-array-map} shows a complete binary tree and
its corresponding array representation.

\begin{figure}[htbp]
       \begin{center}
       	  \includegraphics[scale=0.5]{img/tree-array-map-tree.ps}
          \includegraphics[scale=0.5]{img/tree-array-map-array.ps}
        \caption{Mapping between a complete binary tree and array} \label{fig:tree-array-map}
       \end{center}
\end{figure}

This mapping relationship between tree and array can be denote as 
the following equations (Note that the array index starts from 1).

\begin{algorithmic}[1]
\Function{PARENT}{$i$}
  \State \Return $\lfloor \frac{i}{2} \rfloor$
\EndFunction
\Statex
\Function{LEFT}{$i$}
  \State \Return $2i$
\EndFunction
\Statex
\Function{LEFT}{$i$}
  \State \Return $2i+1$
\EndFunction
\end{algorithmic}

For a given tree node which is represented as the $i$-th element in an
array, since the tree is complete, we can easily find its parent node
as the $\lfloor i/2 \rfloor$-th element in the array; Its left child
with index of $2i$ and right child with index of $2i+1$. If the index
of the child exceeds the length of the array, it simply means this 
node don't have such child.

This mapping calculation can be performed fast if bit-wise operation
is used.

\subsection*{Definition of implicit binary heap by array in C++}
In C++ language, array index starts from zero, but not one. The mapping
from array to binary tree should be adjusted accordingly.

\lstset{language=C++}
\begin{lstlisting}
template<class T>
T parent(T i){ return ((i+1)>>1)-1; }

template<class T>
T left(T i){ return (i<<1)+1; }

template<class T>
T right(T i){ return (i+1)<<1; }
\end{lstlisting}

The tepe T must support bit-wise operation.

\subsection*{Definition of implicit binary heap by array in Python}
Similar as C/C++, the array index in Python starts from 0, so we provide
the mapping functions as below.

\lstset{language=Python}
\begin{lstlisting}
def parent(i):
    return (i+1)//2-1

def left(i):
    return  2*i+1

def right(i):
    return 2*(i+1)
\end{lstlisting}

% ================================================================
%                 Heapify
% ================================================================
\subsection{Heapify}

The most important thing for heap algorithm is to maintain the heap
property, that the top element should be the minimum (maximum) one.

For the implicit binary heap by array, it means for a given node,
which is represented as the $i$-th index, we must develop a algorithm
to check if all its two children conform to this property and incase
there is violation, we need swap the parent and child to fix the 
problem. 

In ``Introduction to Algorithms'' book\cite{CLRS}, this algorithm
is given in a recursive way, here we show a pure imperative solution.
Let's take min-heap for example.

\begin{algorithmic}[1]
\Function{HEAPIFY}{$A, i$}
  \State $n \gets LENGTH(A)$
  \Loop
    \State $l \gets LEFT(i)$
    \State $r \gets RIGHT(i)$
    \State $smallest \gets i$
    \If{$l < n$ and $A[l] < A[i]$}
      \State $smallest \gets l$
    \EndIf
    \If{$r < n$ and $A[r] < A[smallest]$}
      \State $smallest \gets r$
    \EndIf
    \If{$smallest \neq i$}
      \State $exchange A[i] \leftrightarrow A[smallest]$
      \State $i \gets smallest$
    \Else
      \State \Return
    \EndIf
  \EndLoop
\EndFunction
\end{algorithmic}

This algorithm assume that for a given node, the children all conform to the heap property, however, we are not sure if the value of this node is the smallest compare to its
tow children.

For array $A$ and a given index $i$, we need check none its left child or right child
is bigger than $A[i]$, in case we find violation, we pick the smallest one, and set
it as the new value for $A[i]$, the previous value of $A[i]$ is then set as the
new value of the child, and we need go along the child tree to repeat this check and fixing
process until we either reach a leaf node or there is no heap property violation.

\subsection*{Heapify in C++}

For C++ program, we need it cover both traditional C compatible array, and
the modern container abstraction. There are several options to realize this
requirement.

One method is to pass iterators as argument to heap algorithm. C++/STL
implementation (at the time the author wrote this post) uses this approach.

The advantage of using iterator is that some random access iterator is
just implemented as C pointers, so it compatible with C array well.

However, this method need us change the algorithm from a array index style
to pointer operation style. It's hard to reflect the above pseudo code
quite clear in such style. Because of this problem, we won't use this approach
here. Reader can refer to STL source code for detailed information.

Another option is to pass the array or container as well as the 
number of elements as arguments. However, we need abstract the 
comparison anyway so that the algorithm works for both max-heap
and min-heap.

\lstset{language=C++}
\begin{lstlisting}
template<class T> struct MinHeap: public std::less<T>{};
template<class T> struct MaxHeap: public std::greater<T>{};
\end{lstlisting}

Here we define MinHeap and MaxHeap as a kind of alias of less-than
and greater-than logic comparison functor template.

The heapify algorithm can be implemented as the following.

\begin{lstlisting}
template<class Array, class LessOp>
void heapify(Array& a, unsigned int i, unsigned int n, LessOp lt){
  while(true){
    unsigned int l=left(i);
    unsigned int r=right(i);
    unsigned int smallest=i;
    if(l < n && lt(a[l], a[i]))
      smallest = l;
    if(r < n && lt(a[r], a[smallest]))
      smallest = r;
    if(smallest != i){
      std::swap(a[i], a[smallest]);
      i = smallest;
    }
    else
      break;
  }
}
\end{lstlisting}

It is also possible to create a concept of range and realize the 
algorithm with it. Some C++ library, such as boost has already
support range. Here we can develop a light weight range only for
random access container.

\begin{lstlisting}
template<class RIter> // random access iterator
struct Range{
  typedef typename std::iterator_traits<RIter>::value_type value_type;
  typedef typename std::iterator_traits<RIter>::difference_type size_t;
  typedef typename std::iterator_traits<RIter>::reference  reference;
  typedef RIter iterator;

  Range(RIter left, RIter right):first(left), last(right){}

  reference  operator[](size_t i){ return *(first+i); }
  size_t size() const { return last-first; }
  
  RIter first;
  RIter last;
};
\end{lstlisting}

For a given left index $l$, and right index $r$, a range represents
$[l, r)$, So it is easy to construct a range with iterators as well
as the pointer of the array and its length.

Two overloaded auxiliary function templates are provided to create
range easily.

\begin{lstlisting}
template<class Iter>
Range<Iter> range(Iter left, Iter right){ return Range<Iter>(left, right); }

template<class Iter>
Range<Iter> range(Iter left, typename Range<Iter>::size_t n){
  return Range<Iter>(left, left+n);
}
\end{lstlisting}

The above algorithm can be implemented with range like below.

\begin{lstlisting}
template<class R, class LessOp>
void heapify(R a, typename R::size_t i, LessOp lt){
  typename R::size_t l, r, smallest;
  while(true){
    l = left(i);
    r = right(i);
    smallest = i;
    if( l < a.size() && lt(a[l], a[i]))
      smallest = l;
    if( r < a.size() && lt(a[r], a[smallest]))
      smallest = r;
    if( smallest != i){
      std::swap(a[i], a[smallest]);
      i = smallest;
    }
    else
      break;
  }
}
\end{lstlisting}

In order to verify the program, a same test case as in CLRS figure 6.2
is fed to our function.

\begin{lstlisting}
// test c-array
const int a[] = {16, 4, 10, 14, 7, 9, 3, 2, 8, 1};
const unsigned int n = sizeof(a)/sizeof(a[0]);
int x[n];
std::copy(a, a+n, x);
heapify(x, 1, n, MaxHeap<int>());
print_range(x, x+n);

// test random access container
std::vector<short> y(a, a+n);
heapify(y, 1, n, MaxHeap<short>());
print_range(y.begin(), y.end());
\end{lstlisting}

The same test case can also be applied to the ``range'' version of
program.

\begin{lstlisting}
heapify(range(x, n), 1, MaxHeap<int>());

//...

heapify(range(y.begin(), y.end()), 1, MaxHeap<short>());
\end{lstlisting}

Where ``print\_range'' is a helper function to output all elements
in a container, a C array or a range.

\begin{lstlisting}
template<class Iter>
void print_range(Iter first, Iter last){
  for(; first!=last; ++first)
    std::cout<<*first<<", ";
  std::cout<<"\n";
}

template<class R>
void print_range(R a){
  print_range(a.first, a.last);
}
\end{lstlisting}

The above test code can output a result as below:

\begin{verbatim}
16, 14, 10, 8, 7, 9, 3, 2, 4, 1, 
16, 14, 10, 8, 7, 9, 3, 2, 4, 1,
\end{verbatim}

Figure \ref{fig:heapify} shows how this algorithm works.

TODO: put CLRS figure 6.2 here

\subsection*{Heapify in Python}

In order to cover both min-heap and max-heap, we abstract the comparation
as the following.

\lstset{language = Python}
\begin{lstlisting}
MIN_HEAP = lambda a, b: a < b
MAX_HEAP = lambda a, b: a > b 
\end{lstlisting}

By passing the above defined comparation operation as a parameter, the ``Heapify''
algorithm is given as below.

\begin{lstlisting}
def heapify(x, i, less_p = MIN_HEAP):
    n = len(x)
    while True:
        l = left(i)
        r = right(i)
        smallest = i
        if l < n and less_p(x[l], x[i]):
            smallest = l
        if r < n and less_p(x[r], x[smallest]):
            smallest = r
        if smallest != i:
            (x[i], x[smallest])=(x[smallest], x[i])
            i  = smallest
        else:
            break
\end{lstlisting}

We can use the same test case as presents in Figure 6.2 of \cite{CLRS}.

\begin{lstlisting}
l = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1]
heapify(l, 1, MAX_HEAP)
print l 
\end{lstlisting}

The result is something like this.

\begin{verbatim}
[16, 14, 10, 8, 7, 9, 3, 2, 4, 1] 
\end{verbatim}

% ================================================================
%                 Build a heap
% ================================================================
\subsection{Build a heap}

TODO:

\subsection*{Build a heap in C++}

\subsection*{Build a heap in Python}

% ================================================================
%                 Basic heap operations
% ================================================================
\subsection{Basic heap operations}

TODO: top, pop, first-N, decrese kay, and insert

\subsubsection{Access the top element (minimum)}

\subsubsection*{Access the top element in C++}

\subsubsection*{Access the top element in Python}

\subsubsection{Heap Pop (delete minimum)}

\subsubsection*{Pop in C++}

\subsubsection*{Pop in Python}

\subsubsection{Find the first K biggest (smallest) element}

\subsubsection*{Find the first K biggest (smallest) element in C++}

\subsubsection*{Find the first K biggest (smallest) element in Python}

\subsubsection{Modification: Decrease key}

\subsubsection*{Decrease key in C++}

\subsubsection*{Decrease key in Python}

\subsubsection{Insertion}

TODO: direct insertion and insert by decresing key

\subsubsection*{Insertion by decreasing key method in C++}

\subsubsection*{Insertion directly in Python}

% ================================================================
%                 Heap sort
% ================================================================
\subsection{Heap sort}

TODO: general way and Floyd algorithm

\subsection*{Floyd's heap sort algorithm in C++}

\subsection*{General heap sort algorithm in Python}

% ================================================================
%                 Explicit binary heap
% ================================================================
\section{Leftist heap, one of explicit binary heaps}
\label{ebheap}

TODO: general overivew...

Problem with explicit binary tree, balance problem

% ================================================================
%                 Definition
% ================================================================
\subsection{Definition}

TODO: ....

\subsubsection{Rank}

TODO: ...

\subsubsection{Leftist property}

TOOD: ...

\subsubsection{Review the balance problem}

TODO: ...

\subsection*{Definition of Leftist heap in Haskell}

TODO: ...

\lstset{language=Haskell}
\begin{lstlisting}
--...
\end{lstlisting}

TODO: rank auxiliary function

\subsection*{Definition of Leftist heap in Scheme/Lisp}

TODO: ...

\lstset{language=lisp}
\begin{lstlisting}
--...
\end{lstlisting}

% ================================================================
%                 Merge
% ================================================================
\subsection{Merge}

TODO:...

\subsection*{Merge in Haskell}

\subsection*{Merge in Scheme/Lisp}

\subsubsection{Merge operation in implicit binary heap by array}

\subsubsection*{Merge operation in implicit binary heap in C++}

\subsubsection*{Merge operation in implicit binary heap in Python}

% ================================================================
%                 Basic heap operations
% ================================================================
\subsection{Basic heap operations}

\subsubsection{Find minimum (top) and delete minimum (pop)}

\subsubsection*{Find minimum (top) and delete minimum in Haskell}

\subsubsection*{Find minimum (top) and delete minimum in Scheme/Lisp}

\subsubsection{Insertion}

\subsubsection*{Insertion in Haskell}

\subsubsection*{Insertion in Scheme/Lisp}

% ================================================================
%                 Heap sort
% ================================================================
\subsection{Heap sort}

\subsection*{Heap sort in Haskell}

\subsection*{Heap sort in Scheme/Lisp}


% ================================================================
%                 Splay Heap
% ================================================================

\section{Splay heap, another explicit binary heap}
\label{splayheap}

TODO: general overivew...

Another solution to solve the balance problem for BST

% ================================================================
%                 Definition
% ================================================================
\subsection{Definition}

TODO: ....

\subsubsection{Splay}

TODO: ...

\subsection*{Definition of Splay heap in Haskell}

TODO: ...

Okasaki's method and pattern matching method

\lstset{language=Haskell}
\begin{lstlisting}
--...
\end{lstlisting}

\subsection*{Definition of Splay heap in Scheme/Lisp}

TODO: ...

\lstset{language=lisp}
\begin{lstlisting}
--...
\end{lstlisting}

% ================================================================
%                 Basic heap operations
% ================================================================
\subsection{Basic heap operations}

\subsubsection{Insertion}

\subsubsection*{Insertion in Haskell}

\subsubsection*{Insertion in Scheme/Lisp}

\subsubsection{Find minimum (top) and delete minimum (pop)}

\subsubsection*{Find minimum (top) and delete minimum in Haskell}

\subsubsection*{Find minimum (top) and delete minimum in Scheme/Lisp}

% ================================================================
%                 Heap sort
% ================================================================
\subsection{Heap sort}

TODO: code reuse

% ================================================================
%                 Short summary
% ================================================================
\section{Notes and short summary}

TODO: ...

Review to big-O, and balance problem.
Intro of N-way heaps.


% ================================================================
%                 Appendix
% ================================================================
\section{Appendix} \label{appendix}
%\appendix
All programs provided along with this article are free for
downloading.

\subsection{Prerequisite software}
GNU Make is used for easy build some of the program. For C++ and ANSI C programs,
GNU GCC and G++ 3.4.4 are used. 
For Haskell programs GHC 6.10.4 is used
for building. For Python programs, Python 2.5 is used for testing, for
Scheme/Lisp program, MIT Scheme 14.9 is used.

all source files are put in one folder. Invoke 'make' or 'make all'
will build C++ and Haskell program. 

Run 'make Haskell' will separate build Haskell program. the executable
file is ``htest'' (with .exe
in Window like OS). It is also possible to run the program in GHCi.

\subsection{Tools}

Besides them, I use graphviz to draw most of the figures in this post. In order to
translate the B-tree output to dot script. A Haskell tool is provided.
It can be used like this.

\begin{verbatim}
bt2dot filename.dot "string"
\end{verbatim}

Where filename.dot is the output file for the dot script. It can
parse the string which describes B-tree content and translate it 
into dot script.

This source code of this tool is BTr2dot.hs, it can also be downloaded 
with this article.

download position: http://sites.google.com/site/algoxy/btree/btree.zip

\begin{thebibliography}{99}

\bibitem{CLRS}
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. ``Introduction to Algorithms, Second Edition''. The MIT Press, 2001. ISBN: 0262032937.

\bibitem{wiki-heap}
Heap (data structure), Wikipedia. http://en.wikipedia.org/wiki/Heap\_(data\_structure)

\bibitem{wiki-heapsort}
Heapsort, Wikipedia. http://en.wikipedia.org/wiki/Heapsort

\bibitem{okasaki-book}
Chris Okasaki. ``Purely Functional Data Structures''. Cambridge university press, (July 1, 1999), ISBN-13: 978-0521663502

\bibitem{rosetta-heapsort}
Sorting algorithms/Heapsort. Rosetta Code. http://rosettacode.org/wiki/Sorting\_algorithms/Heapsort

\end{thebibliography}

\ifx\wholebook\relax \else
\end{document}
\fi
