\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
%\input{../../../common.tex}
\input{../../../common-en.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{K-ary Heaps with Functional and imperative implementation}

\author{Liu~Xinyu
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
  }

\markboth{K-ary Heaps}{Imperative and Functional}

\maketitle

\ifx\wholebook\relax
\chapter{K-ary Heaps with Functional and imperative implementation}

\section{abstract}
\else
\begin{abstract}
\fi
In my previous post \cite{lxy-bheap}, it's mentioned that heaps can be
generalized and implemented with varies of data structures. However,
only binary heaps are focused in that post no matter by explicit binary
trees or implicit array. 

It's quite natural to extend the binary tree to K-ary tree which yields
K-ary heaps. In this post, we first show Binomial heaps which is actually
consist of forest of K-ary trees. If we delay some operation in Binomial
heaps by using lazy strategy, it turns to be Fibonacci heap, which increases
almost all operations to good amortized time bound. The pairing heaps,
as the best performance in practice is shown at last.

Most functional implementation is based on Okasaki's work \cite{okasaki-book}.
There are multiple programming languages used, including C++, Haskell, 
Python and Scheme/Lisp.

There may be mistakes in the post, please feel free to point out.

This post is generated by \LaTeXe, and provided with GNU FDL(GNU Free Documentation License).
Please refer to http://www.gnu.org/copyleft/fdl.html for detail.

\ifx\wholebook\relax \else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} Binomail Heaps, Fibonacci Heaps, Pairing Heaps

%{\bfseries Corresponding Author:} Liu Xinyu

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

In previous post, we addressed heaps implemented by binary trees, including
implicit complete binary tree by array, Leftist tree which is a type of 
unbalanced lean binary tree, and Splay tree which is in fact binary search
tree. If extends the binary tree to K-ary tree, some interesting heaps
can be implemented. All binary heaps shown in \cite{lxy-bheap} perform
no less than $O(\lg N)$ time for merging, we'll show it's possible to 
improve it to $O(1)$ which is quite helpful to graph algorithms.

In this post, we start from Binomail heaps, which gain the performance for
all operations to $O(\lg N)$, as well as keeping the finding minimum element to 
$O(1)$ time. After that, we'll examine Fibonacci heaps. It improves most 
operations to $O(1)$ time, and left heap pop to $O(\lg N)$ amortized time.
As Fibonacci heap is complex at least in imperative settings, pairing heap
provides simple implementation and it is one of the best heap in practice.
However, the performance of pairing heap is still a conjecture for the
time being.

For each heap, I'll provide both imperative and functional implementations.
in C++, Haskell, Python, and Scheme/Lisp languages. 

All source code can be downloaded in appendix \ref{appendix}, please 
refer to appendix for detailed information about build and run.


% ================================================================
%                 Binomial heap
% ================================================================
\section{Binamial Heaps}
\label{binomail-heap}


% ================================================================
%                 Definition
% ================================================================
\subsection{Definition}

Binomial heap is more complex than most of the binary heaps. However,
it has excellent merge performance which bound to $O(\lg N)$ time. A
binomial heap is consist of a list of binomial trees.

In order to explain why the name of the tree is `binomial', let's review
the famouse Pascal's triangle (in China, we call it Yang Hui's triangle)
\cite{wiki-pascal-triangle}.

\begin{verbatim}
    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1
...
\end{verbatim}

In each row, the numbers are all binomial coefficients. There are many
ways to gain a series of binomial coefficient numbers. One of them is
by using recusive composition. Binomial trees, as well, can be defined
in this way as the following.

\begin{itemize}
\item A binomial tree of rank 0 has only a node as the root;
\item A binomial tree of rank $N$ is consist of two rank $N-1$ binomail trees,
Among these 2 sub trees, the one has the bigger root element is linked as the
leftmost child of the other.
\end{itemize}

We denote a binomial tree of rank 0 as $B_0$, and the binomial tree of rank
$n$ as $B_n$.

Figure \ref{fig:link-bitree} shows a $B_0$ tree and how to link 2 $B_{n-1}$
trees to a $B_n$ tree.

\begin{figure}[htbp]
       \begin{center}
       	  \includegraphics[scale=0.5]{img/b0tree.ps}

          a. $B_0$ tree; 

          \includegraphics[scale=0.5]{img/link-bitree.ps}

          b. Linking 2 $B_{n-1}$ tree yields a $B_n$ tree

        \caption{Recursive definition of binomial trees} \label{fig:link-bitree}
       \end{center}
\end{figure}

With this recursive definition, it easy to draw the form of binomial trees
of rank 0, 1, 2, ..., as shown in figure \ref{fig:bitree-forms}

\begin{figure}[htbp]
       \begin{center}
       	  \includegraphics[scale=0.5]{img/b0tree.ps}

          a. $B_0$ tree; 

          \includegraphics[scale=0.5]{img/b1tree.ps}

          b. $B_1$ tree;

          \includegraphics[scale=0.5]{img/b2tree.ps}

          c. $B_2$ tree;

          \includegraphics[scale=0.5]{img/b3tree.ps}

          c. $B_3$ tree;

          \includegraphics[scale=0.5]{img/b4tree.ps}

          d. $B_4$ tree; ...

        \caption{Forms of binomial trees with rank = 0, 1, 2, 3, 4, ...} \label{fig:bitree-forms}
       \end{center}
\end{figure}


\subsection*{Definition of binomial heap in C++}

\subsection*{Definition of binomail heap in Python}

% ================================================================
%                 Basic heap operation
% ================================================================
\subsection{Basic heap operations}

\subsubsection{Find the minimum element in the heap (top)}

\subsubsection{Merge two heaps}

\subsubsection{Insert a new element to the heap}

\subsubsection{Extract the minimum element from the heap (pop)}

\subsubsection{Decrease an element}

\subsubsection{Delete an element}

% ================================================================
%                 Fibonacci heaps
% ================================================================
\section{Fibonacci Heaps}
\label{fib-heap}

% ================================================================
%                 Definition
% ================================================================
\subsection{Definition}

% ================================================================
%          Basic Heap operations       
% ================================================================
\subsection{Basic heap operations}

\subsubsection{Find the minimum element in the heap (top)}

\subsubsection{Insert a new element to the heap}

\subsubsection{Merge two heaps}

\subsubsection{Extract the minimum element from the heap (pop)}

\subsubsection{Decrease an element}

\subsubsection{Delete an element}

\subsection{Running times}


% ================================================================
%                 Pairing Heaps
% ================================================================

\section{Pairing Heaps}
\label{pairing-heap}

% ================================================================
%                 Definition
% ================================================================
\subsection{Definition}

% ================================================================
%          Basic Heap operations       
% ================================================================
\subsection{Basic heap operations}

\subsubsection{Find the minimum element in the heap (top)}

\subsubsection{Insert a new element to the heap}

\subsubsection{Merge two heaps}

\subsubsection{Extract the minimum element from the heap (pop)}

\subsubsection{Decrease an element}

\subsubsection{Delete an element}

% ================================================================
%                 Short summary
% ================================================================
\section{Notes and short summary}

% ================================================================
%                 Appendix
% ================================================================
\section{Appendix} \label{appendix}
%\appendix
All programs provided along with this article are free for
downloading.

\subsection{Prerequisite software}
GNU Make is used for easy build some of the program. For C++ and ANSI C programs,
GNU GCC and G++ 3.4.4 are used. 
For Haskell programs GHC 6.10.4 is used
for building. For Python programs, Python 2.5 is used for testing, for
Scheme/Lisp program, MIT Scheme 14.9 is used.

all source files are put in one folder. Invoke 'make' or 'make all'
will build C++ Program. 

There is no separate Haskell main program module, however, it is possible to run the program in GHCi.

\begin{itemize}
\item files

\end{itemize}

download position: http://sites.google.com/site/algoxy/otherheaps/otherheaps.zip

\begin{thebibliography}{99}

\bibitem{CLRS}
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. ``Introduction to Algorithms, Second Edition''. The MIT Press, 2001. ISBN: 0262032937.

\bibitem{okasaki-book}
Chris Okasaki. ``Purely Functional Data Structures''. Cambridge university press, (July 1, 1999), ISBN-13: 978-0521663502

\bibitem{wiki-pascal-triangle}
Wikipedia, ``Pascal's triangle''. http://en.wikipedia.org/wiki/Pascal's\_triangle

\bibitem{lxy-bheap}
Liu Xinyu. ``Binary heaps with functional and imperative implementation'', https://sites.google.com/site/algoxy/bheap

\end{thebibliography}

\ifx\wholebook\relax \else
\end{document}
\fi
