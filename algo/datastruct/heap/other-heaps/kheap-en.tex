\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
%\input{../../../common.tex}
\input{../../../common-en.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{K-ary Heaps with Functional and imperative implementation}

\author{Liu~Xinyu
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline}
  }

\markboth{K-ary Heaps}{Imperative and Functional}

\maketitle

\ifx\wholebook\relax
\chapter{K-ary Heaps with Functional and imperative implementation}

\section{abstract}
\else
\begin{abstract}
\fi
In my previous post \cite{lxy-bheap}, it's mentioned that heaps can be
generalized and implemented with varies of data structures. However,
only binary heaps are focused in that post no matter by explicit binary
trees or implicit array. 

It's quite natural to extend the binary tree to K-ary tree which yields
K-ary heaps. In this post, we first show Binomial heaps which is actually
consist of forest of K-ary trees. If we delay some operation in Binomial
heaps by using lazy strategy, it turns to be Fibonacci heap, which increases
almost all operations to good amortized time bound. The pairing heaps,
as the best performance in practice is shown at last.

Most functional implementation is based on Okasaki's work \cite{okasaki-book}.
There are multiple programming languages used, including C++, Haskell, 
Python and Scheme/Lisp.

There may be mistakes in the post, please feel free to point out.

This post is generated by \LaTeXe, and provided with GNU FDL(GNU Free Documentation License).
Please refer to http://www.gnu.org/copyleft/fdl.html for detail.

\ifx\wholebook\relax \else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} Binomail Heaps, Fibonacci Heaps, Pairing Heaps

%{\bfseries Corresponding Author:} Liu Xinyu

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

In previous post, we addressed heaps implemented by binary trees, including
implicit complete binary tree by array, Leftist tree which is a type of 
unbalanced lean binary tree, and Splay tree which is in fact binary search
tree. If extends the binary tree to K-ary tree, some interesting heaps
can be implemented. All binary heaps shown in \cite{lxy-bheap} perform
no less than $O(\lg N)$ time for merging, we'll show it's possible to 
improve it to $O(1)$ which is quite helpful to graph algorithms.

In this post, we start from Binomail heaps, which gain the performance for
all operations to $O(\lg N)$, as well as keeping the finding minimum element to 
$O(1)$ time. After that, we'll examine Fibonacci heaps. It improves most 
operations to $O(1)$ time, and left heap pop to $O(\lg N)$ amortized time.
As Fibonacci heap is complex at least in imperative settings, pairing heap
provides simple implementation and it is one of the best heap in practice.
However, the performance of pairing heap is still a conjecture for the
time being.

For each heap, I'll provide both imperative and functional implementations.
in C++, Haskell, Python, and Scheme/Lisp languages. 

All source code can be downloaded in appendix \ref{appendix}, please 
refer to appendix for detailed information about build and run.


% ================================================================
%                 Binomial heap
% ================================================================
\section{Binomial Heaps}
\label{binomail-heap}


% ================================================================
%                 Definition
% ================================================================
\subsection{Definition}

Binomial heap is more complex than most of the binary heaps. However,
it has excellent merge performance which bound to $O(\lg N)$ time. A
binomial heap is consist of a list of binomial trees.

\subsubsection{Binomial tree}

In order to explain why the name of the tree is `binomial', let's review
the famouse Pascal's triangle (in China, we call it Yang Hui's triangle)
\cite{wiki-pascal-triangle}.

\begin{verbatim}
    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1
...
\end{verbatim}

In each row, the numbers are all binomial coefficients. There are many
ways to gain a series of binomial coefficient numbers. One of them is
by using recusive composition. Binomial trees, as well, can be defined
in this way as the following.

\begin{itemize}
\item A binomial tree of rank 0 has only a node as the root;
\item A binomial tree of rank $N$ is consist of two rank $N-1$ binomail trees,
Among these 2 sub trees, the one has the bigger root element is linked as the
leftmost child of the other.
\end{itemize}

We denote a binomial tree of rank 0 as $B_0$, and the binomial tree of rank
$n$ as $B_n$.

Figure \ref{fig:link-bitree} shows a $B_0$ tree and how to link 2 $B_{n-1}$
trees to a $B_n$ tree.

\begin{figure}[htbp]
       \begin{center}
       	  \includegraphics[scale=0.5]{img/b0tree.ps}

          a. $B_0$ tree; 

          \includegraphics[scale=0.5]{img/link-bitree.ps}

          b. Linking 2 $B_{n-1}$ tree yields a $B_n$ tree

        \caption{Recursive definition of binomial trees} \label{fig:link-bitree}
       \end{center}
\end{figure}

With this recursive definition, it easy to draw the form of binomial trees
of rank 0, 1, 2, ..., as shown in figure \ref{fig:bitree-forms}

\begin{figure}[htbp]
       \begin{center}
       	  \includegraphics[scale=0.5]{img/b0tree.ps}

          a. $B_0$ tree; 

          \includegraphics[scale=0.5]{img/b1tree.ps}

          b. $B_1$ tree;

          \includegraphics[scale=0.5]{img/b2tree.ps}

          c. $B_2$ tree;

          \includegraphics[scale=0.5]{img/b3tree.ps}

          c. $B_3$ tree;

          \includegraphics[scale=0.5]{img/b4tree.ps}

          d. $B_4$ tree; ...

        \caption{Forms of binomial trees with rank = 0, 1, 2, 3, 4, ...} \label{fig:bitree-forms}
       \end{center}
\end{figure}

Observing the binomail trees reveals some interesting properties. For each rank $N$ binomial tree, if counting the number of nodes in each row, it can be found that it is the binomial number.

For instance for rank 4 binomail tree, there is 1 node as the root; and in the second level next to root, there are 4 nodes; and in 3rd level, there are 6 nodes; and in 4th level, there are 4 nodes; and the 5th level, there is 1 node. They are exactly 1, 4, 6, 4, 1 which is the 5th row in Pascal's triangle. That's why we call it binomial tree.

Another interesting property is that the total number of node for a binomail tree with rank $N$ is $2^N$. This can be proved either by binomial theory or the recursive definition directly.

\subsubsection{Binomial heap}

With binomial tree defined, we can introduce the definition of binomial heap. A binomial heap is a set of binomail trees (or a forest of binomial trees) that satisfied the following properties.

\begin{itemize}
\item Each binomail tree in the heap conforms to {\em heap property}, that the key of a node is equal or greater than the key of its parent. Here the healp is actually min-heap, for max-heap, it changes to `equal or less than'. In this post, we only discuss about min-heap, and max-heap can be equally applied by changing the comparison condition.
\item There is at most one binomail tree which has the rank $r$. In other words, there are no two binomial trees have the same rank.
\end{itemize}

This definition leads to an important result that for a binomial heap contains $N$ elements, and if convert $N$ to binary format is $a_0, a_1, a_2, ..., a_m$, where $a_0$ is the LSB and $a_m$ is the MSB, then for each $0 \leq i \leq m$, if $a_i=0$, there is no binomial tree of rank $i$ and if $a_i = 1$, there must be a binomial tree of rank $i$.

For example, if a binomial heap contains 5 element, as 5 is `(LSB)101(MSB)', then there are 2 binomial trees in this heap, one tree has rank 0, the other has rank 2.

Figure \ref{fig:bheap2} shows a binomial heap which have 19 nodes, as 19 is `(LSB)11001(MSB)' in binary format, so there is a $B_0$ tree, a $B_1$ tree and a $B_4$ tree.

\begin{figure}[htbp]
       \begin{center}
       	  \includegraphics[scale=0.5]{img/bheap2.ps}
        \caption{A binomial heap with 19 elements} \label{fig:bheap2}
       \end{center}
\end{figure}

There are two ways to define K-ary trees imperatively. One is by using
`left-child, right-sibling' approach\cite{CLRS}. It is compatible with 
the typical binary tree structure. For each node, it has two fields,
left field and right field. We use the left field to point to the first
child of this node, and use the right field to point to the sibling
node of this node. All silbings are represented as a single directional
linked list.

The other way is to use the library defined collection container, such
as array or list to represent all children of a node.

Since the rank of a tree plays very important role, we also defined
it as a field.

\subsection*{Definition of binomial heap in C++}

\subsection*{Definition of binomial heap in Python}
For `left-child, right-sibling' method, we defined the binomial tree
as the following.

\lstset{language=Python}
\begin{lstlisting}
class BinomialTree:
    def __init__(self, x = None):
        self.rank = 0
        self.key = x
        self.parent = None
        self.child = None
        self.sibling = None
\end{lstlisting}

When initalize a tree with a key, we create a leaf node, set its rank
as zero and all other fields are set as NIL.

It quite nature to utilize pre-defined list to represent mulitple children
as below.

\begin{lstlisting}
class BinomialTree:
    def __init__(self, x = None):
        self.rank = 0
        self.key = x
        self.parent = None
        self.children = []
\end{lstlisting}

\subsection*{Definition of binomial heap in Haskell}
Based on the definition of binomail tree and binomail heap, we translate them in 
Haskell program. 

\lstset{language=Haskell}
\begin{lstlisting}
data BiTree a = Node { rank :: Int
                     , root :: a
                     , children :: [BiTree a]} deriving (Eq, Show)

-- Implicit property: ranks are in monotonically increase order
type BiHeap a = [BiTree a] 
\end{lstlisting}

A binomial tree contains three components, one is the rank as integer, one
is the element as the key of root, others are sub trees as children. As the
comment in the program, a binomial heap is a forest of binomial trees in
monotonically increase order. And there are no two binomial trees have
same rank. 

\subsection*{Definition of binomial heap in Scheme/Lisp}

% ================================================================
%                 Basic heap operation
% ================================================================
\subsection{Basic heap operations}

Before dive into the basic heap operations such as pop and insert,
We'll first realize how to link two trees with same rank into a
bigger one. According to the definition of binomial tree and heap
property that the root always contains the minimum key, we firstly
compare the two root values, select the smaller one as the new
root, and insert the other tree as the first child in front of
all other children. If we use `left child, right sibling' approach,
this algorithm can be described like the following.

\begin{algorithmic}[1]
\Function{LINK}{$T_1, T_2$}
  \If{$KEY(T_2) < KEY(T_1)$}
    \State Exchange $T_1 \leftrightarrow T_2$
  \EndIf
  \State $SIBLING(T_2) \gets CHILD(T_1)$
  \State $CHILD(T_1) \gets T_2$
  \State $PARENT(T_2) \gets T_1$
  \State $RANK(T_1) \gets RANK(T_1) + 1$
  \State \Return $T_1$
\EndFunction
\end{algorithmic}

And if we use a container to manage all children of a node, the
algorihtm is like below.

\begin{algorithmic}[1]
\Function{LINK'}{$T_1, T_2$}
  \If{$KEY(T_2) < KEY(T_1)$}
    \State Exchange $T_1 \leftrightarrow T_2$
  \EndIf
  \State $PARENT(T_2) \gets T_1$
  \State $INSERT-BEFORE(CHILDREN(T_1), T_2)$
  \State $RANK(T_1) \gets RANK(T_1) + 1$
  \State \Return $T_1$
\EndFunction
\end{algorithmic}

The $LINK$ operation takes $O(1)$ time.

\subsubsection*{Link operation in C++}

\subsubsection*{Link operation in Python}
For the `left child, right sibling' approach, the Python version of $LINK$
algorithm is implemented as below.

\lstset{language=Python}
\begin{lstlisting}
def link(t1, t2):
    if t2.key < t1.key:
        (t1, t2) = (t2, t1)
    t2.sibling = t1.child
    t1.child = t2
    t2.parent = t1
    t1.rank = t1.rank + 1
    return t1
\end{lstlisting}

And we can use Python list to manage the children, so that the 
algoritm turns to be the following.

\begin{lstlisting}
def link(t1, t2):
    if t2.key < t1.key:
        (t1, t2) = (t2, t1)
    t2.parent = t1
    t1.children.insert(0, t2)
    t1.rank = t1.rank + 1
    return t1
\end{lstlisting}

\subsubsection*{Link operation in Haskell}
For Haskell program, we construct a new Node with the smaller root and
build the children with the bigger root as the first child like below.

\lstset{language=Haskell}
\begin{lstlisting}
link :: (Ord a) => BiTree a -> BiTree a -> BiTree a
link t1@(Node r x c1) t2@(Node _ y c2) = 
    if x<y then Node (r+1) x (t2:c1)
    else Node (r+1) y (t1:c2)
\end{lstlisting}

\subsubsection*{Link operation in Scheme/Lisp}

\subsubsection{Find the minimum element in the heap (top)}
Among the forest as the binomial heap, each binomial tree conforms to
heap property that the root contains the minimum element in that tree.
In order to find the minimum element in the heap, we can select the 
smallest root of these trees. Since there are $\lg N$ binomial trees
where $N$ is the element number, this approach takes $O(\lg N)$ time.

For the `left child, right sibling' approach, the algorithm can be
decribed as the following.

\begin{algorithmic}[1]
\Function{FIND-MINUMUM}{$H$}
  \State $T \gets HEAD(H)$
  \State $min \gets \infty$
  \While{$T \ne NIL$}
    \If{$KEY(T) < min$}
      \State $min \gets KEY(T)$
    \EndIf
    \State $T \gets SIBLING(T)$
  \EndWhile
  \State \Return $min$
\EndFunction
\end{algorithmic}

While if we manage the children with collection containers, the link
list iteration is abstract to find the minmum element among the list.

\subsubsection{Find the minimum element in C++}

\subsubsection{Find the minimum element in Python}
`left child, right sibling'

Python list

\subsubsection{Find the minimum element in Haskell}
Explain later together with extract min

\subsubsection{Find the minimum element in Scheme/Lisp}

\subsubsection{Merge two heaps}

\subsubsection{Insert a new element to the heap}

\subsubsection{Extract the minimum element from the heap (pop)}

\subsubsection{Decrease an element}

\subsubsection{Delete an element}

% ================================================================
%                 Fibonacci heaps
% ================================================================
\section{Fibonacci Heaps}
\label{fib-heap}

% ================================================================
%                 Definition
% ================================================================
\subsection{Definition}

% ================================================================
%          Basic Heap operations       
% ================================================================
\subsection{Basic heap operations}

\subsubsection{Find the minimum element in the heap (top)}

\subsubsection{Insert a new element to the heap}

\subsubsection{Merge two heaps}

\subsubsection{Extract the minimum element from the heap (pop)}

\subsubsection{Decrease an element}

\subsubsection{Delete an element}

\subsection{Running times}


% ================================================================
%                 Pairing Heaps
% ================================================================

\section{Pairing Heaps}
\label{pairing-heap}

% ================================================================
%                 Definition
% ================================================================
\subsection{Definition}

% ================================================================
%          Basic Heap operations       
% ================================================================
\subsection{Basic heap operations}

\subsubsection{Find the minimum element in the heap (top)}

\subsubsection{Insert a new element to the heap}

\subsubsection{Merge two heaps}

\subsubsection{Extract the minimum element from the heap (pop)}

\subsubsection{Decrease an element}

\subsubsection{Delete an element}

% ================================================================
%                 Short summary
% ================================================================
\section{Notes and short summary}

% ================================================================
%                 Appendix
% ================================================================
\section{Appendix} \label{appendix}
%\appendix
All programs provided along with this article are free for
downloading.

\subsection{Prerequisite software}
GNU Make is used for easy build some of the program. For C++ and ANSI C programs,
GNU GCC and G++ 3.4.4 are used. 
For Haskell programs GHC 6.10.4 is used
for building. For Python programs, Python 2.5 is used for testing, for
Scheme/Lisp program, MIT Scheme 14.9 is used.

all source files are put in one folder. Invoke 'make' or 'make all'
will build C++ Program. 

There is no separate Haskell main program module, however, it is possible to run the program in GHCi.

\begin{itemize}
\item files

\end{itemize}

download position: http://sites.google.com/site/algoxy/otherheaps/otherheaps.zip

\begin{thebibliography}{99}

\bibitem{CLRS}
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. ``Introduction to Algorithms, Second Edition''. The MIT Press, 2001. ISBN: 0262032937.

\bibitem{okasaki-book}
Chris Okasaki. ``Purely Functional Data Structures''. Cambridge university press, (July 1, 1999), ISBN-13: 978-0521663502

\bibitem{wiki-pascal-triangle}
Wikipedia, ``Pascal's triangle''. http://en.wikipedia.org/wiki/Pascal's\_triangle

\bibitem{lxy-bheap}
Liu Xinyu. ``Binary heaps with functional and imperative implementation'', https://sites.google.com/site/algoxy/bheap

\end{thebibliography}

\ifx\wholebook\relax \else
\end{document}
\fi
