谁主张，谁举证 -- ACM crashing balloon / zoj 1003题的歧义

先快速在TL写一下。
题目详情可以参考这里：
http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=3

ZOJ上的判定标准是：
  b不服，站出来质疑；
  如果a能举证说：你瞧，存在一种合理的解释，a = a[1]*a[2]*...*a[n],  b = b[1]*b[2]*...*b[m]; 其中 2<= a[i], b[j] <=100, 且 a[i] !=b[j] if i!=j
  就判断a赢，否则b赢

但是，这里会有对b不利的冤案！例如b踩了气球4和8，于是b = 32 而 a吹牛说自己得了44分，
b不服，但是a狡猾的说，你看，a = 4*11, b=2*16，于是a赢了！b虽然说了实话，a说了假话，但是仍然b输了。

所以我觉得，这道题目应该是按照：谁主张，谁举证的原则来判决。
  既然b主张，那么此时法官应该问b，你踩了哪些气球，b当然可以诬告，但是b此时必须说出一种分解，如果b不能分解，那么显然
  是诬告，法官不用问a，就判断a赢；
  但是针对b说的任意(arbitrary)分解，如果a不能给出一种合理的解释，此时法官就可以判断b赢，否则判断a赢。

针对我说的谁主张，谁举证的原则，我给出两个程序，Python的和Haskell的，他们都不能通过ZOJ但是我认为他们是对的。
最后我再给一个能通过ZOJ的Pythong程序，请大家比较。

欢迎拍砖！
（另：所有程序本质都是深度优先搜索法，使用显示递归）

程序1，Python，谁主张，谁举证：
# ACM/ICPC, ZOJ 1003
# [1]. http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1003

# Soluton 1:
#   Suppose a > b,
#   for any valide factor decomposition of b, there exists a valid decomposition of a => a
#   Otherwise => b
#
# Note that the ZOJ doesn't use this rule, solution 1 won't pass online judge, but I do
#    Think solution 1 has its value.

import sys

def valid(a, b, n):
    if n == 1:
        if b == 1 and a !=1:
            return False
        else:
            return True
    else:
        if b % n == 0 and not valid(a, b/n, n-1):
            return False
        elif a % n == 0 and valid(a/n, b, n-1):
            return True
        else:
            return valid(a, b, n-1)

程序2， Haskell，谁主张，谁举证：

valid a b [] = if b == 1 && a /= 1 then False else True
valid a b (x:xs) | b `mod` x == 0 && (not $ valid a (b `div` x) xs) = False
                 | a `mod` x == 0 && valid (a `div` x) b xs = True
                 | otherwise = valid a b xs

judge a b = if valid a b [2..100] then a else b

main = interact judgeInput where
  judgeInput = unlines . map doJudge . lines
  doJudge ln = let (a:b:_) = map (read::(String->Integer)) (words ln) in
    show $ judge (max a b) (min a b)

程序3，Pythong， ZOJ accepted

# Solution 2:
#   If there exists a decomposition for both a and b ==> a
#   else if there exists a decomposition for b ==> b
#   otherwise ==> a

def valid2(a, b, n):
    return Judge().result(a, b, n)

class Judge:
    def __init__(self):
        self.both_OK = False
        self.b_OK = False

    def exist(self, a, b, n):
        if self.both_OK:
            return True

        if a == 1 and b==1:
            (self.both_OK, self.b_OK) = (True, True)
            return True

        if b == 1:
            self.b_OK = True

        for x in xrange(n, 1, -1):
            if b % x == 0 and self.exist(a, b/x, x-1):
                return True
            if a % x == 0 and self.exist(a/x, b, x-1):
                return True

        return self.both_OK

    def result(self, a, b, n):
        self.exist(a, b, n)
        return not ( self.b_OK and not self.both_OK)

def main():
    for line in sys.stdin:
        [s1, s2] = line.split()
        (a, b) = (int(s1), int(s2))
        if a < b:
            (a, b) = (b, a)
        if valid2(a, b, 100):
            print a
        else:
            print b

if __name__ == "__main__":
    main()
